<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<title>The sscan record for sscan module R2.7</title>

	<style type="text/css">
	<!--
	blockquote { font-size:smaller;}
	-->
	</style>

</head>
<body>
<h1>
The sscan record for sscan module R2.7</h1>
Author: Tim M. Mooney<br>
Based on the scan record, written by Ned D. Arnold.<br>
<p>&nbsp;Advanced Photon Source
<br>&nbsp;Argonne National Laboratory

<P>Contents:

<br><a href="#HEADING_1"><b>1.&nbsp;&nbsp;&nbsp;</b> Introduction</a>

<br><a href="#HEADING_1-1"><b>1.1.</b> A Simple One 
Dimensional Scan</a>

<br><a href="#HEADING_1-2"><b>1.2.</b> Multidimensional
Scans</a>

<br><a href="#HEADING_1-3"><b>1.3.</b> Interaction with clients</a>

<br><a href="#HEADING_1-3-1"><b>1.3.1</b> Starting a scan</a>

<br><a href="#HEADING_1-3-2"><b>1.3.2</b> Stopping a scan</a>

<br><a href="#HEADING_1-3-3"><b>1.3.3</b> Pausing a scan</a>

<br><a href="#HEADING_1-3-4"><b>1.3.4</b> Displaying scan data</a>

<br><a href="#HEADING_1-3-5"><b>1.3.5</b> Handshaking with data-storage clients</a>

<br><a href="#HEADING_1-3-6"><b>1.3.6</b> Handshaking with CA clients that implement positioners or detectors</a>


<br><a href="#HEADING_1-4"><b>1.4.</b> Completion of positioner and
detector-trigger operations</a>

<br><a href="#HEADING_1-5"><b>1.5.</b> Fly scans</a>

<br><a href="#HEADING_1-5-1"><b>1.5.1.</b> Scalar-mode fly scans</a>

<br><a href="#HEADING_1-5-2"><b>1.5.2.</b> Array-mode fly scans</a>

<br><a href="#HEADING_2"><b>2.&nbsp;&nbsp;&nbsp;</b> sscan-Record Fields</a>

<br><a href="#HEADING_2-1"><b>2.1.</b> Control Fields</a>

<br><a href="#HEADING_2-2"><b>2.2.</b> Positioner Fields</a>

<br><a href="#HEADING_2-2-1"><b>2.2.1</b> <tt>LINEAR</tt> Mode</a>

<br><a href="#HEADING_2-2-2"><b>2.2.2.</b> <tt>TABLE</tt> Mode</a>

<br><a href="#HEADING_2-2-3"><b>2.2.3.</b> <tt>FLY</tt> Mode</a>

<br><a href="#HEADING_2-3"><b>2.3.</b> Detector-Trigger Fields</a>

<br><a href="#HEADING_2-4"><b>2.4.</b> Delay Fields</a>

<br><a href="#HEADING_2-5"><b>2.5.</b> Client Handshaking Fields</a>

<br><a href="#HEADING_2-6"><b>2.6.</b> Detector Fields</a>

<br><a href="#HEADING_2-7"><b>2.7.</b> Execution Fields</a>

<br><a href="#HEADING_2-8"><b>2.8.</b> Status/Progress Fields</a>

<br><a href="#HEADING_2-10"><b>2.10.</b> Miscellaneous Fields</a>


<!---------------------------------------------------------------------------->
<br><br><br><hr>
<p><a NAME="HEADING_1"></a>
<h1>1. Introduction</h1>
<hr>

The purpose of the sscan record is to move <i>positioners</i> through a series
of positions and record <i>detector</i> data at each of the positions. This
series of operations is commonly referred to as a <i>scan</i>, or as one loop of
a multi-dimensional scan.  After parameters defining the scan have been
initialized and the scan has been launched, the sscan record begins a possibly
long and involved sequence of operations normally without further input, and 
notifies any interested clients as the scan progresses. The data are collected
into arrays within the record so that clients needn't handle them point by
point.  A separate piece of software ("saveData", which is included with the
sscan record in the synApps sscan module) can coordinate with the sscan record
to write scan data to disk.

<blockquote>

Note that the word "scan" is used frequently in other EPICS documentation to
mean something quite different from what is meant here.  In the <i>EPICS
Application Developers Guide</i>, "scan" connotes record processing or
execution, as in "Database scanning is the mechanism for deciding when to
process a record." Also, periodic record processing is performed by "scan
tasks", and the field that controls when a record will be processed is named
"SCAN".  None of these uses of "scan" have anything to do with the sscan record,
and the word will not have the EPICS meaning in the rest of this
documentation.

</blockquote>


<p>A single sscan record supports a one dimensional scan. Several sscan records
can be linked together to perform a multi-dimensional scan.  Each sscan record
can control up to four positioners, trigger up to four detectors, and acquire
data from up to 74 process variables (70 detector values of type <tt>float</tt>
and four positioner readbacks of type <tt>double</tt>).

<p>In the most common use, the sscan record moves motors and acquires scaler
(pulse counter) data at each motor position, but obviously it can also be used
for other purposes. Any writable EPICS PV (process variable) can be scanned
through a set of values while data are recorded from any other PVs.  For
example, one of the positioner PVs could be used to vary the gain or dwell time 
of a detector during a scan.  Therefore, throughout this document the term
<i>positioner</i> should be taken to mean "any PV to which you can write a
number". Similarly, the term <i>detector trigger</i> will typically refer to a
PV that will cause data acquisition to begin when it is written to, but it could
be taken to mean "any PV to which you can write a number". Finally, the term
<i>detector</i> refers to any readable numeric PV.  ("Signal" might be a better
word for this.)

<P>The sscan record normally acquires sets of scalar data values and assembles
them into arrays, but it can also acquire arrays directly from array-valued
PVs.  The end results can only be one-dimensional arrays, however; a single
sscan record cannot acquire multi-dimensional data.

<p>All of the process variable names used to identify positioners,
detectors, and detector triggers are specified using <i>reassignable links</i>.
This allows a scan to be configured at run time, immediately before it is
executed.  Currently, these links are implemented with the recDynLink library,
which is distributed along with the <b>sscan</b> module.

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_1-1"></a>

<h2>1.1. A Simple One Dimensional Scan</h2>

In the simplest reasonably complete configuration for a one-dimensional scan,
the following fields are used:

<DL>

<DT><tt>P1PV</tt> <DD>the name of a positioner (e.g., "myMotor.VAL")

<DT><tt>P1SP</tt> <DD>start position -- the first position at which data will be
acquired

<DT><tt>P1EP</tt> <DD>end position -- the last position at which data will be
acquired

<DT><tt>NPTS</tt> <DD>the total number of positions to visit

<DT><tt>T1PV</tt> <DD>the name of a detector-trigger PV.  This PV will be
written to after the positioner has arrived at each position, and it is
expected to initiate some data-acquisition operation.

<DT><tt>D01PV</tt> <DD>the name of a detector (signal) PV.  The value of this PV
will be recorded after the detector trigger has finished acquiring data.

</DL>

When a scan is started (by writing a <tt>1</tt> to the <tt>EXSC</tt> field) the
sscan record commands the positioner to move to its starting position.  The
sscan record uses recDynLinkPutCallback() to tell the positioner to move, and
waits for the resulting callback, indicating that the positioner is finished,
before moving on to the next phase of the scan, which is to trigger the
detector.&nbsp; The detector is also triggered using  recDynLinkPutCallback(),
and the sscan record waits for it to finish before reading detectors and going
on to perform another (move, trigger, read) sequence to acquire the next data
point. This algorithm continues until the sscan record has completed
<tt>NPTS</tt> steps, or the scan is aborted (by a client writing <tt>0</tt> to
<tt>the EXSC</tt> field). At the end of the scan, the sscan record has filled in
an array of the positions visited (<tt>P1RA</tt>), and an array of detector
values acquired (<tt>D01DA</tt>).

<P>Let's run through that again, this time more generally, with more detail, and
including more of the available options.
<DL>

<DT>Positioners

<DD>You can specify zero to four positioners.  Positioners are expected to tell
the sscan record when they're done moving (more about this later).  After all
positioners have declared themselves done, the sscan record waits for a
user-specified settling time (<tt>PDLY</tt>, normally zero) before writing to
detector triggers.  (If no positioners, then no positioner settling time.)

<DT>Positions to visit <DD>There are lots of possibilities here.  You can
specify any combination of the set [<em>start, end, center, width, step-size</em>] for
each positioner; you can load a table of positions for each positioner; or you
can specify that positioners are to be moved continuously during a scan.  You
can specify that positions be regarded as absolute, or as relative to the
pre-scan position.

<DT>Detector triggers

<DD>Detector triggers act much like positioners, in that they write a value and
wait for any ensuing processing to finish, but they send the same value at every
data point (<tt>T<em>n</em>CD</tt>).  After all triggered detectors have
declared themselves done, the sscan record waits for a user-specified
settling time (<tt>DDLY</tt>, normally zero) before reading data from
detector-signal PVs.  (If no detector triggers, then no detector settling time.)


<DT>Detector signals

<DD>Typically, detector signals are scalar PVs, but they can be array-valued
PVs.  If so, the sscan record will read them at the end of the scan.  If
array-valued PVs require processing to acquire their values, the sscan record
can write to a special array trigger (<tt>A1PV</tt> <tt>A1CD</tt>, exactly
analogous to detector triggers), and wait for any ensuing processing to finish
before reading the arrays.  If all detector signals are array valued, it's
probably better to use the array acquisition type. (See <tt>ACQT</tt>.)

<P>Detector-signal values can be accumulated from scan to scan, so you can sweep
over a set of positions, building up statistical precision and averaging over
any positioning errors or variable external conditions.  (See <tt>ACQM</tt>.)

<DT>After the scan
<DD>You can tell positioners what to do after the scan is finished, using the
<tt>PASM</tt> field.  The default behavior is simply to remain where the scan
left them, but you could tell them to return to their pre-scan positions, go
to their start positions, or go to positions calculated from acquired data
(e.g., the position at which a specified detector signal <tt>REFD</tt> reached
its peak value during the scan).
</DL>

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_1-2"></a>
<h2>1.2. Multidimensional Scans</h2>

Multidimensional scans are easy: an outer-loop sscan record (which we'll call
"scan2") regards an inner-loop sscan record ("scan1") as a detector to be
triggered, and each sscan record acquires its own data.  Thus,
<tt>scan2.T1PV</tt>, is set to <tt>scan1.EXSC</tt>, and <tt>scan2.T1CD</tt> is
set to 1.  In words, scan2 writes a <tt>1</tt> to the "execute scan" field
(<tt>EXSC</tt>) of scan1.

<p>To initiate the scan, the scan2 record is commanded to begin 
(<tt>scan2.EXSC</tt> is set to <tt>1</tt>).  scan2 sends its <i>positioners</i> to
their starting points, and waits for their callbacks.  Then scan2 writes to its
<i>detector trigger</i>(s), (one of) which in this case causes scan1 to begin its own scan.
The scan1 record will now go through its entire programmed scan, acquiring data
from its detectors at each point.

<p>When scan1 is finished, and its data have been written (or at least
secured), its completion callback causes scan2 to continue in its scan procedure
-- reading detector values, moving positioners to new positions, and causing
scan1 to execute again.

<p>This approach to configuring multidimensional scans is very flexible and
permits scans of any dimension.  Note that scan1 can be executed independently
of scan2, so a complex multidimensional scan can be built and tested one
dimension at a time.  (In principle, it's possible to run several inner-loop
scans in parallel from a single outer-loop scan, but in practice, the capability is
of limited use, because there is no coordination between the inner-loop scans, and no
data-storage client exists that would correctly understand the acquired data.)

<P>An outer sscan record involved in a multidimensional scan doesn't know or
care that the detector trigger it's writing to is actually another sscan record,
which is going to do an entire inner scan; the outer sscan record simply
triggers what it regards as a detector, and waits for that detector to
complete.  Nor do the inner sscan records know that they are parts of something
larger than themselves.  The only piece of code that has to know a
multidimensional scan is occurring is the client that stores the data.  This
client must collect all of the data from each inner scan before those data are
overwritten by the next execution of that inner scan, because sscan records hold
only one-dimensional arrays of data.

<P>Clearly, this calls for some handshaking between the client and the
sscan records involved in a multidimensional scan.  The next section
describes the handshake mechanisms implemented by the sscan record.

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_1-3"></a>
<h2>1.3. Interaction with clients</h2>

<P>Clients of the sscan record include the software that starts, stops,
or pauses a scan; software that displays data acquired by a scan; software that
writes scan data to disk; and software that participates in the a scan by
implementing positioner or detector operation. A single client may do any or all
of these things, of course, but it seems best to discuss them separately.

<p><a NAME="HEADING_1-3-1"></a>
<h3>1.3.1 Starting a scan</h3>

The client writes the number <tt>1</tt> to the sscan record's
<tt>EXSC</tt> field to start a scan.  If the sscan record is able to start a new
scan, it sets its <tt>BUSY</tt> field to <tt>1</tt> while the new scan is in
progress, and it sets <tt>BUSY</tt> to <tt>0</tt> when the scan is done.

<P>If the sscan record is not able to start a new scan, the client will receive
an error indication, and the command will be ignored.  The sscan record
will set its <tt>SMSG</tt> field to a string describing the reason why it cannot
start a new scan.  Possible reasons include the following:

<dl>
<dt>"Scan is paused"<dd>The sscan-record field <tt>PAUS</tt> has a nonzero value,
indicating that some client has told the sscan record to stand by until
<tt>PAUS</tt> is set back to <tt>0</tt>.

<dt>"Already scanning"<dd>A scan is already in progress.  Setting <tt>EXSC</tt> to
<tt>1</tt> while  scan is in progress has no effect on that scan.

<dt>"Waiting for saveData"<dd>A new scan cannot be started because the
data-storage client, "saveData", is still using one of the two sets of
data arrays, and the other set is full of scan data also waiting for service
by saveData.

<dt>"Waiting for callback"<dd>The previous scan is essentially complete,
but one of the commands the sscan record issued has not yet completed.
</dl>

<P>In all of these cases, the start command is ignored, and the scan will not
automatically start when the condition that prevented it from starting is
removed.  A new start command must be issued.

<p><a NAME="HEADING_1-3-2"></a>
<h3>1.3.2 Stopping a scan</h3>
A client tells the sscan record to stop scanning by writing <tt>0</tt> to the
<tt>EXSC</tt> field.  But stopping a scan is sometimes a complicated process, because,
while a scan is in progress, the sscan record issues commands to other
software, and waits for the <i>callbacks</i> that will come when those
commands complete.  Also, the sscan record handshakes with the data-storage
client (if present) to ensure that data arrays are not overwritten before
their content has been written to disk.  When a sscan record receives a "stop"
command, it can stop itself easily, but it cannot unsend or abort the commands
it already sent, and it's not permitted to assume that commands already sent,
or data not yet written, may simply be abandoned.  If it's waiting for
either of these, it will continue to wait until the user tells it to stop by
writing <tt>0</tt> again to the <tt>EXSC</tt> field.  If it's waiting for data storage,
two writes of <tt>0</tt> to <tt>EXSC</tt> are required.

<P>When a sscan record is told to stop while it has outstanding callbacks, it
sets its <tt>SMSG</tt> field to the string "Abort: waiting for callback".  When
the callback arrives, <tt>SMSG</tt> will change to "Scan aborted by operator",
and the <tt>BUSY</tt> field will be set to <tt>0</tt>.

<P>When a sscan record is told to stop while it is waiting for service by the
data-storage client, "saveData", it sets its <tt>SMSG</tt> field to the string
"Killing scan (kill=<i>n</i>/3)", where <i>n</i> is 1, 2, or 3..  When saveData
has serviced the sscan record, <tt>SMSG</tt> will change to "Scan aborted by
operator", and the <tt>BUSY</tt> field will be set to <tt>0</tt>.  If saveData does not
service the sscan record, writing <tt>0</tt> to <tt>EXSC</tt> a total of three times will
cause the scan to complete with the message "Abandoning unsaved scan data".

<P>If the sscan record is waiting for both outstanding callbacks and the
data-storage client, the messages it writes to <tt>SMSG</tt> may overwrite each
other, and not clearly indicate what is happening.  The user's course of
action, however, is always the same:

<ul>

<li> A single write of <tt>0</tt> to the <tt>EXSC</tt> field requests a polite scan abort,
waiting for callbacks and data storage.

<li>Two successive writes of <tt>0</tt> to <tt>EXSC</tt> request a scan abort
with no wait for outstanding callbacks.  However, the sscan record will
still wait for the data-storage client.

<li>Three successive writes of <tt>0</tt> to <tt>EXSC</tt> demand an immediate
scan abort with no regard for consequences.  Scan data will be lost in this
case.

</ul> 

<P>When a scan is aborted, and more than one write to <tt>EXSC</tt> was
required, the <i>next</i> scan may inherit the problem.  If the problem was an
outstanding callback, and that callback <i>still</i> has not come in by the next
time the sscan record is told to start, the scan will not be permitted to
write to the PV whose callback is still outstanding.  This may indicate that a
PV is imperfectly implemented, and cannot be scanned; or that some error
prevented the operation from completing; or that the sscan record missed
the completion message; or simply that the operation is taking a long time to
finish.  If the operation cannot be manually stopped, the only recourse is to
erase the PV name and rewrite it.  This closes and reopens the channel-access
connection to that PV, and frequently will resolve the immediate problem.

<p><a NAME="HEADING_1-3-3"></a>
<h3>1.3.3 Pausing a scan</h3>

A scan can be paused by writing "PAUSE", or the number 1, to the <tt>PAUS</tt> field.
While a sscan record is paused, it will do nothing to further the progress
of the scan, but it will remain receptive to outstanding callbacks.  A paused
scan is continued by writing "GO", or the number <tt>0</tt>, to the <tt>PAUS</tt> field.

<P>Pausing a multidimensional scan should work in the same way as pausing a
single sscan record, but there have been reports that the process fails
sometimes for multidimensional scans, leaving the scan active but not resuming
when <tt>PAUS</tt> is rescinded.  The issue is being studied.

<p><a NAME="HEADING_1-3-4"></a>
<h3>1.3.4 Displaying scan data</h3>

Scan data is published by the sscan record using EPICS Channel Access,
just as any other EPICS record would publish the values of its fields.  The act
of publishing data via Channel Access is referred to here as
<i>posting</i>, because the EPICS function that performs this function is
<TT>db_post_events()</TT>. After a field has been posted, a client can get the
new value by issuing the Channel Access call <tt>ca_get()</tt>.  A client can
also arrange, in advance, to receive posted data from a particular field,
whenever it is posted, by <i>monitoring</i> -- also called <i>subscribing to</i>
-- the field.  See the Channel Access Reference Manual (specifically,
<tt>ca_add_event()</tt> or <tt>ca_create_subscription()</tt>) for the details of
how this is done.  The purpose here is simply to introduce the terms <i>post</i>
and <i>monitor</i>, so that I can use them in this documentation.

<P>The sscan record maintains two sets of array PV's for scan data: data
from a completed scan are posted as P<i>n</i>RA and D<i>nn</i>DA (e.g.,
<tt>P1RA</tt>, <tt>D01DA</tt>); data from a scan in progress are posted as
P<i>n</i>CA and D<i>nn</i>CA.  During a scan, arrays are posted only if the user
requests this by setting the array-posting period, <tt>ATIME</tt>, to a value greater than or equal to
0.1 (seconds).  After a scan has completed, all data arrays are posted, marked with the
mask <tt>DBE_LOG</tt>, and the completed-scan postings (P<i>n</i>RA and
D<i>nn</i>DA) remain available to clients until the next scan completes.   

<blockquote>Because the sscan record implements double-buffered data
arrays, and because of the way in which posting is accomplished in EPICS, the
posting of scan-in-progress data arrays results unavoidably in useless reposting
of completed-scan data arrays.  If this presents a problem for a data-display or
data-storage client, there are two ways to avoid the problem: 1) Tell the sscan
record not to post arrays during scans by leaving the array-post period, ATIME,
at its default value of zero; 2) modify the client so that it monitors only
postings flagged with the DBE_LOG mask.</blockquote>

A more efficient, but more difficult, way for a client to get data from a scan
in progress is to monitor the scalar current-value PVs, such as <tt>R1CV</tt>,
<tt>D01CV</tt>, etc., and collect their values into arrays.

<P>Positioners actually have two fields that might be suitable for display while a
scan is in progress: the positioner's desired value (<tt>P<i>n</i>DV</tt>) and
the readback's current value (<tt>R<i>n</i>CV</tt>).  (If there is no readback
PV, the posted readback value will be a copy of the desired value.)

<P>Not all data points of a scan are guaranteed to be posted as scalar values,
because the sscan record <i>throttles</i> it's posting, so that it
doesn't exceed 20 data points per second.  This throttling is intended to limit
the network activity caused by a scan, and it's necessary because displaying
scan data is not more important that acquiring it, and because the sscan
record also uses the network to acquire data.

<P>The task of accumulating posted scalar values into data arrays is complicated
by the standard EPICS behavior of declining to post a field whose value has not
changed since the last time the field was posted.   If a client were simply to
append each new posting to the data arrays it is accumulating, it would not
be including those repeated values.  The following algorithm will accumulate
data correctly:

<ol>

<li> Create local variables to hold cached values of the fields to be monitored,
and a local variable (which I'll call "numPoints") to hold the number of data
points accumulated.

<li> Monitor <tt>D<i>nn</i>CV</tt>, <tt>R<i>m</i>CV</tt> and <tt>VAL</tt>  (<i>scalar data and control
fields</i>).

<li> Monitor <tt>D<i>nn</i>DA</tt>, <tt>P<i>m</i>RA</tt>, <tt>DATA</tt>, and <tt>CPT</tt> (<i>array
data and control fields</i>).

<li> Whenever <tt>D<i>nn</i>CV</tt>, <tt>R<i>m</i>CV</tt>, or <tt>CPT</tt> are received, cache the
received scalar value in a local variable.

<li> Whenever <tt>D<i>nn</i>DA</tt> or <tt>P<i>m</i>RA</tt> are received, cache the received array
value in a local variable.

<li> When <tt>DATA==0</tt> is received, clear all data arrays, and reset numPoints to zero.

<li> When <tt>VAL</tt> is received, append to all data arrays from cached scalar values, and increment
numPoints.

<li> When <tt>DATA==1</tt> is received, clear all data arrays and replace with cached array values; set
numPoints to the cached value received from <tt>CPT</tt>.

</ol>

<p><a NAME="HEADING_1-3-5"></a>
<h3>1.3.5 Handshaking with data-storage clients</h3>

<P>1) <B>The new way, using the <tt>AWAIT</tt> and <tt>AAWAIT</tt> fields:</B>
<P>The data-storage client waits for <tt>DATA==1</tt>, which indicates that the
scan is over and the sscan record has finished posting all array fields;
writes <tt>1</tt> to the <tt>AWAIT</tt> field to prevent the sscan record
from overwriting array fields before the client has read them; and writes
<tt>0</tt> to <tt>AWAIT</tt> when it is finished reading.  One advantage of this
handshake is that it allows the sscan record to proceed with the next
scan (the sscan record's data arrays are double buffered) until it's time
to post data.  In this way, the data-storage client can be writing one set of
scan data while the sscan record is acquiring the next set.

<P>For <em>very</em> fast scans, or a very slow data-storage client, there might
not be sufficient time, between the posting of one data set and the acquisition
of the next, for the client to write <tt>1</tt> to <tt>AWAIT</tt> (array wait)
field.  In this case, you can cause the sscan record automatically to set
<tt>AWAIT==1</tt>, whenever it posts data, by setting the <tt>AAWAIT</tt> (auto
array wait) field to <tt>1</tt>.  (It's OK if the client also sets
<tt>AWAIT==1</tt>.) <b>saveData</b>, the data-storage client included in the
synApps <b>sscan</b> module, sets <tt>AAWAIT</tt> for each of the sscan records
it monitors.

<P>NOTE:  Because saveData sets <tt>AAWAIT</tt> for the sscan records it
monitors, a scan cannot execute to completion until saveData has written the
previous scan's data to disk (or has tried and failed a preset number of times
to do this).  The <b>sscan</b> module currently does not provide a mechanism by which
the end user can turn data storage off and on.  Data storage is turned on at
boot time, for each sscan record, by telling saveData to monitor that sscan
record.  The only way to turn data storage off is to edit the startup file
and reboot.

<P> Only one data-storage client can use <tt>AWAIT</tt>.  If you have more than one
data-storage client, you must arrange for them to pool their use of the <tt>AWAIT</tt>
field, so that it gets reset to zero only when all have finished.  (It's OK if
<tt>AWAIT</tt> gets set to one more than once.  Only the first <tt>AWAIT==1</tt> write has any
effect.)

<P>Note that this <tt>AWAIT</tt> handshake protects scan data no matter how the
sscan record gets executed, unlike the old method described next.

<P>2) <B>The old way, using the <tt>WAIT</tt>, <tt>WCNT</tt>, and <tt>AWCT</tt>
fields:</B>

<P>Before the <tt>AWAIT</tt> field was introduced, the only means of
handshaking was an extension of the mechanism by which the sscan record waits
for detector triggers to signal completion.  In this extension, the sscan
record waits until all detector triggers have signalled completion,
<em>and</em> the field <tt>WAIT</tt> is equal to zero.  This extension's
intended purpose is to support detectors that can't signal completion with a
callback, but that can write to a PV -- for example, a detector that's
implemented as a channel-access client -- and it can still be used for that
purpose, while a data-storage client is using it to protect data acquired from
an inner-loop scan. 

<p>Here's how the handshake works in a data-storage application:  The data-storage
client notices that an inner sscan record has started a scan (typically, it monitors
the <tt>DATA</tt> field, which is set to zero at the beginning of a scan), and
writes a <tt>1</tt> to the outer sscan record's <tt>WAIT</tt> field.  This prevents the
outer sscan record from continuing until the client has read the inner scan's data. 
The client waits for <tt>DATA==1</tt>, which indicates that new data are available. 
When the client has finished reading the inner scan's data, it writes a <tt>0</tt> to the
outer sscan record's <tt>WAIT</tt> field, allowing the scan to continue.

<P>If there are several clients that want the scan to <tt>WAIT</tt> for them, they
can all write to the <tt>WAIT</tt> field.  Each <tt>1</tt> increments the scan's wait-count
field, <tt>WCNT</tt>; each <tt>0</tt> decrements it.  When <tt>WCNT</tt> reaches zero, the
scan continues.

<p>In fast scans, there might not be time for a client to notice that an inner scan
has started and write that <tt>1</tt> to the outer scan's <tt>WAIT</tt> field before the
inner scan completes and is triggered again.  In this case, the outer scan can be
made automatically to write a <tt>1</tt> to it's own <tt>WAIT</tt> field whenever it
triggers detectors.  It will do this if its AutoWaitCounT (<tt>AWCT</tt>) field is
set to <tt>1</tt>.  In this case, the client must NOT write another <tt>1</tt> to the outer scan's
<tt>WAIT</tt> field (that would increment the wait count to 2), but must only write
<tt>0</tt> to the <tt>WAIT</tt> field to indicate that it is ready for the scan to
continue.

<P>If there are N clients, the autoWaitCount can be set to N, and the scan
will continue only after N <tt>0</tt>'s have been written to the <tt>WAIT</tt> field.

<P>The advantage of the autoWaitCount==0 method is that scans can be performed
whether or not a client is available to write to the <tt>WAIT</tt> field.  The
disadvantage is that the is not reliable for very fast scans.

<P>Note that this form of handshaking doesn't do a very thorough job of data
protection, because it does not directly prevent a sscan record
from overwriting its own arrays; it only prevents an outer-loop
sscan record from <em>telling</em> an inner-loop record to start a
new scan line.  If the sscan record is executed by some other
agent, the <tt>WAIT</tt> handshake doesn't protect data at all.

<p><a NAME="HEADING_1-3-6"></a>
<h3>1.3.6 Handshaking with CA clients that implement positioners or detectors</h3>

A channel-access client can participate in scans driven by the sscan record if
two criteria are met:

<OL>

<LI>The client is driven by a PV to which one of the sscan record's
positioner or detector-trigger links writes.

<LI>The client can signal completion in a way that the sscan record understands.

</OL> 

<P>There are two mechanisms the client can use to signal completion that will
work with the sscan record:

<DL>

<DT><b>putNotify-based completion signalling</b>

<DD><P>This is the method the sscan record expects everything it
drives to use for signalling completion, and it is the method the
sscan record itself uses to signal completion.  Clients can't
signal completion directly using putNotify, because their execution is not
managed by EPICS. But they can do it indirectly, by
writing to a <i>busy</i> record.

<P>A <i>busy</i> record is a custom EPICS record, supplied as part of the synApps
package, that looks and operates almost exactly like the binary-output ("bo")
record, except that it executes its forward link, <tt>FLNK</tt>, only when its
<tt>VAL</tt> field has the value zero.  As it happens, EPICS' putNotify
completion mechanism is implemented as part of the processing of forward links,
so the fact that the <i>busy</i> record allows a CA client to control the execution of
its forward link means that the client can control the timing of a putNotify
callback.

<P>Here's how it works in practice:

<ul>

<li>A developer loads a <i>busy</i> record (let's call it <tt>xxx:detBusy</tt>) into
the IOC.

<li>The sscan record writes a <tt>1</tt> to <tt>xxx:detBusy.VAL</tt>.

<li>The client monitors <tt>xxx:detBusy.VAL</tt>, and begins some operation when
it goes to <tt>1</tt>.

<li>When the client's done, it writes <tt>0</tt> to <tt>xxx:detBusy.VAL</tt>.
 
<li>This causes the record to process, and to request that EPICS execute its
forward link.

<li>EPICS discovers that the <i>busy</i> record is finished when it executes the
forward link, and it sends a callback to the sscan record.

</ul>

<P>Thus, the <i>busy</i> record appears to be executing all the time the client
actually <em>is</em> executing, so the sscan record can know when the client is
done.

<P>Very simple, but it does require that a dedicated record be loaded in some IOC.
Here's a database that loads a <i>busy</i> record:

<pre>
record(busy, "xxx:CCD_Busy")
{
}
</pre>

Many of the databases in synApps contain <i>busy</i> records for this purpose,
particularly those that act as front ends for State Notation Language (SNL)
code.  Though motivated by the needs of the sscan record, this
completion-signalling capability can be used by any CA client participating in
any EPICS application.

<P><DT><b><tt>WAIT</tt>-field handshake with the sscan record</b>

<DD><P>This handshake is intended for CA clients that implement detectors, and
that do <i>not</i> signal completion using a <i>busy</i> record. Here's how it works:

<ul>

<li>The client monitors a PV to find out when someone wants it to
acquire data.

<li>The sscan record writes some value to the PV to start
acquisition.

<li>The client writes <tt>1</tt> to &lt;scanrecord&gt;<tt>.WAIT</tt>, indicating
that it wants the sscan record to wait.

<li>The client performs its
data-acquisition task.

<li>The client writes <tt>0</tt> to
&lt;scanrecord&gt;<tt>.WAIT</tt>, indicating that it's done.

</ul>

<P>Several clients can use the <tt>WAIT</tt> field, each write of <tt>1</tt>
increments a wait count <tt>WCNT</tt>; each write of <tt>0</tt> decrements
<tt>WCNT</tt>; the sscan record stops waiting when <tt>WCNT</tt> is decremented
to zero.  The sscan record doesn't care, by the way, who writes
what to <tt>WAIT</tt>; it simply waits until the number of <tt>WAIT==0</tt>
writes equals the number of <tt>WAIT==1</tt> writes.

<p>But what if clients are a little slow to react, and the sscan
record checks its wait-count <tt>WCNT</tt> before the clients have had time to
write 1's to it? If this is a problem, you can cause the sscan
record to set <tt>WCNT</tt> at the appropriate time, by setting
&lt;scanrecord&gt;<tt>.AWCT</tt> to the number of slow clients.  (But now those
slow clients must NOT write <tt>1</tt> to <tt>WAIT</tt>.) </DL> 

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_1-4"></a>
<h2> 1.4. Completion of positioner and detector-trigger operations</h2>

<p>As was mentioned previously, all of the process variable names used to
identify positioners, detectors, and detector triggers are specified using
<i>reassignable links</i>.  These links are implemented differently than
standard EPICS links.  Reassignable links are channel-access links implemented
with the recDynLink library (originally written by Marty Kraimer and Ned Arnold;
modified to use callbacks and currently maintained by Tim Mooney).  These links
perform writes with the channel-access function, <tt>ca_put_callback()</tt>, and
the sscan record expects the resulting callback function to be called only after
all processing caused by the write operation has completed. (I'll call this
expectation the <i>completion-callback criterion</i>, in this documentation, and
I'll describe the conditions under which it is met.)

<P>For simple positioners and detectors, this is never a problem.  Individual
records (using either <i>synchronous</i> or <i>asynchronous</i> completion
strategies, as these terms are defined in the <i>EPICS Application Developer's
Guide</i>) always satisfy the completion-callback criterion.  Special records
(motor, scaler, mca, and sscan records) which do not use either synchronous or
asynchronous strategies, have been engineered to satisfy the completion-callback
criterion simply by having them refrain from calling <tt>recGblFwdLink()</tt>
(i.e., from executing their Forward Links) until the operation they started has
finished.

<p>If a positioner or detector is implemented with a collection of linked
records all of which individually satisfy the completion-callback criterion, the
whole series of records will also satisfy the criterion if all links in the
processing chain started by the sscan record's write have the attribute
<tt>PP</tt>, and all of the records that process are scan-passive (i.e., their
<tt>SCAN</tt> fields are set to "Passive").  Databases that do not satisfy this
criterion can still satisfy the completion-callback criterion very simply: at
least one record in the database must refrain from executing its Forward Link
until the operation is finished, and that record must be either be the record
written to, or it must be driven by that record via an unbroken series of
<tt>PP</tt> links.

<P>If a positioner or detector is implemented with the help of a CA client, such as
an SNL program, see the subsection on "putNotify-based completion signalling" in
section <a href="#HEADING_1-3-6"><b>1.3.6</b> Handshaking with CA clients that
implement positioners or detectors</a>.

<p>Database developers should note that a <tt>PP</tt> link from a record in one
IOC to a record in another IOC will silently be converted to a <tt>CA</tt>
link, which will not satisfy the completion-callback criterion.  In this case,
there are two options: the <i>busy</i>-record solution, detailed above, and the
use of a buffer record that can do a <tt>ca_put_callback()</tt> to make the
link between IOCs.  Currently, I'm aware of six record types that can do a
<tt>ca_put_callback()</tt>: the sscan, swait, and sseq
records; an ai record with soft asynchronous device support; and the
sCalcout and aCalcout records.  (The sscan, swait,
sseq, sCalcout, and aCalcout records are distributed with
synApps.  swait, sCalcout, and aCalcout are  variants of
the calcout record; sseq is a variant of the seq record.)

<!---------------------------------------------------------------------------->
<p><a NAME="HEADING_1-5"></a>
<h2> 1.5. Fly scans</h2>

The term "fly scan" is generic for several types of scans that behave and are
configured differently, though all involve one or more positioners moving while
data are being acquired.  Such positioners are said to be in "fly mode".

<P>Currently, the sscan record treats fly-mode positioners in essentially the
same way for all types of fly scans: they are sent to their start positions
(along with any non-fly-mode positioners), and the sscan record waits for all to
complete; then, fly-mode positioners are launched toward their end points when
detectors are triggered for the first (or only) time, and the sscan record does
not wait for them to complete.

<P>Clearly, the speed at which a fly-mode positioner moves is an important
consideration for a fly scan, because one wants to know at what position data
points are acquired.  But the sscan record does not provide any support for
reconciling positioner speed with other scan conditions, such as the start and
end points, the number of data points to be acquired, and the detector dwell
time.  This must be done by external software, either before the scan starts, or
as part of processing triggered by one of the sscan record's links, such as the
before-scan link.

<P>From the viewpoint of the sscan record, there are two types of fly scans:
<i>scalar-mode</i> fly scans, in which the sscan record directs the scan point by
point; and <i>array-mode</i> fly scans, in which the scan record hands off the
point-by-point direction to some other entity, such as a multichannel scaler. 
These types are distinguished by the value of <tt>ACQT</tt> (ACQuisition Type).

<p><a NAME="HEADING_1-5-1"></a>
<h3> 1.5.1 Scalar-mode fly scans</h3>

<P>If <tt>ACQT</tt>==<tt>SCALAR</tt> ("scalar mode", the default), the sscan
record will direct the acquisition of <tt>NPTS</tt> data points individually, as
we've been assuming thus far. That is, it will execute <tt>NPTS</tt> iterations
of (move, trigger, read).  A scalar-mode scan is a fly scan if one or more
positioners have their step mode PVs (<tt>P<em>n</em>SM</tt>) set to
<tt>FLY</tt>.  The only difference between this type of scan and the scans we've
considered up to now is the motion of those fly-mode positioners.

<P>In scalar mode, the sscan record executes fly scans as follows:

<ol>

<li>Execute the before-scan link.  Wait for completion if
<tt>BSWAIT</tt>==<tt>Wait</tt>.

<li>Send all positioners to their start points, and wait for completion.

<li>Send fly-mode positioners to their end points.  Do not wait for completion.

<li>Trigger detectors and wait for completion.

<li>Read positioners and detectors.

<li>Send non-fly-mode positioners to their next positions and wait for completion.

<li> Trigger detectors and wait for completion.

<li>Read positioners and detectors.

<li>Repeat (6,7,8) until <tt>NPTS</tt> data points have been acquired, or the
scan is aborted.

<li>Execute the array-trigger link, and wait for completion.

<li>Read the first <tt>NPTS</tt> elements of any array-valued detectors.

<li>If <tt>PASM</tt>!=<tt>STAY</tt>, send all positioners to specified
positions, and wait for completion.  (It is assumed that these commands
will redirect any fly-mode positioners that are still moving toward their end
points.)

<li>Execute the after-scan link.  Wait for completion if
<tt>ASWAIT</tt>==<tt>Wait</tt>.

</ol>

<P>Scalar-mode fly scans are relatively easy to configure, because the only
external conditions that must be set are the positioner speed and the detector
dwell time.  However, the association between positioner and detector values is
typically not as precise or as repeatable as in a step scan.  This is because
fly-mode positioners are read while they are moving, and because the timing of
those reads is not tightly synchronized with the positioner's motion.  In the
simplest case (no non-fly-mode positioners) the  time between positioner reads
is the detector dwell time plus the sscan record's per-point overhead time,
which varies because the IOC processor is doing other things in addition to
scanning.

<p><a NAME="HEADING_1-5-2"></a>
<h3> 1.5.2 Array-mode fly scans</h3>

<P>If <tt>ACQT</tt>==<tt>1D ARRAY</tt> ("array mode"), the sscan record will
direct the acquisition of only a single "data point", and that data point will
be a set of one-dimensional arrays of length <t>NPTS</tt>.  In an array-mode
scan, all positioners are treated as being in fly mode, whatever the values of
their step-mode PVs, because the sscan record writes to them only twice.  After
moving positioners to their start positions, the sscan record will execute only
one (move, trigger, read) sequence.

<blockquote>Array mode was originally intended merely to read a collection of
array-valued detectors (multichannel analyzer spectra), and not to involve
positioners at all.  However, the sscan record does not erase any existing
positioner PVs when array mode is selected, and if any exist then
<i>something</i> must be done with them, so this documentation must describe
it.</blockquote>

<P>In array mode, the sscan record executes fly scans as follows:

<ol>

<li>Execute the before-scan link.  Wait for completion if
<tt>BSWAIT</tt>==<tt>Wait</tt>.

<li>Send all positioners to their start points, and wait for completion.

<li>Send all positioners to their end points.  Do not wait for completion.

<li>Trigger detectors and wait for completion.

<li>Execute the array-trigger link, and wait for completion.

<li>Read the first <tt>NPTS</tt> elements of any array-valued detectors.

<li>If <tt>PASM</tt>!=<tt>STAY</tt>, send all positioners to specified
positions, and wait for completion.  (It is assumed that these commands
will redirect any fly-mode positioners that are still moving toward their end
points.)

<li>Execute the after-scan link.  Wait for completion if
<tt>ASWAIT</tt>==<tt>Wait</tt>.

</ol>

<P>Because the sscan record doesn't do any point-by-point writes to (or reads
from) positioners during an array-mode scan, the data it acquires will represent
an average over position, unless some external agent enforces a coordination
between positioner values and the acquisition of detector-array elements.  The
advantage of array-mode fly scans over scalar-mode fly scans is that this
coordination can be done externally by hardware that's capable of doing it well;
the disavantage is that hardware positioner/detector coordination must be
arranged.

<P>In one common implementation of an array-mode scan, detector data are
acquired by a multichannel scaler, which is advanced from channel to channel
either by a periodic signal, or by pulses from a motor.  In contrast to the
scalar-mode fly scans discussed above, this type of fly scan can have a very
precise and reproducible association between positioner and detector values.


<blockquote> In previous versions of the sscan record, fly mode was implemented
slightly differently, as follows (differences are in <i>italics</i>) If the
sscan record was in scalar mode (<tt>ACQT</tt>==<tt>SCALAR</tt>), and a
positioner's step mode had the value <tt>FLY</tt>, the sscan record sent it to
the start position at the beginning of a scan, waited for it to get there,
<i>acquired one data point (trigger, read),</i>  sent the positioner to the end
position, and began acquiring the remaining data points while the positioner was
travelling to the end position.  <i>If the record was in array mode
(<tt>ACQT</tt>==<tt>1D&nbsp;ARRAY</tt>), positioners that were not explicitly in
fly mode (<tt>PnSM</tt>!=<tt>FLY</tt>) were not sent to the end position at
all.</i> </blockquote>


<!---------------------------------------------------------------------------->
<br><br><br><hr>
<p><a NAME="HEADING_2"></a>
<h1>2. sscan-Record Fields</h1>
<hr>

Many options are available to control the execution of a scan. All parameters
for a particular sscan record must be configured prior to initiating the scan,
as the sscan record will not allow most fields to be written to while a scan is
in progress.  However, in a multidimensional scan, outer scans can modify the
parameters of inner scans, because at the time an outer sscan record is writing
to positioners, all inner sscan records are idle. You should use caution in
programming such self modifying scans, because clients displaying or analyzing
multidimensional scan data may have trouble dealing with parameters changing
during a scan.

<P>In this documentation, many of the sscan-record fields will be listed in
tables containing the following informational headings:

<dl>

<dt><b>Field</b></dt>

<dd>The name of the sscan-record field</dd>

<dt><b>Summary</b></dt>

<dd>Basic purpose of the field</dd>

<dt><b>Type</b></dt>

<dd>Data type of the field.  If the field is a menu, the menu choices (text
strings) are listed in quotes.  (Don't include the quotes when you write to the
field.)  Note that if you write a numeric value to a menu field, the number
will be interpreted as an index into the list of menu choices.  The first item
in the list has the index 0.</dd>

<dt><b>DCT</b></dt>

<dd>Can this field be modified by database-configuration tools?</dd>

<dt><b>Initial/Default</b></dt>

<dd>Value if the field is not specified in the .db file.  If the field is a
menu, the text string will be shown, followed by the corresponding index. </dd>

<dt><b>Read</b></dt>

<dd>Can user read this field?</dd>

<dt><b>Modify</b></dt>

<dd>Is user ever allowed to write to this field?  (Note that the sscan record
will reject writes to certain otherwise writable fields while a scan is
underway.)</dd>

<dt><b>Posted</b></dt>

<dd>If the record should modify the field, will the new value be posted?</dd>

<dt><b>PP</b></dt>

<dd>Does a channel-access write to this field cause the record to process?</dd>

</dl>

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-1"></a>

<h2>2.1. Control Fields</h2>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>NPTS</tt></td>
<td>Number of Points&nbsp;</td>
<td>LONG</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>MPTS</tt></td>
<td>Maximum Number of Points</td>
<td>LONG</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr>
<td><tt>PASM</tt></td>
<td>Positioner After-Scan Mode</td>
<td>Menu ("STAY", "START POS", "PRIOR POS", "PEAK POS", "VALLEY POS", "+EDGE POS",  "-EDGE POS", CNTR OF MASS)</td>
<td>Yes</td>
<td>"STAY" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>
<blockquote>
	PASM allows the user to control where positioners are left after
	a scan is finished.  Here are the possibilities:

	<dl compact>

	<dt>"STAY"<dd>Do nothing.  Leave positioners where they were when the last data
	point was acquired.

	<dt>"START POS"<dd>Go the the position of the first data point acquired.

	<dt>"PRIOR POS"<dd>Go to the position they occupied prior to the scan.

	<dt>"PEAK POS"<dd>Attempt to find the highest point in the data from the
	detector specified by the REFD field.  If a highest point is found, go to its
	position, else "STAY".

	<dt>"VALLEY POS"<dd>Attempt to find the lowest point in the data from the
	detector specified by the REFD field.  If a lowest point is found, go to its
	position, else "STAY".

	<dt>"+EDGE POS"<dd>Take the derivative of the REFD data, then do "PEAK POS".

	<dt>"-EDGE POS"<dd>Take the derivative of the REFD data, then do "VALLEY POS".

	<dt>"CNTR OF MASS"<dd>Like "PEAK POS", but sends positioner(s) the position of
	the center of mass of the data, as calculated with reference to positioner 1.
	Note that the calculated center of mass depends on the distribution of positioner
	data.  If multiple positioners are involved in a scan, they will not, in general,
	have the same center of mass.

	</dl>
</blockquote>
</td>
</tr>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>REFD</tt></td>
<td>Reference detector for After-Scan mode</td>
<td>SHORT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr>
<td><tt>BSPV</tt></td>
<td>Before-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSNV</tt></td>
<td>BSPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSCD</tt></td>
<td>Before-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSWAIT</tt></td>
<td>Wait for completion?</td>
<td>MENU ("YES", "NO")</td>
<td>Yes</td>
<td>"YES" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>
<blockquote>

	<tt>BSPV</tt>, <tt>BSNV</tt>, <tt>BSCD</tt>, and <tt>BSWAIT</tt> allow the
	user to specify a PV to be written to before every scan starts.  (If the
	sscan record is part of a multidimensional scan, each
	participating sscan record has its own set of before-scan
	parameters, so you can cause an action to occur before the whole scan
	starts, and before each nested loop starts.)

	<P>To specify a before-scan PV write, write the name of the PV to
	<tt>BSPV</tt>, and the value to be written to <tt>BSCD</tt>.  If you want
	the sscan record to wait for completion of processing
	triggered by the write, before going on with the rest of the scan, set
	<tt>BSWAIT</tt> to "YES" (1).  You can check to status of the link by
	looking at <tt>BSNV</tt>.  If the link is good, <tt>BSNV</tt> will be zero.

	<P>Note that the before-scan link is permitted to change only selected
	fields of its own sscan record:  it cannot change PV names
	(i.e., links); and it cannot change the acquisition type (<tt>ACQT</tt>) or
	mode (<tt>ACQM</tt>).  If this sscan record is part of a
	multidimensional scan, the before-scan link can change any field of a
	lower-level sscan record (i.e., one that its record it
	driving), and no field of a higher level scan record.

</blockquote>
</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>ASPV</tt></td>
<td>After-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASNV</tt></td>
<td>ASPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASCD</tt></td>
<td>After-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASWAIT</tt></td>
<td>Wait for completion?</td>
<td>MENU ("YES", "NO")</td>
<td>Yes</td>
<td>"YES" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>
<blockquote>

	<tt>ASPV</tt>, <tt>ASNV</tt>, <tt>ASCD</tt>, and <tt>ASWAIT</tt> allow the
	user to specify a PV to be written to after every scan is finished.  (If the
	sscan record is part of a multidimensional scan, each
	participating sscan record has its own set of after-scan
	parameters, so you can cause an action to occur after the whole scan is
	done, and after each nested loop is done.)

	<P>To specify an after-scan PV write, write the name of the PV to
	<tt>ASPV</tt>, and the value to be written to <tt>ASCD</tt>.  If you want the
	sscan record to wait for completion of processing triggered by
	the write, before going on with the rest of the scan wrap-up, set <tt>ASWAIT</tt> to
	"YES" (1).  You can check to status of the link by looking at <tt>ASNV</tt>.  If the
	link is good, <tt>ASNV</tt> will be zero.

	<P>Note that the after-scan link is permitted to change only selected fields
	of its own sscan record:  it cannot change PV names (i.e.,
	links); and it cannot change the acquisition type (<tt>ACQT</tt>) or mode
	(<tt>ACQM</tt>).  If this sscan record is part of a
	multidimensional scan, the after-scan link can change any field of a
	lower-level sscan record (i.e., one that its record it
	driving), and no field of a higher level scan record.

</blockquote>
</td>
</tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>A1PV</tt></td>
<td>Array-read trigger 1 PV Name</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>A1NV</tt></td>
<td>A1PV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>A1CD</tt></td>
<td>A1 Cmnd</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>
<blockquote>

	<tt>A1PV</tt>, <tt>A1NV</tt>, and <tt>A1CD</tt> allow the user to specify a
	PV to be written to before the sscan record tries to read
	array-valued data.  (It may be necessary, for example, to cause data to be
	read from hardware into a set of EPICS PVs, or to execute some calculation
	on the data, before the sscan record acquires it. The
	sscan record will wait for processing triggered by this write
	to complete before reading arrays.

	<P>To specify an array-preparation PV write, write the name of the PV to
	<tt>A1PV</tt>, and the value to be written to <tt>A1CD</tt>.  You can check
	to status of the link by looking at <tt>A1NV</tt>.  If the link is good,
	<tt>A1NV</tt> will be zero.

</blockquote>
</td>
</tr>
<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>ATIME</tt></td>
<td>Array post time period</td>
<td>FLOAT</td>
<td>Yes</td>
<td>0.0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>COPYTO</tt></td>
<td>Copy Last Array Point Thru This Element Number</td>
<td>LONG</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>
<blockquote>

	These fields control the posting of array data during a scan. <tt>ATIME</tt>
	is the minimal time period in seconds between array postings during a scan. 
	If <tt>ATIME</tt> is greater than 0.1 (seconds), and if more than this time
	has elapsed since the last array posting of this scan's data, then the
	current-data arrays will be posted after the next data point has been
	acquired.
	
	<P><b>NOTE</b>: Posting current-data arrays also causes completed-scan data
	arrays to be posted (uselessly, because they were posted at the end of the
	previous scan, and the data they contain has not changed).  Some display or
	storage clients may have a problem with this new behavior of the
	sscan record.  If so, there are two alternatives: 1) leave
	<tt>ATIME</tt> at its default value of 0.0, or 2) have the client specify
	DBE_LOG when it subscribes to the data array (using ca_add_event() or
	ca_create_subscription()). (If a client does not monitor data arrays, but
	instead uses ca_get() to read them, then it won't care how often they are
	posted.)
	
	<P>Some data-display clients (notably, MEDM) cannot use a PV to tell them
	how many valid data points are being sent.  This results in bizarre looking
	plots that can be made to look correct by repeating the last valid array
	values to fill the unused array elements.  This can be a time-consuming
	process, so by default it's only done once, at the end of a scan.  But
	arrays posted during a scan also will not be plotted correctly by such
	clients, so you can specify that the last valid array elements be copied for
	arrays posted during a scan, by setting <tt>COPYTO</tt> to the number of
	array elements in the client's data buffer.  If <tt>COPYTO</tt> == 0, no
	copying will be done; if <tt>COPYTO</tt> == -1, the last value will be
	copied to all unused array elements in the sscan record's data buffers.
	If <tt>COPYTO</tt> is set to a value larger than <tt>MPTS</tt>, the value
	used will be <tt>MPTS</tt>.

</blockquote>
</td>
</tr>
</table>

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-2"></a>

<h2>2.2. Positioner Fields</h2>

Each sscan record can control up to four <i>positioners</i>, by which it
sets conditions under which data will be acquired.  A positioner is any numeric PV
to which the sscan record can write, and you specify that a positioner is to
be scanned by typing its PV name into one of the sscan record's fields
<tt>PnPV</tt>.  If the value written to the PV (the <i>desired</i> value) might not
accurately indicate the true value of the underlying hardware positioner, you can
specify a readback PV to retrieve a more accurate value.  I'll sometimes call the
PV that the sscan record writes to the "drive" PV.  If no readback PV is specified,
the drive PV will also be used as the readback PV.

<p>There are three possible modes for determining desired values for a positioner:
<tt>LINEAR</tt>, <tt>TABLE</tt>, and <tt>FLY</tt>.  Each positioner has its own
mode PV, and you specify which mode you want for a positioner by setting its
<tt>PnSM</tt> field (e.g., <tt>P1SM</tt> for positioner 1). If <tt>PnSM</tt>==
<tt>LINEAR</tt>, the desired values are determined from parameters such as start
position, step increment, number of points, and end position. If
<tt>PnSM</tt>==<tt>TABLE</tt>, the desired values are found in an array
(<tt>PnPA</tt>), which must have been loaded into the sscan record prior to
initiating a scan. If <tt>PnSM</tt>==<tt>FLY</tt>, the desired values are the start
and end positions for <tt>LINEAR</tt> mode.

<blockquote> In addition to the positioner scan modes <tt>PnSM</tt>, there is
another sscan record field that influences how positioners are scanned.  The
<tt>ACQT</tt> (acquisition type) field affects all positioners, and either
directs them to behave as described above (when ACQT==<tt>SCALAR</tt>), or to
all be effectively in fly mode (when ACQT==<tt>1D&nbsp;ARRAY</tt>.  I'll
sometimes refer to this as "array mode").  See the "Fly Scans" section for
more detail. </blockquote>

<P>For each positioner, the user may specify a process variable in the
<tt>R1PV</tt>-<tt>R4PV</tt>  fields that corresponds to the actual (or measured)
position of the motor. If this readback field is configured, the sscan record
will confirm after each movement that the readback position differs by no more
than a specified value from the desired position. The difference limit is
specified in the <tt>R1DL</tt> -<tt>R4DL</tt> fields.  If it's zero, no check is
performed.  Otherwise, if the difference limit is exceeded, the scan will abort
and the record will go into an alarm state. A text field within the record
(<tt>SMSG</tt>) will inform the operator of the error condition.

<P>The positioner-readback field normally contains the name of a PV from which
readback values are read, but it may also contain the static text "TIME", or
"time".  In this case, the sscan record sets the scalar readback
field <tt>R<i>n</i>CV</tt> to the time in seconds since the beginning of the scan, and
fills the readback array <tt>P<i>n</i>RA</tt> with those values.

<h4>Drive Fields</h4>
<P>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PV</tt></td>
<td>Positioner <i>n</i> Process Variable ame</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>NV</tt></td>
<td>P<i>n</i>PV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SM</tt></td>
<td>Positioner <i>n</i> step-mode</td>
<td>Menu ("LINEAR", "TABLE", "FLY")</td>
<td>Yes</td>
<td>"LINEAR" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>AR</tt></td>
<td>Positioner <i>n</i> Absolute/Relative Mode</td>
<td>Menu ("ABSOLUTE", "RELATIVE")</td>
<td>Yes</td>
<td>"ABSOLUTE" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>DV</tt></td>
<td>Pos. <i>n</i> Desired Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>LV</tt></td>
<td>Pos. <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>DV</tt></td>
<td>Pos. <i>n</i> Desired Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>LV</tt></td>
<td>Pos. <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>



<tr>
<td><tt>P<i>n</i>EU</tt></td>
<td>Positioner <i>n</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>HR</tt></td>
<td>Pos. <i>n</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt><tt>P<i>n</i>LR</tt></tt></td>
<td>Pos. <i>n</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>PR</tt></td>
<td>Pos. <i>n</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>PA</tt></td>
<td>P<i>n</i> Step Array</td>
<td>DOUBLE[]</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>


<h4>Readback fields</h4>

<P>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>R<i>n</i>PV</tt> </td>
<td>Readback <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>NV</tt></td>
<td>Readback <i>/n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>DL</tt> </td>
<td>Readback <i>n</i> Difference Limit&nbsp;</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>CV</tt></td>
<td>Readback <i>n</i> Current Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>LV</tt></td>
<td>Readback <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>RA</tt></td>
<td>P<i>n</i> Readback Array</td>
<td>DOUBLE[]</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>CA</tt></td>
<td>P<i>n</i> Current Readback Array</td>
<td>DOUBLE[]</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<P>Clients that display scan data will most likely be interested in only one of
the two positioner-array fields: <tt>P<i>n</i>CA</tt> or <tt>P<i>n</i>RA</tt>.
These array fields are backed by the same double-buffered arrays, so they cannot
be posted separately.

<P><tt>P<i>n</i>CA</tt> will yield data from the scan that currently is
executing. This array can be read at any time during the scan, and it may be
posted with the mask, DBE_VALUE, while the scan is in progress. (<tt>ATIME</tt>
controls this.)  When the scan completes, <tt>P<i>n</i>CA</tt> will be posted
with the mask, DBE_VALUE|DBE_LOG.

<P><tt>P<i>n</i>RA</tt> will yield data from the most recently completed scan.
This array's data will remain available while the next scan's data are being
acquired, and will become unavailable when that scan completes.  Clients
interested only in completed-scan data should use this field.  Clients that
monitor this field should always specify the mask, DBE_LOG, in their
ca_add_event() or ca_create_subscription() call.  If this field is monitored
with the mask, DBE_VALUE, the client may receive multiple postings of the same
data.

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-2-1"></a>

<h3> 2.2.1 <tt>LINEAR</tt> Mode</h3>

If a positioner's step-mode field (e.g., <tt>P1SM</tt>) has the value
<tt>LINEAR</tt>, a scan can be fully defined by three parameters, e.g., the
start position (<tt>P1SP</tt>), the step increment (<tt>P1SI</tt>), and the
number of data points (<tt>NPTS</tt>). A scan involving <i>N</i> positioners is
defined by merely 2<i>N</i>+1 parameters, since <tt>NPTS</tt> applies to all
positioners. For the convenience of interactive users, and to support channel
access clients that define scans differently, the first positioner can be
specified by as many as six parameters: starting position (<tt>P1SP</tt>),
ending position (<tt>P1EP</tt>), center position (<tt>P1CP</tt>), scan  width
(<tt>P1WD</tt>), step increments (<tt>P1SP</tt>), and <tt>NPTS</tt>. For the
other three positioners, the same parameters are available minus the
<tt>NPTS</tt> field, since that applies to all. The parameters that pertain to
the same positioner are a set. The record imposes an upper limit (<tt>MPTS</tt>)
on <tt>NPTS</tt>. Both <tt>MPTS</tt> and <tt>NPTS</tt> are configured by the
user. The positioner width, configurable in the <tt>P1WD</tt> -<tt>P4WD</tt> 
fields, may be negative.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>SP</tt></td>
<td>Positioner <i>n</i> Starting Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>EP</tt></td>
<td>Positioner <i>n</i> Ending Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>CP</tt> </td>
<td>Positioner <i>n</i> Center Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>WD</tt> </td>
<td>Positioner <i>n</i> Width</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SI</tt> </td>
<td>Positioner <i>n</i> Step Increment</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p>Some of these fields can be redundant. For instance, the positioner width
(<tt>P1WD</tt> -<tt>P4WD</tt>) is simply the distance from the starting
position to the ending position (<tt>P<i>n</i>EP</tt>  - <tt>P<i>n</i>SP</tt>). The record calculates redundant parameters for the same set, if the
parameters are left undefined. However, the user can still configure the
redundant parameters anyway.

<p>There is no unique prescription for removing inconsistencies among redundant
parameters, and no hard-coded set of preferences among parameters is likely to
please everyone. Therefore, the sscan record allows the user to "freeze"
parameters with flags so that they will not be changed by the record's internal
attempts to ensure consistency among the parameter set. Frozen parameters can
be changed by the user and by any other client, but not by the record. It is
the user's responsibility to ensure that frozen parameters do not prevent
freely specifying unfrozen parameters. For example, if both
<tt>P<i>n</i>SI</tt>  and <tt>NPTS</tt> are frozen, changes to
<tt>P<i>n</i>WD</tt>  will be rejected. Similarly, if both
<tt>P<i>n</i>SP</tt>  and P<i>n</i>CP are frozen, changes to
<tt>P<i>n</i>EP</tt>  and <tt>P<i>n</i>WD</tt> will have no effect. By default,
<tt>P<i>n</i>SP</tt> , <tt>P<i>n</i>SI</tt> , and <tt>NPTS</tt> are frozen.
When the record cannot adjust the parameters to be consistent, a flag is raised
in the alert field (<tt>ALRT</tt>) and a message reported in the state message
field (<tt>SMSG</tt>).

<p>The freeze flag override field (<tt>FFO</tt>) has two choices: <tt>Use
F-Flags</tt> and <tt>Override</tt>. <tt>Override</tt> causes the current
settings of all the freeze flags to be saved and monitors to be called for
those that have changed. <tt>Use F-Flags</tt> causes the flags saved with the
<tt>Override</tt> command to be restored if any have changed. Changing the
choice of this field at run-time causes the special record support routines to
perform these actions. So if <tt>Override</tt> is chosen at run-time, then all
current settings are saved, and can be restored at a later time by changing the
<tt>FFO</tt>  field to <tt>Use F-Flags</tt>.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>FPTS</tt> </td>
<td>Freeze Flag for <tt>NPTS</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"FREEZE" (1)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>FFO</tt> </td>
<td>Freeze Flag Override</td>
<td>Menu ("USE F-FLAGS", "OVERRIDE")</td>
<td>Yes</td>
<td>"USE F-FLAGS" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FS</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FE</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>EP</tt> </td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FI</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SI</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FC</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>CP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FW</tt></td>
<td>Positioner n Freeze Flag for <tt>P<i>n</i>WD</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Although this approach may seem to present the user with an overwhelming
number of choices when it comes to linear scans, it should be noted that by
default the user only has to configure <tt>NPTS</tt>, and the starting position
(<tt>P<i>n</i>SP</tt>) and the step increment (<tt>P<i>n</i>SI</tt>) fields for
each positioner in order to fully define the scan of a positioner. The operator
interface (usually MEDM or another CA client) need only present the user
with these fields. However, by changing the freeze flags from the defaults and
presenting the user with different fields to fill in, the scan can be defined
in a completely flexible way. The result is that a simple scan can be defined
easily, but advanced users are not limited in flexibility.

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-2-2"></a>
<h3>2.2.2 <tt>TABLE</tt> Mode</h3>

If a positioner's step-mode field (e.g., <tt>P1SM</tt>) has the value
<tt>TABLE</tt> mode, the user specifies all positions to be visited during the
scan by writing them into an array (e.g., <tt>P1PA</tt>) prior to the start of a
scan. These arrays are used only in <tt>TABLE</tt> mode.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PA</tt> </td>
<td>Positioner <i>n</i> Position Array</td>
<td>DOUBLE array</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</table>

<P>To load an array of positions into <tt>P<i>n</i>PA</tt>, you can use any
channel-access client that knows how to write to numeric arrays.  There are
several versions of the command-line program caput that can do this.  For one
version, you specify the switch <code>-m</code>, and write a comma-separated
list of values:

<pre>caput -m 2idb1:scan1.P1PA 0.,1.,2.</pre>

works.  For another version, you specify the flag <code>-a</code>, specify the
number of values to be written, and specify the values separated by spaces:

<pre>caput -a 2idb1:scan1.P1PA 3 0. 1. 2.</pre>

<P>You might also do this from Python, using <a href="http://cars9.uchicago.edu/software/python/pyepics3">pyepics</a>:

<pre>
wheaties% setenv LD_LIBRARY_PATH /home/oxygen/MOONEY/epics/base-3.14.12.1/lib/solaris-sparc
wheaties% python
>>> import epics
>>> epics.caput("xxx:scan1.P1PA", [1,2,3,4,5,6,7])
>>> epics.caget("xxx:scan1.P1PA")
array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  0.,  0.,  0.,  0.,  0.,  0.,
...
</pre>

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-2-3"></a>
<h3>2.2.3 <tt>FLY</tt> Mode</h3>

If a positioner's step-mode field (e.g., <tt>P1SM</tt>) has the value
<tt>FLY</tt>, the positioner is said to be in "fly mode", and it will make only
two motions during the scan. The first motion is the same as that of a linear-
or table-mode positioner: the sscan record sends the positioner to its start
point, and waits for it to get there.  The next motion is different: when the
sscan record triggers detectors for the first time, it also launches fly-mode
positioners to their end points.  The sscan record doesn't wait for fly-mode
positioners to reach their end points, and fly-mode positioners are not
commanded again, unless the Positioner After-Scan Mode (<tt>PASM</tt>) requires
this (for example, by specifying that all positioners return to their pre-scan
positions).

<P>Note that the PV <tt>ACQT</tt> (ACQuisition Type) also affects positioner
motion: when <tt>ACQT</tt>==<tt>1D ARRAY</tt>, all positioners are effectively
in fly mode, because the sscan record will acquire only one (array valued) data
point.   In this case, the PVs <tt>P<i>n</i>SM</tt> serve only to determine the
starting and ending points of the positioners' motions, as detailed in the
following table for positioner 1:

<P><table BORDER> <tr><th>scan mode (P1SM)<th>acquisition type (ACQT)<th>start
point<th>end point<th>motion <tr><td colspan 4>
<tr><td>LINEAR<td>SCALAR<td>P1SP<td>P1EP<td>point-to-point
<tr><td>TABLE<td>SCALAR<td>P1PA[0]<td>P1PA[npts-1]<td>point-to-point
<tr><td>FLY<td>SCALAR<td>P1SP<td>P1EP<td>fly <tr><td colspan 4>
<tr><td>LINEAR<td>1D ARRAY<td>P1SP<td>P1EP<td>fly <tr><td>TABLE<td>1D
ARRAY<td>P1PA[0]<td>P1PA[npts-1]<td>fly <tr><td>FLY<td>1D
ARRAY<td>P1SP<td>P1EP<td>fly </table>

<P>While fly-mode positioners are moving toward their end points, the sscan
record goes through all the normal scan phases -- triggering detectors and
waiting for them to finish, reading any detectors and positioner readbacks,
sending any non-fly-mode positioners to their next positions and waiting for
them to get there.


<P>If a fly-mode positioner has a specified readback PV (<tt>R<i>n</i>PV</tt>),
its value will be read during the scan, but in many cases the value will be only
approximately correct, because the positioner is in motion during the read, and
because the sscan record doesn't cause the readback PV to process.  If the
positioner is a motor, for example, and the readback PV is posted periodically,
the sscan record will read values that are imperfectly synchronized with the
scan.


<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-3"></a>

<h2>2.3. Detector-Trigger Fields</h2>

If valid process variable names are entered into the detector trigger fields
(<tt>T1PV</tt>-<tt>T4PV</tt> ) fields, the sscan record will write the
specified command data (the floating point numbers <tt>T1CD</tt>-<tt>T4CD</tt>
) to those process variables between the positioning phase and the data
acquisition phase.  If no detector trigger field contains a valid PV, the sscan
record will skip this step and acquire the data immediately.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>T<i>n</i>PV</tt></td>
<td>Detector Trigger <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>NV</tt></td>
<td>Trigger <i>n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>CD</tt></td>
<td>Trigger <i>n</i> Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-4"></a>

<h2>2.4. Delay Fields</h2>

Generally, after the sscan record has written to positioners and waited for all
positioners to declare themselves done, it waits an additional settling time,
specified in seconds by the <tt>PDLY</tt> field, before entering the next scan
phase. Similarly, after detector triggers have declared themselves done, the
sscan record waits for <tt>DDLY</tt> seconds before reading positioner and
detector data.

<P>If no positioners are defined, then <tt>PDLY</tt> is ignored.  If no
detector triggers are defined, then <tt>DDLY</tt> is ignored.  <tt>PDLY</tt>
does not apply to after-scan positioner motions.

<!---------------------------------------------------------------------------->

<p><a NAME="HEADING_2-5"></a>

<h2>2.5. Client Handshaking Fields</h2>

Immediately before data are to be read from positioners and detectors, the
sscan record checks the <tt>WCNT</tt> field.  If this field is nonzero, the
sscan record waits until it gets set to zero before reading data and continuing
with the scan.  The <tt>WCNT</tt> is not directly writable by clients. 
Instead, a client wanting to put a hold on the scan writes a <tt>1</tt> to the
<tt>WAIT</tt> field, which increments <tt>WCNT</tt> by one.  When the client is
ready for the scan to continue, it writes a <tt>0</tt> to the <tt>WAIT</tt> field,
which decrements the <tt>WCNT</tt> field.  This mechanism allows several
clients independently to handshake with the sscan record, and it is intended or
two purposes:

<P>1) A data-storage client can put a hold on a sscan record whose data it is
writing by writing to the <tt>AWAIT</tt> field.  This hold doesn't prevent the
record from executing, or even from acquiring new data, but it does prevent the
record from switching data buffers.

<P>2) In a multidimensional scan, a data-storage client can put a hold on scan2
while it is writing data from scan1, by writing to the <tt>WAIT</tt> field. 
This relatively inefficient handshake is still used by some data-storage
clients.

<P>3) A data-acquisition client that doesn't declare completion via EPICS'
putNotify mechanism can declare completion using <tt>WAIT</tt>.

<P>A client may not be able to write quickly enough to <tt>WAIT</tt> to ensure
that the scan holds before data acquisition.  In this case, the client can
cause the sscan record to write automatically to <tt>WCNT</tt> whenever
detectors are triggered, by incrementing the value of the <tt>AWCT</tt> field. 
The client must remember to decrement <tt>AWCT</tt> before exiting, otherwise
scans will hang waiting for a nonexistent client.

<P>A client may not be able to write quickly enough to <tt>AWAIT</tt> to ensure
that the scan holds before switching buffers.  In this case, the sscan record
can be made to write automatically to <tt>AWAIT</tt> whenever data are posted,
by setting the <tt>AAWAIT</tt> field to <tt>1</tt>. 

<P><table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>WAIT</tt></td>
<td>Wait for client</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WCNT</tt></td>
<td>Wait count</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>AWCT</tt></td>
<td>Auto Wait</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WTNG</tt></td>
<td>Waiting</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>
<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>AWAIT</tt></td>
<td>Waiting for data-storage client</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td><tt>AAWAIT</tt></td>
<td>AutoWait for data-storage client</td>
<td>MENU ("NO","YES")</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<!---------------------------------------------------------------------------->

<br><br><br><hr>
<p><a NAME="HEADING_2-6"></a>
<h2>2.6 Detector Fields</h2>
<hr>

Each sscan record can acquire data from up to 74 process variables (70
detector signals, <tt>D01</tt>-<tt>D70</tt>, and four positioner readbacks,
<tt>R1</tt>-<tt>R4</tt>) at each point in the scan. These data will most
commonly be from a detector or from a position readback (which would record the
actual motor positions at each point and could then be compared to the desired
position array).

<P>Although positioner readbacks, <tt>R1</tt>-<tt>R4</tt>, are normally used to
confirm the position at which data actually were acquired (as opposed to the
position to which the sscan record <i>told</i> a positioner to go), they
can be used to record any data.  These four variables are the only place to
record double-precision scan data.  Note that these readbacks are not
full-fledged detectors, because the sscan record currently cannot read into them
from a array-valued PV's, as it can for actual detectors.

<p>The scan results will most frequently be read as position arrays
(<tt>P1RA</tt>-<tt>P4RA</tt>) and detector arrays 
(<tt>D01DA</tt>-<tt><tt>D70DA</tt></tt>).

<p>A one-dimensional scan is complete when the <tt>BUSY</tt> field
goes back to zero (during the scan its value is 1). A client program monitoring
the scan can read the position and data arrays when the <tt>DATA</tt> field is
set to 1. (The client could have a monitor set on the data-array fields so the
record will post them when the scan is finished.)

<p>For two-dimensional scans, the client should read the arrays from the scan1
record after the completion of each inner scan and associate these data with
the current outer-scan information.  (Let's call the inner scan 'x', and the
outer scan 'y'.)  This will allow the client to display data after each x scan.
The sscan record will buffer the data for only one x scan, so the client must
read the arrays before the next x scan is completed.  If the scan is too fast
for this, see <a href="#HEADING_1-3-4">section 1.3.4 - Handshaking with
data-storage clients</a>

<p>During slow scans, the application program may want to display scan progress
point-by-point. The sscan record posts monitors on fields that it updates each
point, but it doesn't post point-by-point monitors faster than 20 times per
second. If a scan is proceeding at a rate less than 20 points per second, every
point will be posted. If a scan is proceeding at 100 steps per second, scalar
values will be posted approximately every 5th point. In either case, the array
data will contain every point at the completion of the scan.

<p>Special Acquisition Parameters:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr><td colspan=9>version 5.16 and earlier:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV", "GET ARRAYS")</td>
<td>Yes</td>
<td>"NORMAL" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>version 5.17 and later:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV")</td>
<td>Yes</td>
<td>"NORMAL" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><tt>ACQT</tt></td>
<td>Acquisition Type</td>
<td>Menu ("SCALAR", "1D ARRAY")</td>
<td>Yes</td>
<td>"SCALAR" (<tt>0</tt>)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Data and related PV's:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td colspan=9>For <i>nn</i> in [01..70] (e.g., "D01PV", "D02PV", ... "D70PV") :</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PV</tt></td>
<td>data <i>nn</i> Process Variable name</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>NV</tt></td>
<td>data <i>nn</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DA</tt></td>
<td>Detector <i>nn</i> End-Of-Scan Data Array</td>
<td>FLOAT[ ]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>CA</tt></td>
<td>Detector <i>nn</i> Current-Data Array</td>
<td>FLOAT[ ]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>EU</tt></td>
<td>Detector <i>nn</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>HR</tt></td>
<td>Det. <i>nn</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LR</tt></td>
<td>Det. <i>nn</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PR</tt></td>
<td>Det. <i>nn</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>CV</tt></td>
<td>Detector <i>nn</i> Current Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LV</tt></td>
<td>Detector <i>nn</i> Last Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>










</table>


<!---------------------------------------------------------------------------->
<br><br><br><hr>
<p><a NAME="HEADING_2-7"></a>
<h2>2.7 Execution fields</h2>
<hr>

<P>A scan is started when a client writes <tt>1</tt> to the EXSC field.

<P>Prior to beginning an actual scan, the record can be commanded to check the
scan parameters to ensure that all positioner requests are within positioner
limits. This is done by writing <tt>1</tt> to the <tt>CMND</tt> field. The
record will do a "dry run" by calculating every positioner value (or looking it
up in the table) and comparing it with the high range and low range values
(<tt>P1HR</tt>-<tt>P4HR</tt> and <tt><tt>P1LR</tt></tt>-<tt>P4LR</tt>)
associated with that positioner's Process Variable. (Drive limits are an
attribute of most process variables).  If any step would exceed the drive
limits, the operator is notified via the <tt>SMSG</tt> field.  (Note that the
sscan record does not retrieve positioner limits whenever they are changed, but
only when the sscan record connects (makes a link) to the positioner.  The sscan
record disconnects and reconnects to positioners at the beginning of every
scan for this reason, though it declines to do this if the most recent scan
ended less than <code>sscanRecordLookupTime</code> seconds ago.  The default
value of <code>sscanRecordLookupTime</code> is 1.)


<table BORDER>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>EXSC</tt></td>
<td>Execute Scan Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>


<tr>
<td><tt>CMND</tt></td>
<td>Command Field</td>
<td>ENUM</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</table>

<p>The command (<tt>CMND</tt>) field supports eight commands, as follows:

<table BORDER>

<tr>

<th><tt>CMND</tt></th> <th>Command</th>

<tr><td>0<td>Clear the State Message field (<tt>SMSG</tt>)</td></tr>

<tr><td>1<td>Execute a "dry run", checking positioners against their
limits</td></tr>

<tr><td>2<td>Show a preview of the scan, using the positioner and detector
arrays DnnCA and PnCA:  Write data-point numbers to DnnCA, and corresponding
positioner values to PnCA.</td></tr>

<tr><td>3<td>Clear all PVs, freeze flags, modes, switches, etc.</td></tr>

<tr><td>4<td>Clear all positioner-name PVs, freeze flags, modes, and 
switches.</td></tr>

<tr><td>5<td>Clear positioner-name PVs.</td></tr>

<tr><td>6<td>Clear all positioner-name and readback-name PVs, freeze flags,
modes, and  switches.</td></tr>

<tr><td>7<td>Clear positioner-name and readback-name PVs.</td></tr>

</table>



<!---------------------------------------------------------------------------->
<br><br><br><hr>
<p><a NAME="HEADING_2-8"></a>
<h1>2.8 Status/Progress Fields</h1>
<hr>

These fields are used to process the record, to implement monitors for certain
fields, and/or to keep track of data for processing and/or for the operator.
None of these fields are configurable by a database configuration tool. Most of
them can be accessed at run-time, and many can be modified at run-time.

<p>The Current Point (<tt>CPT</tt>) field contains the current point of an
active scan.

<P> The <tt>BUSY</tt> field indicates whether (<tt>1</tt>) or not (<tt>0</tt>) a
scan is in progress.

<P>The <tt>DATA</tt> field indicates the state of the data arrays.  <tt>DATA</tt>
is set to <tt>0</tt> at the beginning of a scan, and is set to <tt>1</tt> after
the data arrays have been posted.  Note that data arrays are not
posted during a scan, but only at the end.

<p>The <tt>VAL</tt> field is used only as a progress indicator.  It is posted
after all point-by-point PVs (e.g., <tt>R1CV</tt>, <tt>D01CV</tt>) have been
posted.  (So, if a PV you're interested in hasn't been posted by the time you
get the <tt>VAL</tt>-field monitor, that PVs value hasn't changed since the
last time it was posted.)

<p>The State Message (<tt>SMSG</tt>) field holds a message sent by the record
that alerts the operator to an error condition. It can be cleared by writing a
<tt>0</tt> to the Command (<tt>CMND</tt>) field.

<p>The Alert (<tt>ALRT</tt>) field is a flag which indicates if an error
condition currently exists. <tt>1</tt> means YES; <tt>0</tt>, NO. The cause of the condition will
be displayed in the <tt>SMSG</tt> field.

<p>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>CPT</tt></td>
<td>Current Point</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BUSY</tt></td>
<td>Scan-is-busy Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>DATA</tt></td>
<td>Data-are-ready flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>VAL</tt></td>
<td>Value Field&nbsp;</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>SMSG</tt></td>
<td>State Message&nbsp;</td>
<td>STRING [40]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ALRT</tt></td>
<td>Alert Field&nbsp;</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p>The scan-phase (<tt>FAZE</tt>) field indicates in which phase of a scan the
record currently is.  The possible phases are as follows:

<table border>

<tr><th>phase</th><th>message</th><th>meaning</th></tr>

<tr><td>0</td><td>IDLE</td><td>Nothing is going on.</td></tr>

<tr><td>1</td><td>INIT_SCAN</td><td>A scan is starting</td></tr>

<tr><td>2</td><td>DO:BEFORE_SCAN</td><td>The next thing to do is trigger the
before-scan link.</td></tr>

<tr><td>3</td><td>WAIT:BEFORE_SCAN</td><td>The before-scan link has been
triggered.  We're waiting for its callback to come in.</td></tr>

<tr><td>4</td><td>MOVE_MOTORS</td><td>The next thing to do is to write to
positioners.</td></tr>

<tr><td>5</td><td>WAIT:MOTORS</td><td>We've told motors to move.  Now we're
waiting for their callbacks to come in.</td></tr>

<tr><td>6</td><td>TRIG_DETECTORS</td><td>The next thing to do is to trigger
detectors.</td></tr>

<tr><td>7</td><td>WAIT:DETECTORS</td><td>We've triggered detectors.  Now we're
waiting for their callbacks to come in.</td></tr>

<tr><td>8</td><td>RETRACE_MOVE</td><td>The next thing to do it send positioners
to their post-scan positions.</td></tr>

<tr><td>9</td><td>WAIT:RETRACE</td><td>We've told positioners to go to their
post-scan positions.  Now we're waiting for their callbacks to come
in.</td></tr>

<tr><td>10</td><td>DO:AFTER_SCAN</td><td>The next thing to do is trigger the
after-scan link.</td></tr>

<tr><td>11</td><td>WAIT:AFTER_SCAN</td><td>The after-scan link has been
triggered.  We're waiting for its callback to come in.</td></tr>

<tr><td>12</td><td>SCAN_DONE</td><td>The scan is finished.</td></tr>

<tr><td>13</td><td>SCAN_PENDING</td><td>A scan has been commanded, but has not
yet started</td></tr>

<tr><td>14</td><td>PREVIEW</td><td>We're doing a preview of the scan.</td></tr>

<tr><td>15</td><td>RECORD SCALAR DATA</td><td>Record scalar data.</td></tr>

</table>


<p>The data-state (<tt>DSTATE</tt>) field indicates in what state is the
processing of data arrays.  The possible states are as follows:

<table border>

<tr><th>state</th><th>message</th><th>meaning</th></tr>

<tr><td>0</td><td>UNPACKED</td><td>Data arrays are either idle or being
filled.  <br>If a client should read an array now, it would get last scan's
data.</td></tr>

<tr><td>1</td><td>TRIG_ARRAY_READ</td><td>The next thing to do is trigger the
array-read PV, <tt>A1PV</tt>.   <br>If a client should read an array now, it
would get last scan's data.</td></tr>

<tr><td>2</td><td>ARRAY_READ_WAIT</td><td><tt>A1PV</tt> has been triggered, and
the callback is still outstanding.   <br>If a client should read an array now,
it would get last scan's data.</td></tr>

<tr><td>3</td><td>ARRAY_GET_CALLBACK_WAIT</td><td>recDynLinkGetCallback() has been
issued for array-valued PVs, and one or more callbacks are still outstanding.
</td></tr>

<tr><td>4</td><td>RECORD_ARRAY_DATA</td><td>It's time to read array data.  If
any array-valued PVs exist, the data state will change to
ARRAY_GET_CALLBACK_WAIT while waiting for the callbacks.</td></tr>

<tr><td>5</td><td>SAVE_DATA_WAIT</td><td>Arrays are filled, but cannot be
posted yet because the data-storage client is not finished writing last scan's
data.   <br>If a client should read an array now, it would get last scan's
data.</td></tr>

<tr><td>6</td><td>PACKED</td><td>Arrays are filled, and buffers have been
switched, but they haven't yet been posted.   <br>If a client should read an
array now, it would get last scan's data.</td></tr>

<tr><td>7</td><td>POSTED</td><td>Data arrays have been posted.  <br>Now the
data-storage client can read this scan's array data.</td></tr>

</table>


<!---------------------------------------------------------------------------->
<br><br><br><hr>
<p><a NAME="HEADING_2-10"></a>
<h2>2.10 Miscellaneous Fields</h2>
<hr>

<p>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>NAME</tt></td>
<td>Record Name</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>DESC</tt></td>
<td>Description</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>PCPT</tt></td>
<td>Previous Current Point&nbsp;</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>PXSC</tt></td>
<td>Previous Execute Scan</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>TOLP</tt></td>
<td>Time of Last Posting&nbsp;</td>
<td>ULONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>TLAP</tt></td>
<td>Time of Last Array Posting&nbsp;</td>
<td>ULONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>VERS</tt></td>
<td>Code Version (This field has not been kept up to date.)</td>
<td>FLOAT</td>
<td>No</td>
<td>1.0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>XSC</tt></td>
<td>Internal copy of <tt>EXSC</tt></td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr><td colspan=9> Private fields</td</tr>

<tr>
<td><tt>RPVT</tt></td>
<td>Record Private&nbsp;</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>DB</tt></td>
<td>Pos. <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>

<tr>
<td><tt>R<i>n</i>DB</tt></td>
<td>Readback <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DB</tt></td>
<td>Detector <i>nn</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tr>

<tr><td colspan=9>
<blockquote>
	<p>The database Address fields (<tt><i>xx</i>DB</tt>) contain pointers to
	the dbAddr structures of the corresponding process variables. For instance,
	<tt>P1DB</tt> points to the dbAddr structure of <tt>P1PV</tt>.
</blockquote>
</td>
</tr>
</table>

</body>
</html>

