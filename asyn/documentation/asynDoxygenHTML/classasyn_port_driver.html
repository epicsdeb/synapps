<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>asyn: asynPortDriver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>asynPortDriver Class Reference</h1><!-- doxytag: class="asynPortDriver" -->Base class for asyn port drivers; handles most of the bookkeeping for writing an asyn port driver with standard asyn interfaces and a parameter library.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="asyn_port_driver_8h-source.html">asynPortDriver.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for asynPortDriver:</div>
<div class="dynsection">

<p><center><img src="classasyn_port_driver.png" usemap="#asynPortDriver_map" border="0" alt=""></center>
<map name="asynPortDriver_map">
<area href="classtest_asyn_port_driver.html" alt="testAsynPortDriver" shape="rect" coords="0,56,119,80">
</map>
</div>

<p>
<a href="classasyn_port_driver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8">asynPortDriver</a> (const char *<a class="el" href="classasyn_port_driver.html#8ddf9106f0496dcdaa47dd9a2255fd6b">portName</a>, int <a class="el" href="classasyn_port_driver.html#0d13d8094512a71769a7d71b83d324cc">maxAddr</a>, int paramTableSize, int interfaceMask, int interruptMask, int asynFlags, int autoConnect, int priority, int stackSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the <a class="el" href="classasyn_port_driver.html" title="Base class for asyn port drivers; handles most of the bookkeeping for writing an...">asynPortDriver</a> class.  <a href="#cf77e873fc4fdbd8d07154ef80dc38b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#74f2e1d0b2abfe03aa9bbe06391c521d">~asynPortDriver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for <a class="el" href="classasyn_port_driver.html" title="Base class for asyn port drivers; handles most of the bookkeeping for writing an...">asynPortDriver</a> class; frees resources allocated when port driver is created.  <a href="#74f2e1d0b2abfe03aa9bbe06391c521d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#6b40e94cb3b954b56e09b6f4ef012b0b">lock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the driver to prevent multiple threads from accessing memory at the same time.  <a href="#6b40e94cb3b954b56e09b6f4ef012b0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#1d1d4af019934b79b9fca0aa444d0036">unlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unocks the driver; called when an asyn client or driver is done accessing common memory.  <a href="#1d1d4af019934b79b9fca0aa444d0036"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#fa59c628c1de272f1802d91e2abda9b1">getAddress</a> (asynUser *pasynUser, int *address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the asyn address associated with a pasynUser structure.  <a href="#fa59c628c1de272f1802d91e2abda9b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#fd2f4b80ce65bf9d02f9bbc32302206a">readInt32</a> (asynUser *pasynUser, epicsInt32 *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt32-&gt;read().  <a href="#fd2f4b80ce65bf9d02f9bbc32302206a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#1215286a6408d471e7405a46519e3216">writeInt32</a> (asynUser *pasynUser, epicsInt32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt32-&gt;write().  <a href="#1215286a6408d471e7405a46519e3216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#61e02fb1d9f5f265ea33c6b17b6ac623">readUInt32Digital</a> (asynUser *pasynUser, epicsUInt32 *value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynUInt32Digital-&gt;read().  <a href="#61e02fb1d9f5f265ea33c6b17b6ac623"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#9879ac9d8d7cf814722bae9ee30e3e3b">writeUInt32Digital</a> (asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynUInt32Digital-&gt;write().  <a href="#9879ac9d8d7cf814722bae9ee30e3e3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#4d3f73ce284bd653559518ca824ba467">setInterruptUInt32Digital</a> (asynUser *pasynUser, epicsUInt32 mask, interruptReason reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynUInt32Digital-&gt;setInterrupt().  <a href="#4d3f73ce284bd653559518ca824ba467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#07665c5512270e342b2eba8476845340">clearInterruptUInt32Digital</a> (asynUser *pasynUser, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynUInt32Digital-&gt;clearInterrupt().  <a href="#07665c5512270e342b2eba8476845340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#14739432073825eca7fd7ad6c042fb3d">getInterruptUInt32Digital</a> (asynUser *pasynUser, epicsUInt32 *mask, interruptReason reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynUInt32Digital-&gt;getInterrupt().  <a href="#14739432073825eca7fd7ad6c042fb3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#383d377be74285d173715caebba856c9">getBounds</a> (asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt32-&gt;<a class="el" href="classasyn_port_driver.html#383d377be74285d173715caebba856c9" title="Called when asyn clients call pasynInt32-&gt;getBounds(), returning the bounds on...">getBounds()</a>, returning the bounds on the asynInt32 interface for drivers that use raw units.  <a href="#383d377be74285d173715caebba856c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#23490f2571c603e16c1ec2a7de9471b2">readFloat64</a> (asynUser *pasynUser, epicsFloat64 *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat64-&gt;read().  <a href="#23490f2571c603e16c1ec2a7de9471b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#75e58b4afefeffdccd93014289256b13">writeFloat64</a> (asynUser *pasynUser, epicsFloat64 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat64-&gt;write().  <a href="#75e58b4afefeffdccd93014289256b13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#5a1d6c60d26f18eb256f397c6d1db3a8">readOctet</a> (asynUser *pasynUser, char *value, size_t maxChars, size_t *nActual, int *eomReason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynOctet-&gt;read().  <a href="#5a1d6c60d26f18eb256f397c6d1db3a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#f7ba9c491b7a486198b9c90ca9b07894">writeOctet</a> (asynUser *pasynUser, const char *value, size_t maxChars, size_t *nActual)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynOctet-&gt;write().  <a href="#f7ba9c491b7a486198b9c90ca9b07894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#e3402f6a7d03b031672c085a1a36c39c">readInt8Array</a> (asynUser *pasynUser, epicsInt8 *value, size_t nElements, size_t *nIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt8Array-&gt;read().  <a href="#e3402f6a7d03b031672c085a1a36c39c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#8521c92d9de5e498e64b45a8f83e15f5">writeInt8Array</a> (asynUser *pasynUser, epicsInt8 *value, size_t nElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt8Array-&gt;write().  <a href="#8521c92d9de5e498e64b45a8f83e15f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#ca2c7b603a1752b94c25059584d98671">doCallbacksInt8Array</a> (epicsInt8 *value, size_t nElements, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynInt8Array interface.  <a href="#ca2c7b603a1752b94c25059584d98671"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#a296a61cffb51af230431310bcdc67bc">readInt16Array</a> (asynUser *pasynUser, epicsInt16 *value, size_t nElements, size_t *nIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt16Array-&gt;read().  <a href="#a296a61cffb51af230431310bcdc67bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#9ba3c7b61f6f06f26bdf542d861ab432">writeInt16Array</a> (asynUser *pasynUser, epicsInt16 *value, size_t nElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt16Array-&gt;write().  <a href="#9ba3c7b61f6f06f26bdf542d861ab432"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#8800a144f8d9699c641075c67d2e3983">doCallbacksInt16Array</a> (epicsInt16 *value, size_t nElements, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynInt16Array interface.  <a href="#8800a144f8d9699c641075c67d2e3983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#836cebf0cba617f9f99f5a498e20281c">readInt32Array</a> (asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt32Array-&gt;read().  <a href="#836cebf0cba617f9f99f5a498e20281c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#f3e0be717536185b760eb5c048a7dcf7">writeInt32Array</a> (asynUser *pasynUser, epicsInt32 *value, size_t nElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynInt32Array-&gt;write().  <a href="#f3e0be717536185b760eb5c048a7dcf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#612f81fb6bfbf5809f5631b057f6880c">doCallbacksInt32Array</a> (epicsInt32 *value, size_t nElements, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynInt32Array interface.  <a href="#612f81fb6bfbf5809f5631b057f6880c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#3e0148ec1ad0e86b7dc171d23fc2f1da">readFloat32Array</a> (asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat32Array-&gt;read().  <a href="#3e0148ec1ad0e86b7dc171d23fc2f1da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#d05acbce2a80dd60d89199629cabded0">writeFloat32Array</a> (asynUser *pasynUser, epicsFloat32 *value, size_t nElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat32Array-&gt;write().  <a href="#d05acbce2a80dd60d89199629cabded0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#92a5fcffe7c880d980efa9613e27cf56">doCallbacksFloat32Array</a> (epicsFloat32 *value, size_t nElements, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynFloat32Array interface.  <a href="#92a5fcffe7c880d980efa9613e27cf56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#f9e0d45589a67b26a54daf95ce31bce8">readFloat64Array</a> (asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat64Array-&gt;read().  <a href="#f9e0d45589a67b26a54daf95ce31bce8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#2c2a82f7e7e0375ca223bbb2cbf29e99">writeFloat64Array</a> (asynUser *pasynUser, epicsFloat64 *value, size_t nElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynFloat64Array-&gt;write().  <a href="#2c2a82f7e7e0375ca223bbb2cbf29e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#672323bfdd2e205ff37047369a5bdab6">doCallbacksFloat64Array</a> (epicsFloat64 *value, size_t nElements, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynFloat64Array interface.  <a href="#672323bfdd2e205ff37047369a5bdab6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#aabc9345e5912981dd5fee6d9175382d">readGenericPointer</a> (asynUser *pasynUser, void *pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynGenericPointer-&gt;read().  <a href="#aabc9345e5912981dd5fee6d9175382d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#85ac345a32f69a2ba2e783603a3fdffe">writeGenericPointer</a> (asynUser *pasynUser, void *pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when asyn clients call pasynGenericPointer-&gt;write().  <a href="#85ac345a32f69a2ba2e783603a3fdffe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#dab692755d43afc2fede3447ea9078e2">doCallbacksGenericPointer</a> (void *pointer, int reason, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by driver to do the callbacks to registered clients on the asynGenericPointer interface.  <a href="#dab692755d43afc2fede3447ea9078e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#684edc92eb34cec6def9131dc638257d">drvUserCreate</a> (asynUser *pasynUser, const char *drvInfo, const char **pptypeName, size_t *psize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by asynManager to pass a pasynUser structure and drvInfo string to the driver; Assigns pasynUser-&gt;reason based on the value of the drvInfo string.  <a href="#684edc92eb34cec6def9131dc638257d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#03d74bfe552845d9624d158dc875b9a1">drvUserGetType</a> (asynUser *pasynUser, const char **pptypeName, size_t *psize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns strings associated with driver-specific commands.  <a href="#03d74bfe552845d9624d158dc875b9a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#865e5bd35906d12d61f0268f2b86d6cd">drvUserDestroy</a> (asynUser *pasynUser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees any resources allocated by drvUserCreate.  <a href="#865e5bd35906d12d61f0268f2b86d6cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#92af1c2ca1851d26b5140cb3357724c7">report</a> (FILE *fp, int details)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports on status of the driver.  <a href="#92af1c2ca1851d26b5140cb3357724c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#55869053a2e52318ec6eefcfa50a2e72">connect</a> (asynUser *pasynUser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects driver to device; the base class implementation simply calls pasynManager-&gt;exceptionConnect.  <a href="#55869053a2e52318ec6eefcfa50a2e72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#fc929bda292a564063558d80899511ab">disconnect</a> (asynUser *pasynUser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnects driver from device; the base class implementation simply calls pasynManager-&gt;exceptionDisconnect.  <a href="#fc929bda292a564063558d80899511ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#20e248e20dcecf64350ad34dda0482be">createParam</a> (const char *name, <a class="el" href="asyn_port_driver_8h.html#a744baae4016b0caa9910b448ccbc456">asynParamType</a> type, int *index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a parameter in the parameter library.  <a href="#20e248e20dcecf64350ad34dda0482be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#18575123378b3bc7f749535ccd7aa8d9">createParam</a> (int list, const char *name, <a class="el" href="asyn_port_driver_8h.html#a744baae4016b0caa9910b448ccbc456">asynParamType</a> type, int *index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a parameter in the parameter library.  <a href="#18575123378b3bc7f749535ccd7aa8d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#a74032eec9808e5c939996aca70a4d7c">findParam</a> (const char *name, int *index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a parameter in the parameter library.  <a href="#a74032eec9808e5c939996aca70a4d7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#9efbeb78ceb5d1ad7d84545f9ee8379b">findParam</a> (int list, const char *name, int *index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a parameter in the parameter library.  <a href="#9efbeb78ceb5d1ad7d84545f9ee8379b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#f221160aa6c599e42b5d678d4ccf7899">getParamName</a> (int index, const char **name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of a parameter in the parameter library.  <a href="#f221160aa6c599e42b5d678d4ccf7899"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#bba1da45d9b3a520ea0cfdb6e01a9ed3">getParamName</a> (int list, int index, const char **name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of a parameter in the parameter library.  <a href="#bba1da45d9b3a520ea0cfdb6e01a9ed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#7cbe73cb1d38341f78a487d3e2411565">reportSetParamErrors</a> (asynStatus status, int index, int list, const char *functionName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports errors when setting parameters.  <a href="#7cbe73cb1d38341f78a487d3e2411565"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#5403d81341bc5a391c0419593e041e4c">reportGetParamErrors</a> (asynStatus status, int index, int list, const char *functionName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports errors when getting parameters.  <a href="#5403d81341bc5a391c0419593e041e4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#e5373b45dd879ea203cf3ab03a7abdb4">setIntegerParam</a> (int index, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for an integer in the parameter library.  <a href="#e5373b45dd879ea203cf3ab03a7abdb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#61d3672e805e68abc4b8584c038e63d9">setIntegerParam</a> (int list, int index, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for an integer in the parameter library.  <a href="#61d3672e805e68abc4b8584c038e63d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#06b7dd2f7144fcf738e28b21aee667ba">setUIntDigitalParam</a> (int index, epicsUInt32 value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a UInt32Digital in the parameter library.  <a href="#06b7dd2f7144fcf738e28b21aee667ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#afa380d26215c47e6c37c5faacc303ce">setUIntDigitalParam</a> (int list, int index, epicsUInt32 value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a UInt32Digital in the parameter library.  <a href="#afa380d26215c47e6c37c5faacc303ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#0f23380aa837eb840490a28e8711369c">setDoubleParam</a> (int index, double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a double in the parameter library.  <a href="#0f23380aa837eb840490a28e8711369c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#a9d64cc4cb1f329de2d3c4949ab50d55">setDoubleParam</a> (int list, int index, double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a double in the parameter library.  <a href="#a9d64cc4cb1f329de2d3c4949ab50d55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#9894fd10123fb620177df68e3c9ae29f">setStringParam</a> (int index, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a string in the parameter library.  <a href="#9894fd10123fb620177df68e3c9ae29f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#cc5f7ac39e11b4e45033d348aeb3f30b">setStringParam</a> (int list, int index, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value for a string in the parameter library.  <a href="#cc5f7ac39e11b4e45033d348aeb3f30b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#366ffed61b558f99911ab6f4292ba7bb">getIntegerParam</a> (int index, int *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for an integer from the parameter library.  <a href="#366ffed61b558f99911ab6f4292ba7bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#bb474605f2e2724b0d4323bd164b407a">getIntegerParam</a> (int list, int index, int *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for an integer from the parameter library.  <a href="#bb474605f2e2724b0d4323bd164b407a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#67232d15dd10d3e0d33289cdd9a4124e">getUIntDigitalParam</a> (int index, epicsUInt32 *value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for an UInt32Digital parameter from the parameter library.  <a href="#67232d15dd10d3e0d33289cdd9a4124e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#decd22e066b5f281c9201aabef4ba164">getUIntDigitalParam</a> (int list, int index, epicsUInt32 *value, epicsUInt32 mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for an UInt32Digital parameter from the parameter library.  <a href="#decd22e066b5f281c9201aabef4ba164"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#6c4515dec6ebceab3796969ae9d3305d">getDoubleParam</a> (int index, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for a double from the parameter library.  <a href="#6c4515dec6ebceab3796969ae9d3305d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#ea8116db0b8e71aa4a3dff619d9e4014">getDoubleParam</a> (int list, int index, double *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for a double from the parameter library.  <a href="#ea8116db0b8e71aa4a3dff619d9e4014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#4c538db4aae903a0eecfc17fcebda02f">getStringParam</a> (int index, int maxChars, char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for a string from the parameter library.  <a href="#4c538db4aae903a0eecfc17fcebda02f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#608aef594ed10ee8e3608ec5e995bb9d">getStringParam</a> (int list, int index, int maxChars, char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value for a string from the parameter library.  <a href="#608aef594ed10ee8e3608ec5e995bb9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#e78a19e5e691019ed119fea17cb8a021">callParamCallbacks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls callParamCallbacks(0, 0) i.e.  <a href="#e78a19e5e691019ed119fea17cb8a021"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#ff391ed40b61aa993afcd52265440f76">callParamCallbacks</a> (int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls callParamCallbacks(addr, addr) i.e.  <a href="#ff391ed40b61aa993afcd52265440f76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual asynStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#67e26db300f62f7724cd28f8bb8340ae">callParamCallbacks</a> (int list, int addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls paramList::callCallbacks(addr) for a specific parameter list.  <a href="#67e26db300f62f7724cd28f8bb8340ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#93675408d6351491c56d8bb874852cd9">reportParams</a> (FILE *fp, int details)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls paramList::report(fp, details) for each parameter list that the driver supports.  <a href="#93675408d6351491c56d8bb874852cd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#b54a75f524c802559e78e7bf000a7c61">callbackTask</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#8ddf9106f0496dcdaa47dd9a2255fd6b">portName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of this asyn port.  <a href="#8ddf9106f0496dcdaa47dd9a2255fd6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#0d13d8094512a71769a7d71b83d324cc">maxAddr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum asyn address (addr) supported by this driver.  <a href="#0d13d8094512a71769a7d71b83d324cc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">asynUser *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#3d701fd7f49ab07da6c5edf3429cdfe5">pasynUserSelf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">asynUser connected to ourselves for asynTrace  <a href="#3d701fd7f49ab07da6c5edf3429cdfe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">asynStandardInterfaces&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyn_port_driver.html#0acc0a49b9d762bdbd7d42af5dbea5ef">asynStdInterfaces</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asyn interfaces this driver implements.  <a href="#0acc0a49b9d762bdbd7d42af5dbea5ef"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for asyn port drivers; handles most of the bookkeeping for writing an asyn port driver with standard asyn interfaces and a parameter library. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cf77e873fc4fdbd8d07154ef80dc38b8"></a><!-- doxytag: member="asynPortDriver::asynPortDriver" ref="cf77e873fc4fdbd8d07154ef80dc38b8" args="(const char *portName, int maxAddr, int paramTableSize, int interfaceMask, int interruptMask, int asynFlags, int autoConnect, int priority, int stackSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynPortDriver::asynPortDriver           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>paramTableSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interfaceMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interruptMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>asynFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>autoConnect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stackSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the <a class="el" href="classasyn_port_driver.html" title="Base class for asyn port drivers; handles most of the bookkeeping for writing an...">asynPortDriver</a> class. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>portName</em>&nbsp;</td><td>The name of the asyn port driver to be created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxAddr</em>&nbsp;</td><td>The maximum number of asyn addr addresses this driver supports. Often it is 1 (which is the minimum), but some drivers, for example a 16-channel D/A or A/D would support values &gt; 1. This controls the number of parameter tables that are created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>paramTableSize</em>&nbsp;</td><td>The number of parameters that this driver supports. This controls the size of the parameter tables. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interfaceMask</em>&nbsp;</td><td>Bit mask defining the asyn interfaces that this driver supports. The bit mask values are defined in <a class="el" href="asyn_port_driver_8h.html">asynPortDriver.h</a>, e.g. asynInt32Mask. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interruptMask</em>&nbsp;</td><td>Bit mask definining the asyn interfaces that can generate interrupts (callbacks). The bit mask values are defined in <a class="el" href="asyn_port_driver_8h.html">asynPortDriver.h</a>, e.g. asynInt8ArrayMask. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asynFlags</em>&nbsp;</td><td>Flags when creating the asyn port driver; includes ASYN_CANBLOCK and ASYN_MULTIDEVICE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoConnect</em>&nbsp;</td><td>The autoConnect flag for the asyn port driver. 1 if the driver should autoconnect. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>The thread priority for the asyn port driver thread if ASYN_CANBLOCK is set in asynFlags. If it is 0 then the default value of epicsThreadPriorityMedium will be assigned by asynManager. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stackSize</em>&nbsp;</td><td>The stack size for the asyn port driver thread if ASYN_CANBLOCK is set in asynFlags. If it is 0 then the default value of epicsThreadGetStackSize(epicsThreadStackMedium) will be assigned by asynManager. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="74f2e1d0b2abfe03aa9bbe06391c521d"></a><!-- doxytag: member="asynPortDriver::~asynPortDriver" ref="74f2e1d0b2abfe03aa9bbe06391c521d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynPortDriver::~asynPortDriver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor for <a class="el" href="classasyn_port_driver.html" title="Base class for asyn port drivers; handles most of the bookkeeping for writing an...">asynPortDriver</a> class; frees resources allocated when port driver is created. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b54a75f524c802559e78e7bf000a7c61"></a><!-- doxytag: member="asynPortDriver::callbackTask" ref="b54a75f524c802559e78e7bf000a7c61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asynPortDriver::callbackTask           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="67e26db300f62f7724cd28f8bb8340ae"></a><!-- doxytag: member="asynPortDriver::callParamCallbacks" ref="67e26db300f62f7724cd28f8bb8340ae" args="(int list, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::callParamCallbacks           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls paramList::callCallbacks(addr) for a specific parameter list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>The asyn address to be used in the callback. Typically the same value as list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ff391ed40b61aa993afcd52265440f76"></a><!-- doxytag: member="asynPortDriver::callParamCallbacks" ref="ff391ed40b61aa993afcd52265440f76" args="(int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::callParamCallbacks           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls callParamCallbacks(addr, addr) i.e. 
<p>
with list=addr, which is normal. 
</div>
</div><p>
<a class="anchor" name="e78a19e5e691019ed119fea17cb8a021"></a><!-- doxytag: member="asynPortDriver::callParamCallbacks" ref="e78a19e5e691019ed119fea17cb8a021" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::callParamCallbacks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls callParamCallbacks(0, 0) i.e. 
<p>
with both list and asyn address. 
</div>
</div><p>
<a class="anchor" name="07665c5512270e342b2eba8476845340"></a><!-- doxytag: member="asynPortDriver::clearInterruptUInt32Digital" ref="07665c5512270e342b2eba8476845340" args="(asynUser *pasynUser, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::clearInterruptUInt32Digital           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynUInt32Digital-&gt;clearInterrupt(). 
<p>
The base class implementation simply sets the value in the parameter library. Derived classes will reimplement this function if they need to perform an action when an clearInterrupt is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>Interrupt mask. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="55869053a2e52318ec6eefcfa50a2e72"></a><!-- doxytag: member="asynPortDriver::connect" ref="55869053a2e52318ec6eefcfa50a2e72" args="(asynUser *pasynUser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::connect           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects driver to device; the base class implementation simply calls pasynManager-&gt;exceptionConnect. 
<p>
Derived classes can reimplement this function for real connection management. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>The pasynUser structure which contains information about the port and address </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="18575123378b3bc7f749535ccd7aa8d9"></a><!-- doxytag: member="asynPortDriver::createParam" ref="18575123378b3bc7f749535ccd7aa8d9" args="(int list, const char *name, asynParamType type, int *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::createParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="asyn_port_driver_8h.html#a744baae4016b0caa9910b448ccbc456">asynParamType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a parameter in the parameter library. 
<p>
Calls paramList::addParam (name, index) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Parameter type </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20e248e20dcecf64350ad34dda0482be"></a><!-- doxytag: member="asynPortDriver::createParam" ref="20e248e20dcecf64350ad34dda0482be" args="(const char *name, asynParamType type, int *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::createParam           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="asyn_port_driver_8h.html#a744baae4016b0caa9910b448ccbc456">asynParamType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a parameter in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#f277a790297fadeb62ba5e972c9da95f" title="Adds a new parameter to the parameter library.">paramList::createParam</a> (list, name, index) for all parameters lists. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Parameter type </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc929bda292a564063558d80899511ab"></a><!-- doxytag: member="asynPortDriver::disconnect" ref="fc929bda292a564063558d80899511ab" args="(asynUser *pasynUser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::disconnect           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disconnects driver from device; the base class implementation simply calls pasynManager-&gt;exceptionDisconnect. 
<p>
Derived classes can reimplement this function for real connection management. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>The pasynUser structure which contains information about the port and address </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92a5fcffe7c880d980efa9613e27cf56"></a><!-- doxytag: member="asynPortDriver::doCallbacksFloat32Array" ref="92a5fcffe7c880d980efa9613e27cf56" args="(epicsFloat32 *value, size_t nElements, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksFloat32Array           </td>
          <td>(</td>
          <td class="paramtype">epicsFloat32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynFloat32Array interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>A client will be called if addr matches the asyn address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="672323bfdd2e205ff37047369a5bdab6"></a><!-- doxytag: member="asynPortDriver::doCallbacksFloat64Array" ref="672323bfdd2e205ff37047369a5bdab6" args="(epicsFloat64 *value, size_t nElements, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksFloat64Array           </td>
          <td>(</td>
          <td class="paramtype">epicsFloat64 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynFloat64Array interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>A client will be called if addr matches the asyn address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dab692755d43afc2fede3447ea9078e2"></a><!-- doxytag: member="asynPortDriver::doCallbacksGenericPointer" ref="dab692755d43afc2fede3447ea9078e2" args="(void *pointer, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksGenericPointer           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>genericPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynGenericPointer interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>genericPointer</em>&nbsp;</td><td>Pointer to the object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>A client will be called if address matches the address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8800a144f8d9699c641075c67d2e3983"></a><!-- doxytag: member="asynPortDriver::doCallbacksInt16Array" ref="8800a144f8d9699c641075c67d2e3983" args="(epicsInt16 *value, size_t nElements, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksInt16Array           </td>
          <td>(</td>
          <td class="paramtype">epicsInt16 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynInt16Array interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>A client will be called if addr matches the asyn address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="612f81fb6bfbf5809f5631b057f6880c"></a><!-- doxytag: member="asynPortDriver::doCallbacksInt32Array" ref="612f81fb6bfbf5809f5631b057f6880c" args="(epicsInt32 *value, size_t nElements, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksInt32Array           </td>
          <td>(</td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynInt32Array interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>A client will be called if addr matches the asyn address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ca2c7b603a1752b94c25059584d98671"></a><!-- doxytag: member="asynPortDriver::doCallbacksInt8Array" ref="ca2c7b603a1752b94c25059584d98671" args="(epicsInt8 *value, size_t nElements, int reason, int addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::doCallbacksInt8Array           </td>
          <td>(</td>
          <td class="paramtype">epicsInt8 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by driver to do the callbacks to registered clients on the asynInt8Array interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>A client will be called if reason matches pasynUser-&gt;reason registered for that client. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>A client will be called if addr matches the asyn address registered for that client. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="684edc92eb34cec6def9131dc638257d"></a><!-- doxytag: member="asynPortDriver::drvUserCreate" ref="684edc92eb34cec6def9131dc638257d" args="(asynUser *pasynUser, const char *drvInfo, const char **pptypeName, size_t *psize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::drvUserCreate           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>drvInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pptypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>psize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by asynManager to pass a pasynUser structure and drvInfo string to the driver; Assigns pasynUser-&gt;reason based on the value of the drvInfo string. 
<p>
This base class implementation looks up the drvInfo string in the parameter list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that driver will modify </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>drvInfo</em>&nbsp;</td><td>String containing information about what driver function is being referenced </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pptypeName</em>&nbsp;</td><td>Location in which driver can write information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>psize</em>&nbsp;</td><td>Location where driver can write information about size of pptypeName </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="865e5bd35906d12d61f0268f2b86d6cd"></a><!-- doxytag: member="asynPortDriver::drvUserDestroy" ref="865e5bd35906d12d61f0268f2b86d6cd" args="(asynUser *pasynUser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::drvUserDestroy           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees any resources allocated by drvUserCreate. 
<p>
This base class implementation does nothing. Derived classes could reimplement this function if they allocate any resources in drvUserCreate, but <a class="el" href="classasyn_port_driver.html" title="Base class for asyn port drivers; handles most of the bookkeeping for writing an...">asynPortDriver</a> classes typically do not need to do so. 
</div>
</div><p>
<a class="anchor" name="03d74bfe552845d9624d158dc875b9a1"></a><!-- doxytag: member="asynPortDriver::drvUserGetType" ref="03d74bfe552845d9624d158dc875b9a1" args="(asynUser *pasynUser, const char **pptypeName, size_t *psize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::drvUserGetType           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>pptypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>psize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns strings associated with driver-specific commands. 
<p>
This base class implementation does nothing. Derived classes could reimplement this function to return the requested information, but most do not reimplement this. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that driver will modify </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pptypeName</em>&nbsp;</td><td>Location in which driver can write information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>psize</em>&nbsp;</td><td>Location where driver can write information about size of pptypeName </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9efbeb78ceb5d1ad7d84545f9ee8379b"></a><!-- doxytag: member="asynPortDriver::findParam" ref="9efbeb78ceb5d1ad7d84545f9ee8379b" args="(int list, const char *name, int *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::findParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a parameter in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#50e1f02b63daeb7a934b717f83db0fc0" title="Finds a parameter in the parameter library.">paramList::findParam</a> (name, index) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a74032eec9808e5c939996aca70a4d7c"></a><!-- doxytag: member="asynPortDriver::findParam" ref="a74032eec9808e5c939996aca70a4d7c" args="(const char *name, int *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::findParam           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a parameter in the parameter library. 
<p>
Calls findParam(0, name, index), i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fa59c628c1de272f1802d91e2abda9b1"></a><!-- doxytag: member="asynPortDriver::getAddress" ref="fa59c628c1de272f1802d91e2abda9b1" args="(asynUser *pasynUser, int *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getAddress           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the asyn address associated with a pasynUser structure. 
<p>
Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>Returned address. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns asynError if the address is &gt; maxAddr value passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="383d377be74285d173715caebba856c9"></a><!-- doxytag: member="asynPortDriver::getBounds" ref="383d377be74285d173715caebba856c9" args="(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getBounds           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt32-&gt;<a class="el" href="classasyn_port_driver.html#383d377be74285d173715caebba856c9" title="Called when asyn clients call pasynInt32-&gt;getBounds(), returning the bounds on...">getBounds()</a>, returning the bounds on the asynInt32 interface for drivers that use raw units. 
<p>
Device support uses these values for unit conversion. The base class implementation simply returns low=0, high=65535. Derived classes can reimplement this function if they support raw units with different limits. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>low</em>&nbsp;</td><td>Address of the low limit. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>high</em>&nbsp;</td><td>Address of the high limit. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea8116db0b8e71aa4a3dff619d9e4014"></a><!-- doxytag: member="asynPortDriver::getDoubleParam" ref="ea8116db0b8e71aa4a3dff619d9e4014" args="(int list, int index, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getDoubleParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for a double from the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#4851347f00ef1ed6a0e1fc7e8ab2dd63" title="Returns the value for a double from the parameter library.">paramList::getDouble</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6c4515dec6ebceab3796969ae9d3305d"></a><!-- doxytag: member="asynPortDriver::getDoubleParam" ref="6c4515dec6ebceab3796969ae9d3305d" args="(int index, double *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getDoubleParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for a double from the parameter library. 
<p>
Calls getDoubleParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb474605f2e2724b0d4323bd164b407a"></a><!-- doxytag: member="asynPortDriver::getIntegerParam" ref="bb474605f2e2724b0d4323bd164b407a" args="(int list, int index, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getIntegerParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for an integer from the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#46156258d7eb8324fb58254fe9ce4b58" title="Returns the value for an integer from the parameter library.">paramList::getInteger</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="366ffed61b558f99911ab6f4292ba7bb"></a><!-- doxytag: member="asynPortDriver::getIntegerParam" ref="366ffed61b558f99911ab6f4292ba7bb" args="(int index, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getIntegerParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for an integer from the parameter library. 
<p>
Calls getIntegerParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="14739432073825eca7fd7ad6c042fb3d"></a><!-- doxytag: member="asynPortDriver::getInterruptUInt32Digital" ref="14739432073825eca7fd7ad6c042fb3d" args="(asynUser *pasynUser, epicsUInt32 *mask, interruptReason reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getInterruptUInt32Digital           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32 *&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interruptReason&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynUInt32Digital-&gt;getInterrupt(). 
<p>
The base class implementation simply returns the value from the parameter library. Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>Interrupt mask address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>Interrupt reason. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bba1da45d9b3a520ea0cfdb6e01a9ed3"></a><!-- doxytag: member="asynPortDriver::getParamName" ref="bba1da45d9b3a520ea0cfdb6e01a9ed3" args="(int list, int index, const char **name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getParamName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of a parameter in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#06c00189483c97d46e2319a661c439c7" title="Returns the name of a parameter from the parameter library.">paramList::getName</a> (index, name) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f221160aa6c599e42b5d678d4ccf7899"></a><!-- doxytag: member="asynPortDriver::getParamName" ref="f221160aa6c599e42b5d678d4ccf7899" args="(int index, const char **name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getParamName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of a parameter in the parameter library. 
<p>
Calls getParamName(0, index, name) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Parameter name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="608aef594ed10ee8e3608ec5e995bb9d"></a><!-- doxytag: member="asynPortDriver::getStringParam" ref="608aef594ed10ee8e3608ec5e995bb9d" args="(int list, int index, int maxChars, char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getStringParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for a string from the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#891e60b55c76e720dd825c81b97958e9" title="Returns the value for a string from the parameter library.">paramList::getString</a> (index, maxChars, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxChars</em>&nbsp;</td><td>Maximum number of characters to return. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4c538db4aae903a0eecfc17fcebda02f"></a><!-- doxytag: member="asynPortDriver::getStringParam" ref="4c538db4aae903a0eecfc17fcebda02f" args="(int index, int maxChars, char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getStringParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for a string from the parameter library. 
<p>
Calls getStringParam(0, index, maxChars, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxChars</em>&nbsp;</td><td>Maximum number of characters to return. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="decd22e066b5f281c9201aabef4ba164"></a><!-- doxytag: member="asynPortDriver::getUIntDigitalParam" ref="decd22e066b5f281c9201aabef4ba164" args="(int list, int index, epicsUInt32 *value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getUIntDigitalParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for an UInt32Digital parameter from the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#8fe749d2526682c9e96b34f2dbb48a00" title="Returns the value for an integer from the parameter library.">paramList::getUInt32</a> (index, value, mask) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The mask to apply when getting the value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67232d15dd10d3e0d33289cdd9a4124e"></a><!-- doxytag: member="asynPortDriver::getUIntDigitalParam" ref="67232d15dd10d3e0d33289cdd9a4124e" args="(int index, epicsUInt32 *value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::getUIntDigitalParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value for an UInt32Digital parameter from the parameter library. 
<p>
Calls getUIntDigitalParam(0, index, value, mask) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to get. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The mask to apply when getting the value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b40e94cb3b954b56e09b6f4ef012b0b"></a><!-- doxytag: member="asynPortDriver::lock" ref="6b40e94cb3b954b56e09b6f4ef012b0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks the driver to prevent multiple threads from accessing memory at the same time. 
<p>
This function is called whenever asyn clients call the functions on the asyn interfaces. Drivers with their own background threads must call <a class="el" href="classasyn_port_driver.html#6b40e94cb3b954b56e09b6f4ef012b0b" title="Locks the driver to prevent multiple threads from accessing memory at the same time...">lock()</a> to protect conflicts with asyn clients. They can call <a class="el" href="classasyn_port_driver.html#1d1d4af019934b79b9fca0aa444d0036" title="Unocks the driver; called when an asyn client or driver is done accessing common...">unlock()</a> to permit asyn clients to run during times that the driver thread is idle or is performing compute bound work that does not access memory also accessible by clients. 
</div>
</div><p>
<a class="anchor" name="3e0148ec1ad0e86b7dc171d23fc2f1da"></a><!-- doxytag: member="asynPortDriver::readFloat32Array" ref="3e0148ec1ad0e86b7dc171d23fc2f1da" args="(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readFloat32Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat32Array-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nIn</em>&nbsp;</td><td>Number of elements actually read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="23490f2571c603e16c1ec2a7de9471b2"></a><!-- doxytag: member="asynPortDriver::readFloat64" ref="23490f2571c603e16c1ec2a7de9471b2" args="(asynUser *pasynUser, epicsFloat64 *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readFloat64           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat64 *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat64-&gt;read(). 
<p>
The base class implementation simply returns the value from the parameter library. Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the value to read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9e0d45589a67b26a54daf95ce31bce8"></a><!-- doxytag: member="asynPortDriver::readFloat64Array" ref="f9e0d45589a67b26a54daf95ce31bce8" args="(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readFloat64Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat64 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat64Array-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nIn</em>&nbsp;</td><td>Number of elements actually read. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classtest_asyn_port_driver.html#7f49b35f2282a1cf1e70e959da1e270a">testAsynPortDriver</a>.</p>

</div>
</div><p>
<a class="anchor" name="aabc9345e5912981dd5fee6d9175382d"></a><!-- doxytag: member="asynPortDriver::readGenericPointer" ref="aabc9345e5912981dd5fee6d9175382d" args="(asynUser *pasynUser, void *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readGenericPointer           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>genericPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynGenericPointer-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>genericPointer</em>&nbsp;</td><td>Pointer to the object to read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a296a61cffb51af230431310bcdc67bc"></a><!-- doxytag: member="asynPortDriver::readInt16Array" ref="a296a61cffb51af230431310bcdc67bc" args="(asynUser *pasynUser, epicsInt16 *value, size_t nElements, size_t *nIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readInt16Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt16 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt16Array-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nIn</em>&nbsp;</td><td>Number of elements actually read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd2f4b80ce65bf9d02f9bbc32302206a"></a><!-- doxytag: member="asynPortDriver::readInt32" ref="fd2f4b80ce65bf9d02f9bbc32302206a" args="(asynUser *pasynUser, epicsInt32 *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readInt32           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt32-&gt;read(). 
<p>
The base class implementation simply returns the value from the parameter library. Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the value to read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="836cebf0cba617f9f99f5a498e20281c"></a><!-- doxytag: member="asynPortDriver::readInt32Array" ref="836cebf0cba617f9f99f5a498e20281c" args="(asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readInt32Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt32Array-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nIn</em>&nbsp;</td><td>Number of elements actually read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3402f6a7d03b031672c085a1a36c39c"></a><!-- doxytag: member="asynPortDriver::readInt8Array" ref="e3402f6a7d03b031672c085a1a36c39c" args="(asynUser *pasynUser, epicsInt8 *value, size_t nElements, size_t *nIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readInt8Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt8 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt8Array-&gt;read(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nIn</em>&nbsp;</td><td>Number of elements actually read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a1d6c60d26f18eb256f397c6d1db3a8"></a><!-- doxytag: member="asynPortDriver::readOctet" ref="5a1d6c60d26f18eb256f397c6d1db3a8" args="(asynUser *pasynUser, char *value, size_t maxChars, size_t *nActual, int *eomReason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readOctet           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nActual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>eomReason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynOctet-&gt;read(). 
<p>
The base class implementation simply returns the value from the parameter library. Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the string to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxChars</em>&nbsp;</td><td>Maximum number of characters to read. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nActual</em>&nbsp;</td><td>Number of characters actually read. Base class sets this to strlen(value). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>eomReason</em>&nbsp;</td><td>Reason that read terminated. Base class sets this to ASYN_EOM_END. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="61e02fb1d9f5f265ea33c6b17b6ac623"></a><!-- doxytag: member="asynPortDriver::readUInt32Digital" ref="61e02fb1d9f5f265ea33c6b17b6ac623" args="(asynUser *pasynUser, epicsUInt32 *value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::readUInt32Digital           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynUInt32Digital-&gt;read(). 
<p>
The base class implementation simply returns the value from the parameter library. Derived classes rarely need to reimplement this function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the value to read. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask value to use when reading the value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92af1c2ca1851d26b5140cb3357724c7"></a><!-- doxytag: member="asynPortDriver::report" ref="92af1c2ca1851d26b5140cb3357724c7" args="(FILE *fp, int details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asynPortDriver::report           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>details</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports on status of the driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fp</em>&nbsp;</td><td>The file pointer on which report information will be written </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>details</em>&nbsp;</td><td>The level of report detail desired</td></tr>
  </table>
</dl>
If details &gt; 1 then information is printed about the contents of the parameter library. If details &gt; 2 then information is printed about all of the interrupt callbacks registered. Derived classes typically reimplement this function to print driver-specific details and then call this base class function. 
</div>
</div><p>
<a class="anchor" name="5403d81341bc5a391c0419593e041e4c"></a><!-- doxytag: member="asynPortDriver::reportGetParamErrors" ref="5403d81341bc5a391c0419593e041e4c" args="(asynStatus status, int index, int list, const char *functionName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asynPortDriver::reportGetParamErrors           </td>
          <td>(</td>
          <td class="paramtype">asynStatus&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>functionName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports errors when getting parameters. 
<p>
asynParamBadIndex and asynParamWrongType are printed with ASYN_TRACE_ERROR because they should never happen. asynParamUndefined is printed with ASYN_TRACE_FLOW because it is an expected error if the value is read before it is defined, which device support can do. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>status</em>&nbsp;</td><td>The error status. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionName</em>&nbsp;</td><td>The name of the function that generated the error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="93675408d6351491c56d8bb874852cd9"></a><!-- doxytag: member="asynPortDriver::reportParams" ref="93675408d6351491c56d8bb874852cd9" args="(FILE *fp, int details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asynPortDriver::reportParams           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>details</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls paramList::report(fp, details) for each parameter list that the driver supports. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fp</em>&nbsp;</td><td>The file pointer on which report information will be written </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>details</em>&nbsp;</td><td>The level of report detail desired. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7cbe73cb1d38341f78a487d3e2411565"></a><!-- doxytag: member="asynPortDriver::reportSetParamErrors" ref="7cbe73cb1d38341f78a487d3e2411565" args="(asynStatus status, int index, int list, const char *functionName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asynPortDriver::reportSetParamErrors           </td>
          <td>(</td>
          <td class="paramtype">asynStatus&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>functionName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports errors when setting parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>status</em>&nbsp;</td><td>The error status. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionName</em>&nbsp;</td><td>The name of the function that generated the error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9d64cc4cb1f329de2d3c4949ab50d55"></a><!-- doxytag: member="asynPortDriver::setDoubleParam" ref="a9d64cc4cb1f329de2d3c4949ab50d55" args="(int list, int index, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setDoubleParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a double in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#fefeefad32cbcb03592d3531be974d29" title="Sets the value for a double in the parameter library.">paramList::setDouble</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f23380aa837eb840490a28e8711369c"></a><!-- doxytag: member="asynPortDriver::setDoubleParam" ref="0f23380aa837eb840490a28e8711369c" args="(int index, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setDoubleParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a double in the parameter library. 
<p>
Calls setDoubleParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="61d3672e805e68abc4b8584c038e63d9"></a><!-- doxytag: member="asynPortDriver::setIntegerParam" ref="61d3672e805e68abc4b8584c038e63d9" args="(int list, int index, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setIntegerParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for an integer in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#c9b677e6f1c3f74e83fb76ffc70b3be3" title="Sets the value for an integer in the parameter library.">paramList::setInteger</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5373b45dd879ea203cf3ab03a7abdb4"></a><!-- doxytag: member="asynPortDriver::setIntegerParam" ref="e5373b45dd879ea203cf3ab03a7abdb4" args="(int index, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setIntegerParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for an integer in the parameter library. 
<p>
Calls setIntegerParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4d3f73ce284bd653559518ca824ba467"></a><!-- doxytag: member="asynPortDriver::setInterruptUInt32Digital" ref="4d3f73ce284bd653559518ca824ba467" args="(asynUser *pasynUser, epicsUInt32 mask, interruptReason reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setInterruptUInt32Digital           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interruptReason&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynUInt32Digital-&gt;setInterrupt(). 
<p>
The base class implementation simply sets the value in the parameter library. Derived classes will reimplement this function if they need to perform an action when an setInterrupt is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>Interrupt mask. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>Interrupt reason. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cc5f7ac39e11b4e45033d348aeb3f30b"></a><!-- doxytag: member="asynPortDriver::setStringParam" ref="cc5f7ac39e11b4e45033d348aeb3f30b" args="(int list, int index, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setStringParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a string in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#fbd657062854b28751627288d0501b43" title="Sets the value for a string in the parameter library.">paramList::setString</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9894fd10123fb620177df68e3c9ae29f"></a><!-- doxytag: member="asynPortDriver::setStringParam" ref="9894fd10123fb620177df68e3c9ae29f" args="(int index, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setStringParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a string in the parameter library. 
<p>
Calls setStringParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afa380d26215c47e6c37c5faacc303ce"></a><!-- doxytag: member="asynPortDriver::setUIntDigitalParam" ref="afa380d26215c47e6c37c5faacc303ce" args="(int list, int index, epicsUInt32 value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setUIntDigitalParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a UInt32Digital in the parameter library. 
<p>
Calls <a class="el" href="classparam_list.html#c9b677e6f1c3f74e83fb76ffc70b3be3" title="Sets the value for an integer in the parameter library.">paramList::setInteger</a> (index, value) for the parameter list indexed by list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>The parameter list number. Must be &lt; maxAddr passed to <a class="el" href="classasyn_port_driver.html#cf77e873fc4fdbd8d07154ef80dc38b8" title="Constructor for the asynPortDriver class.">asynPortDriver::asynPortDriver</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The mask to use when setting the value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="06b7dd2f7144fcf738e28b21aee667ba"></a><!-- doxytag: member="asynPortDriver::setUIntDigitalParam" ref="06b7dd2f7144fcf738e28b21aee667ba" args="(int index, epicsUInt32 value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::setUIntDigitalParam           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value for a UInt32Digital in the parameter library. 
<p>
Calls setUIntDigitalParam(0, index, value) i.e. for parameter list 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The parameter number </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to set. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The mask to use when setting the value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d1d4af019934b79b9fca0aa444d0036"></a><!-- doxytag: member="asynPortDriver::unlock" ref="1d1d4af019934b79b9fca0aa444d0036" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unocks the driver; called when an asyn client or driver is done accessing common memory. 
<p>

</div>
</div><p>
<a class="anchor" name="d05acbce2a80dd60d89199629cabded0"></a><!-- doxytag: member="asynPortDriver::writeFloat32Array" ref="d05acbce2a80dd60d89199629cabded0" args="(asynUser *pasynUser, epicsFloat32 *value, size_t nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeFloat32Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat32Array-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="75e58b4afefeffdccd93014289256b13"></a><!-- doxytag: member="asynPortDriver::writeFloat64" ref="75e58b4afefeffdccd93014289256b13" args="(asynUser *pasynUser, epicsFloat64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeFloat64           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat64&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat64-&gt;write(). 
<p>
The base class implementation simply sets the value in the parameter library and calls any registered callbacks for this pasynUser-&gt;reason and address. Derived classes will reimplement this function if they need to perform an action when an asynFloat64 value is written. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to write. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classtest_asyn_port_driver.html#d68bd63bbdbbb636c412d85a2b3da18a">testAsynPortDriver</a>.</p>

</div>
</div><p>
<a class="anchor" name="2c2a82f7e7e0375ca223bbb2cbf29e99"></a><!-- doxytag: member="asynPortDriver::writeFloat64Array" ref="2c2a82f7e7e0375ca223bbb2cbf29e99" args="(asynUser *pasynUser, epicsFloat64 *value, size_t nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeFloat64Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat64 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynFloat64Array-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85ac345a32f69a2ba2e783603a3fdffe"></a><!-- doxytag: member="asynPortDriver::writeGenericPointer" ref="85ac345a32f69a2ba2e783603a3fdffe" args="(asynUser *pasynUser, void *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeGenericPointer           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>genericPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynGenericPointer-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>genericPointer</em>&nbsp;</td><td>Pointer to the object to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ba3c7b61f6f06f26bdf542d861ab432"></a><!-- doxytag: member="asynPortDriver::writeInt16Array" ref="9ba3c7b61f6f06f26bdf542d861ab432" args="(asynUser *pasynUser, epicsInt16 *value, size_t nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeInt16Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt16 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt16Array-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1215286a6408d471e7405a46519e3216"></a><!-- doxytag: member="asynPortDriver::writeInt32" ref="1215286a6408d471e7405a46519e3216" args="(asynUser *pasynUser, epicsInt32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeInt32           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt32-&gt;write(). 
<p>
The base class implementation simply sets the value in the parameter library and calls any registered callbacks for this pasynUser-&gt;reason and address. Derived classes will reimplement this function if they need to perform an action when an asynInt32 value is written. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to write. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classtest_asyn_port_driver.html#c43147a2c8d0ba9652d65b3ffb23791f">testAsynPortDriver</a>.</p>

</div>
</div><p>
<a class="anchor" name="f3e0be717536185b760eb5c048a7dcf7"></a><!-- doxytag: member="asynPortDriver::writeInt32Array" ref="f3e0be717536185b760eb5c048a7dcf7" args="(asynUser *pasynUser, epicsInt32 *value, size_t nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeInt32Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt32Array-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8521c92d9de5e498e64b45a8f83e15f5"></a><!-- doxytag: member="asynPortDriver::writeInt8Array" ref="8521c92d9de5e498e64b45a8f83e15f5" args="(asynUser *pasynUser, epicsInt8 *value, size_t nElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeInt8Array           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt8 *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynInt8Array-&gt;write(). 
<p>
The base class implementation simply prints an error message. Derived classes may reimplement this function if required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the array to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nElements</em>&nbsp;</td><td>Number of elements to write. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f7ba9c491b7a486198b9c90ca9b07894"></a><!-- doxytag: member="asynPortDriver::writeOctet" ref="f7ba9c491b7a486198b9c90ca9b07894" args="(asynUser *pasynUser, const char *value, size_t maxChars, size_t *nActual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeOctet           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>nActual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynOctet-&gt;write(). 
<p>
The base class implementation simply sets the value in the parameter library and calls any registered callbacks for this pasynUser-&gt;reason and address. Derived classes will reimplement this function if they need to perform an action when an asynOctet value is written. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Address of the string to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nChars</em>&nbsp;</td><td>Number of characters to write. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nActual</em>&nbsp;</td><td>Number of characters actually written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9879ac9d8d7cf814722bae9ee30e3e3b"></a><!-- doxytag: member="asynPortDriver::writeUInt32Digital" ref="9879ac9d8d7cf814722bae9ee30e3e3b" args="(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus asynPortDriver::writeUInt32Digital           </td>
          <td>(</td>
          <td class="paramtype">asynUser *&nbsp;</td>
          <td class="paramname"> <em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsUInt32&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when asyn clients call pasynUInt32Digital-&gt;write(). 
<p>
The base class implementation simply sets the value in the parameter library and calls any registered callbacks for this pasynUser-&gt;reason and address. Derived classes will reimplement this function if they need to perform an action when an asynInt32 value is written. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pasynUser</em>&nbsp;</td><td>pasynUser structure that encodes the reason and address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Value to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask value to use when writinging the value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="0acc0a49b9d762bdbd7d42af5dbea5ef"></a><!-- doxytag: member="asynPortDriver::asynStdInterfaces" ref="0acc0a49b9d762bdbd7d42af5dbea5ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStandardInterfaces <a class="el" href="classasyn_port_driver.html#0acc0a49b9d762bdbd7d42af5dbea5ef">asynPortDriver::asynStdInterfaces</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The asyn interfaces this driver implements. 
<p>

</div>
</div><p>
<a class="anchor" name="0d13d8094512a71769a7d71b83d324cc"></a><!-- doxytag: member="asynPortDriver::maxAddr" ref="0d13d8094512a71769a7d71b83d324cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classasyn_port_driver.html#0d13d8094512a71769a7d71b83d324cc">asynPortDriver::maxAddr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The maximum asyn address (addr) supported by this driver. 
<p>

</div>
</div><p>
<a class="anchor" name="3d701fd7f49ab07da6c5edf3429cdfe5"></a><!-- doxytag: member="asynPortDriver::pasynUserSelf" ref="3d701fd7f49ab07da6c5edf3429cdfe5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynUser* <a class="el" href="classasyn_port_driver.html#3d701fd7f49ab07da6c5edf3429cdfe5">asynPortDriver::pasynUserSelf</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
asynUser connected to ourselves for asynTrace 
<p>

</div>
</div><p>
<a class="anchor" name="8ddf9106f0496dcdaa47dd9a2255fd6b"></a><!-- doxytag: member="asynPortDriver::portName" ref="8ddf9106f0496dcdaa47dd9a2255fd6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classasyn_port_driver.html#8ddf9106f0496dcdaa47dd9a2255fd6b">asynPortDriver::portName</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The name of this asyn port. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/home/epics/devel/asynR4-16/asyn/miscellaneous/<a class="el" href="asyn_port_driver_8h-source.html">asynPortDriver.h</a><li>/home/epics/devel/asynR4-16/asyn/miscellaneous/<a class="el" href="asyn_port_driver_8cpp.html">asynPortDriver.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Jan 15 11:46:44 2011 for asyn by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
