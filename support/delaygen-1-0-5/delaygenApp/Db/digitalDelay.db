# digitalDelay.db
# Support for GigaBaudics digital delay box
# Tim Mooney 9/18/2008
#
# aSub-record fields:
# ---------------------
# A    - the desired delay
# VALA - the closest achievable delay
# VALB - the bit pattern that will produce VALA
# VALC - actual delay - desired delay
# VALD - the next lower delay value
# VALE - the next higher delay value
# C    - delays corresponding to each bit of pattern (array of length $(BITS))
# I    - index array, used to sort VALA (array of length $(N))
# D    - achievable delays (array of length $(N))
# B    - bit patterns corresponding to delays D (array of length $(N))
# E    - if == 1, reinitialize and set back to 0.  (Use if C overwritten.)

record(aSub, "$(P)$(Q)aSub") {
	field(INAM, "digitalDelay_init")
	field(SNAM, "digitalDelay_do")
	field(PREC, "1")
	field(EFLG, "ON CHANGE")
	field(FTA, "DOUBLE")
	field(NOA, "1")
	field(FTVA, "DOUBLE")
	field(NOVA, "1")
	field(OUTA, "$(P)$(Q)actualDelay PP")
	field(FTVB, "LONG")
	field(NOVB, "1")
	field(OUTB, "$(P)$(Q)bitPattern PP")
	field(FTVC, "DOUBLE")
	field(NOVC, "1")
	field(FTVD, "DOUBLE")
	field(NOVD, "1")
	field(FTVE, "DOUBLE")
	field(NOVE, "1")
	field(FTI, "LONG")
	field(NOI, "$(N)")
	field(FTD, "DOUBLE")
	field(NOD, "$(N)")
	field(FTC, "DOUBLE")
	field(NOC, "$(BITS)")
	field(FTB, "LONG")
	field(NOB, "$(N)")
	field(FTE, "LONG")
	field(NOE, "1")
}

record(ao, "$(P)$(Q)desiredDelay") {
	field(OUT, "$(P)$(Q)aSub.A PP")
	field(PINI, "YES")
	field(PREC, "1")
	field(EGU, "ps")
}

record(ao, "$(P)$(Q)actualDelay") {
	field(PREC, "1")
	field(EGU, "ps")
}

record(ao, "$(P)$(Q)nextHigher") {
	field(DOL, "$(P)$(Q)aSub.VALE")
	field(OUT, "$(P)$(Q)desiredDelay.VAL PP")
	field(OMSL, "closed_loop")
	field(PREC, "1")
	field(EGU, "ps")
}

record(ao, "$(P)$(Q)nextLower") {
	field(DOL, "$(P)$(Q)aSub.VALD")
	field(OUT, "$(P)$(Q)desiredDelay.VAL PP")
	field(OMSL, "closed_loop")
	field(PREC, "1")
	field(EGU, "ps")
}
record(longout, "$(P)$(Q)bitPattern") {
	field(OUT, "$(P)$(Q)output.P PP")
}

record(transform, "$(P)$(Q)output") {
	field(CMTA, "ls bit")
	field(CMTM, "ms bit")
	field(CMTN, "latch bit")
	field(CLCA, "p&1?1:0")
	field(CLCB, "p&2?1:0")
	field(CLCC, "p&4?1:0")
	field(CLCD, "p&8?1:0")
	field(CLCE, "p&16?1:0")
	field(CLCF, "p&32?1:0")
	field(CLCG, "p&64?1:0")
	field(CLCH, "p&128?1:0")
	field(CLCI, "p&256?1:0")
	field(CLCJ, "p&512?1:0")
	field(CLCK, "p&1024?1:0")
	field(CLCL, "p&2048?1:0")
	field(CLCM, "p&4096?1:0")
	field(N, "1")
	field(OUTA, "$(OUTDEV)0 PP")
	field(OUTB, "$(OUTDEV)1 PP")
	field(OUTC, "$(OUTDEV)2 PP")
	field(OUTD, "$(OUTDEV)3 PP")
	field(OUTE, "$(OUTDEV)4 PP")
	field(OUTF, "$(OUTDEV)5 PP")
	field(OUTG, "$(OUTDEV)6 PP")
	field(OUTH, "$(OUTDEV)7 PP")
	field(OUTI, "$(OUTDEV)8 PP")
	field(OUTJ, "$(OUTDEV)9 PP")
	field(OUTK, "$(OUTDEV)10 PP")
	field(OUTL, "$(OUTDEV)11 PP")
	field(OUTM, "$(OUTDEV)12 PP")
	field(OUTN, "$(OUTDEV)13 PP")
}
