#
# Bruker CCD snapshot macros
#
# You must to start the SMART5624 program on the Bruker PC
# in command mode before any of this will work. 
#
# In order to save an image to disk, you must run the bruker_save
# function after you take a snapshot, otherwise the image is lost.
#
#
# Edit the snap_cmd and save_cmd variables to get the bruker to do what
# you want. Refer to the online SMART manual and the SMART Service
# manual in the black binder for command syntax.
#
global bruker_ip;
bruker_ip="164.54.112.156:999"
def bruker_init '
{
	local good_pulse
	
	p "Connecting to Bruker PC"
	if(sock_io(bruker_ip, "connect")!=1){
		p "Unable to Connect to Bruker"
		exit
	}
	
#	p "Checking Bruker heartbeat..."
#	good_pulse=" 0 1  d  0  0  0 ff 40  0  0"
#	sock_io(bruker_ip, "send", "h\n\n")
#	tmp=sock_io(bruker_ip, "read")
#	if(tmp==good_pulse){
#		p "Got heartbeat, SMART running"
#	}else{
#		p "ERROR: SMART is not running on bruker PC"
#		exit
#	}
	
	p "Logging into Smart Service"
	sock_io(bruker_ip, "send", "y\n\n")
	sock_io(bruker_ip, "read")
#	p "Sending username = smartservice"
	sock_io(bruker_ip, "send", "smartService\n\n")
	sock_io(bruker_ip, "read")
#	p "Sending password = bruker"THERE IS NO PASSWORD
	sock_io(bruker_ip, "send", "\n\n")
	tmp=sock_io(bruker_ip, "read")
	if(tmp="Authenticated OK"){
		p tmp
	}else{
		p tmp
		exit
	}
	tmp=sock_io(bruker_ip,"send","o\n\n")
	done="not done"
	while(done!=""){
	   done=sock_io(bruker_ip,"read")
	   p done
	}
	tmp=sock_io(bruker_ip,"send","C\n\n")
	sock_io(bruker_ip, "read")
}'
def bruker_snap '{
	local snap_cmd
	local ifshut
	
	if ($2==1) {
		ifshut="/SHUTTER"
	} else {
		ifshut=""
	}
	# comment out one of these depending on options you want
#	snap_cmd="M ADD "$1" /DISPLAY=-1 /DISABLE_CORRECTION /NOCORREL "ifshut"\n\n"
	snap_cmd="M ADD "$1" /DISPLAY=-1 /NOCORREL "ifshut"\n\n"
	sock_io(bruker_ip, "send", snap_cmd)
}'


def wait_next_cmd '{
  	done="not done"
	while(done !=""){
	   tmp=sock_io(bruker_ip,"read")
	   p tmp
	   if (index(tmp,"command")!=0)
	   {
	   	done=""
	   }
	   	
	}
  p "got it"


}'


def bruker_test '{
local ii
local ecnt
local is_save_everything

# test Bruker stability Jan05
ecnt=1000
is_save_everything =0

for(ii=7811;ii<=1000000;ii++){
  p ii,date()
  bruker_snap 5
  #sleep(10)
  wait_next_cmd
  if (is_save_everything)
  {  
 	 filen="brukertest2_" ii
 	 bruker_save(filen,filen)
 	 #sleep(10)
  
 	 wait_next_cmd
  
 	 filen ="brukertestw2_" ii
 	 bruker_unwarp("$$FRAME",filen,1)
 	 #sleep(10)
 	 
 	 wait_next_cmd
    }
	ecnt=ecnt+1
    if (ecnt>200)
    {  
  
        unix("cat timemail.txt | mail -tw tmadden@anl.gov")


	 filen="brukertest3_" ii
 	 bruker_save(filen,filen)
 
 	 wait_next_cmd
  
 	 filen ="brukertestw3_" ii
 	 bruker_unwarp("$$FRAME",filen,1)
 	 
 	 wait_next_cmd
  

       ecnt=0
     }

  }
}'

def bruker_snap_wait '{
	local snap_cmd
	local ifshut	
	if ($2==1) {
		ifshut="/SHUTTER"
	} else {
		ifshut=""
	}
	#read the first line, which should start with SA, to initialize
        p sock_io(bruker_ip,"read")	
	snap_cmd="M ADD "$1" /DISABLE_CORRECTION /NOCORREL "ifshut"\n\n"
#	snap_cmd="M ADD "$1" /NOCORREL "ifshut"\n\n"
	sock_io(bruker_ip, "send", snap_cmd)
# after snap completed, new information starting with SA is created - use this to test return
        done=0
	while(done!=1){
	     sleep(0.5)
	     tmp=sock_io(bruker_ip,"read")
	     split(tmp,stg," ")
	     if(stg[0]=="SA") {
			done=1;
			}	
	}
	sleep(0.5)	
}'

def bruker_save(n,m) '{
	local save_cmd
	
	if(n==""){
	   eprint "Usage: bruker_save(\"filename\",\"frame title\")"
	}
	save_cmd="M SAVE "n" /TITLE="m" /DISPLAY=-1\n\n"
#	p save_cmd
	sock_io(bruker_ip, "send", save_cmd)
	tmp=sock_io(bruker_ip,"read")
}'

def bruker_unwarp(n,m,l) '{
        local unwarp_cmd
 	if(n==""){
	   eprint "Usage: bruker_unwarp(\"warped input filename\",\"unwarped output filename\",\"#frames to process\")"
	}
	unwarp_cmd="M SPATIAL /UNWARP "n" "l" "m" /DISPLAY=-2\n\n"
#	p unwarp_cmd
	sock_io(bruker_ip, "send", unwarp_cmd)
	tmp=sock_io(bruker_ip,"read")
}'
       

def bruker_close '{
	sock_io(bruker_ip,"close")
}'
def bruker_shutter '{
	local line

	line = "M SHUTTER\n\n"
	sock_io(bruker_ip,"send", line)
}'
def bruker_check(n) '{

	stat=5
	old=sock_io(bruker_ip,"timeout")
	sock_io(bruker_ip,"timeout",0)
	done=1
	while(done!=0){
	sock_io(bruker_ip,"send","o\n\n")
	i=0;
	while(i!=1){
	   tmp=sock_io(bruker_ip,"read")
#	   if(tmp!="")p tmp
	   split(tmp,stg," ")
	   if(stg[0]=="DE"){
	      if(n==1){
	         done=stg[1]
	      }else{
	         done=0
	      }
	      stat=stg[1]
	   }
	   if(stg[0]=="SZ") i=1
	}
	}
	sock_io(bruker_ip,"timeout",old)
	return(stat)
}'
def bruker_wait '{

	stat=5
	done=0
	old=sock_io(bruker_ip,"timeout")
	sock_io(bruker_ip,"timeout",0)
	while(done!=1){
		tmp=sock_io(bruker_ip,"read")
		split(tmp,stg," ")
                p tmp,stg
		if(stg[0]=="SC"){
			oldtime=stg["2"];
			done=1;
		}
	}
	sock_io(bruker_ip,"timeout",old)
}'
def bruker_clear '{

	stat=5
	done=0
	old=sock_io(bruker_ip,"timeout")
	sock_io(bruker_ip,"timeout",0)
	while(done!=1){
		tmp=sock_io(bruker_ip,"read")
#		split(tmp,stg," ")
		if(tmp==""){
			done=1
		}
	}
	sock_io(bruker_ip,"timeout",old)
}'
	