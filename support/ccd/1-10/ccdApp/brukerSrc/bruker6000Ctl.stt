program bruker6000Ctl("P=15IDB:")

%{
 #include <string.h>
 #include <time.h>
 #include <math.h>
 #include <errlog.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include "epicsTypes.h"
 #include "shareLib.h"
 #include <osdSock.h>
 #include <osiSock.h> 
 #include <errlog.h> 


 #define DEFAULT_PORT 999 
 #define SERVER "164.54.162.19" 
 #define USERNAME "SmartService"
 #define PASSWORD "bruker"
 #define STARTSTR "w c:\\saxi\\smart32\\smart.exe /com  > c:\\std.out"
}%

					
/* This program must be compiled with the recursive option */
option +r;
struct     sockaddr_in    srv_addr, cli_addr;
SOCKET     cli_sock[2];

char writeBuffer[2][1000];
char readBuffer[2][1000];
int  iLB;
char logBuffer[10][200];
int  iRB;
char returnBuffer[10][200];
int receive_wait;

 

string stringIn;           
assign stringIn to "{P}brukerCtlStringIn.VAL";
monitor stringIn;

string stringOut;           
assign stringOut to "{P}brukerCtlStringOut.VAL";

string heartbeat;           
assign heartbeat to "{P}brukerCtlHeartbeat.VAL";

string fileName1;          
assign fileName1 to "{P}brukerCtlFileName1.VAL";

string fileName2;          
assign fileName2 to "{P}brukerCtlFileName2.VAL";

string titleName;        
assign titleName to "{P}brukerCtlTitleName.VAL";

string addTime;          
assign addTime to "{P}brukerCtlAddTime.VAL";

string maxDispCts;          
assign maxDispCts to "{P}brukerCtlMaxDspCts.VAL";

string resetInv;          
assign resetInv to "{P}brukerCtlResetInv.VAL";


string drkFrame;        
assign drkFrame to "{P}brukerCtlDrkFrame.VAL";

string version;          
assign version to "{P}brukerCtlVersion.VAL";

string logString;          
assign logString to "{P}brukerCtlLog.VAL";

string rtValString;          
assign rtValString to "{P}brukerCtlRtVal.VAL";

int rtValGet;          
assign rtValGet to "{P}brukerCtlRtValBI.VAL";
monitor rtValGet;

int heartbeatGet;          
assign heartbeatGet to "{P}brukerCtlHeartbeatBI.VAL";
monitor heartbeatGet;

int versionGet;           
assign versionGet to "{P}brukerCtlVersionBI.VAL";
monitor versionGet;

int verbose;
assign verbose to "{P}brukerCtlVerbose.VAL";
monitor verbose;

int takeStill;
assign takeStill to "{P}brukerCtlTakeStillBI.VAL";
monitor takeStill;

int correl;
assign correl to "{P}brukerCtlCorrel.VAL";

int useShut;
assign useShut to "{P}brukerCtlUseShut.VAL";

int useAtten;
assign useAtten to "{P}brukerCtlUseAtten.VAL";

int useFlood;
assign useFlood to "{P}brukerCtlUseFlood.VAL";

string addingBI;
assign addingBI to "{P}brukerCtlAddingBI.VAL";

int connect_second_sock;
int connect_receive;
int msgLen;
int jLogLines; 
int jReturnLines;
int adding_done;


evflag brukerInMon;            
sync  stringIn		brukerInMon;

evflag versionMon;            
sync  versionGet	versionMon;

evflag heartbeatMon;            
sync  heartbeatGet	heartbeatMon;

evflag rtValMon;            
sync  rtValGet	rtValMon;

evflag takeStillMon;            
sync  takeStill	takeStillMon;


ss smartLogger {
	state init {
		when() {
%%			connectSock1(ssId, pVar, 0);
			connect_second_sock = 1;
		} state monitor_inputs
	}
    state monitor_inputs {
		when(){
%{			
			pVar->msgLen = recvMessage(ssId, pVar, 0);
			printf("BrkLg: {%s}\n", pVar->readBuffer[0]); 			
			pVar->jLogLines=stripLogBuffer(ssId, pVar, 0);
}%			
			for (iLB=0; iLB<jLogLines; iLB++) {
%%				strcpy(pVar->logString, pVar->logBuffer[pVar->iLB]);
				if (msgLen > 2) pvPut(logString); 
			}
		} state monitor_inputs
    }
}


ss smartSend {
    /* Initialize things when first starting */
    state init {
        when(connect_second_sock==1) {
%%			connectSock2(ssId, pVar, 1);
			efClear(brukerInMon);
 			efClear(versionMon);
 			efClear(heartbeatMon);
			connect_receive=1;
		} state send_outputs

		when() {

		} state init

    }  /* End state init */

    state send_outputs {

		when(efTestAndClear(brukerInMon)){
%%			strcpy(pVar->writeBuffer[1], pVar->stringIn);
%%			strcpy(pVar->stringOut, pVar->stringIn);
			pvPut(stringOut);
%%			sendMessage(ssId, pVar, 1);
		} state send_outputs

 		when(efTestAndClear(versionMon)&(versionGet==1)){
%{			strcpy(pVar->writeBuffer[1], "V");
			sendMessage(ssId, pVar, 1);
			strcpy(pVar->version,pVar->readBuffer[1]);
}%			pvPut(version);
		} state send_outputs

 		when(efTestAndClear(heartbeatMon)&(heartbeatGet==1)){
%{			strcpy(pVar->writeBuffer[1], "H");
			sendMessage(ssId, pVar, 1);
			strcpy(pVar->heartbeat,pVar->readBuffer[1]);
}%			pvPut(heartbeat);
		} state send_outputs

 		when(efTestAndClear(rtValMon)&(rtValGet==1)){
%{			strcpy(pVar->writeBuffer[1], "O");
			sendMessage(ssId, pVar, 1);
			strcpy(pVar->rtValString,pVar->readBuffer[1]);
}%			pvPut(rtValString);
		} state send_outputs

 		when(efTestAndClear(takeStillMon)&(takeStill==1)){
			pvGet(useAtten);
			pvGet(useShut);
			pvGet(correl);
			pvGet(useFlood);
			pvGet(maxDispCts);
			pvGet(addTime);
			pvGet(resetInv);

%{			
			sprintf(pVar->writeBuffer[1], "M ADD %s /DISPLAY=%s /RESET=%s", pVar->addTime, pVar->maxDispCts, pVar->resetInv);
			if (pVar->useShut)
				strcat(pVar->writeBuffer[1], " /SHUT");
			if(pVar->correl)
				strcat(pVar->writeBuffer[1], " /NOCORREL");
			if (pVar->useFlood)
				strcat(pVar->writeBuffer[1], " /DISABLE_CORRECTION");
			if(pVar->useAtten)
				strcat(pVar->writeBuffer[1], " /ATTENUATOR ");
			sendMessage(ssId, pVar, 1);
			strcpy(pVar->addingBI, "ADDING"); 
}%			

		} state send_outputs

    }
}

ss smartReceive {
    state init {
        when(connect_receive==1) {
		} state monitor_inputs

		when() {
		} state init
    }  

    state monitor_inputs {
 		when(){
%%			recvMessage(ssId, pVar, 1);		
%%			printf("BrkReturn:{%s}\n", pVar->readBuffer[1]); 
%%			pVar->jReturnLines=stripReturnBuffer(ssId, pVar, 0);
%%			strcpy(pVar->addingBI, "Ready"); 
%%			printf("BrkReturn:{%s}\n", pVar->addingBI); 
		} state monitor_inputs
    }
}





/* Begin C code functions */
%{
static int openSmartService(SS_ID ssId, struct UserVar *pVar, int isock)
{
	int port;
	port = DEFAULT_PORT;

	cli_sock[isock]=epicsSocketCreate(PF_INET,SOCK_STREAM,0);

	if (cli_sock[isock]==INVALID_SOCKET){
 		printf( "Sockets error %d: Couldn't create socket.\n", SOCKERRNO);
	    return -1;
	}

	cli_addr.sin_family=AF_INET;
	cli_addr.sin_addr.s_addr=INADDR_ANY;        
	cli_addr.sin_port=0;                /* no specific port req'd */

/* Bind client socket to any local interface and port */

	if (bind(cli_sock[isock],(struct sockaddr*)&cli_addr,sizeof(cli_addr))!=0){
 		printf( "Sockets error %d: Couldn't bind socket.\n", SOCKERRNO);
		return -1;
	}


	srv_addr.sin_family = AF_INET;
	srv_addr.sin_addr.s_addr = inet_addr(SERVER); 
	srv_addr.sin_port=htons(port);

/* Connect to FTP server at address SERVER */

	if (connect(cli_sock[isock],(struct sockaddr*)&srv_addr,sizeof(srv_addr))!=0){
		printf( "Sockets error %d: Client couldn't connect to socket.\n", SOCKERRNO);
		return -1;
	}
	return 0;
}

static int connectSock1(SS_ID ssId, struct UserVar *pVar, int isock)
{
	openSmartService(ssId, pVar, 0); 
	strcpy(pVar->writeBuffer[isock], "c");
	sendMessage(ssId, pVar, 0);
	strcpy(pVar->writeBuffer[isock], STARTSTR);
	sendMessage(ssId, pVar, 0);
	recvMessage(ssId, pVar, 0);
	strcpy(pVar->writeBuffer[isock], USERNAME);
	sendMessage(ssId, pVar, 0);
	recvMessage(ssId, pVar, 0);
	strcpy(pVar->writeBuffer[isock], PASSWORD);
	sendMessage(ssId, pVar, 0);
   return 0;
}

static int connectSock2(SS_ID ssId, struct UserVar *pVar, int isock)
{	
	openSmartService(ssId, pVar, 1);
	strcpy(pVar->writeBuffer[isock], "M");
	sendMessage(ssId, pVar, 1);
	recvMessage(ssId, pVar, 1);
	strcpy(pVar->writeBuffer[isock], USERNAME);
	sendMessage(ssId, pVar, 1);
	recvMessage(ssId, pVar, 1);
	strcpy(pVar->writeBuffer[isock], PASSWORD);
	sendMessage(ssId, pVar, 1);
 	strcpy(pVar->writeBuffer[isock], "O");
	sendMessage(ssId, pVar, 1);
   return 0;
}

static int sendMessage(SS_ID ssId, struct UserVar *pVar, int isock)
{
 	int retval, len; 
	strcat(pVar->writeBuffer[isock],"\r\n");
	len = strlen(pVar->writeBuffer[isock]);
    if (pVar->verbose) printf("\nsending %ssize %d\n", pVar->writeBuffer[isock], len);
	retval = send(cli_sock[isock],pVar->writeBuffer[isock], len,0); 
	if (retval != 0) { 
		printf("send() failed: error %d\n",SOCKERRNO); 
	} 
	flushWriteBuffer(ssId, pVar, isock);
    return 0;
}


static int recvMessage(SS_ID ssId, struct UserVar *pVar, int isock)
{
	int retval; 
	if (pVar->verbose) printf("Socket # %d recv\n", isock);
	flushReadBuffer(ssId, pVar, isock);
	retval = recv(cli_sock[isock], pVar->readBuffer[isock], sizeof (pVar->readBuffer[isock]),0 ); 
	if (pVar->verbose) printf("Received %d bytes, data [%s] from client\n",retval, pVar->readBuffer[isock]); 
	if (retval != 0) { 
		printf("recv() failed: error %d\n",SOCKERRNO); 
		epicsSocketDestroy(cli_sock[isock]); 
	} 
	return retval;
}

static int flushWriteBuffer(SS_ID ssId, struct UserVar *pVar, int isock)
{	
	int i;
	for (i=0;i<128;i++) pVar->writeBuffer[isock][i]='\0';
	return 0;
}

static int flushReadBuffer(SS_ID ssId, struct UserVar *pVar, int isock)
{	
	int i;
	for (i=0;i<128;i++) pVar->readBuffer[isock][i]='\0';
	return 0;
}

static int stripLogBuffer(SS_ID ssId, struct UserVar *pVar, int isock)
{
	int i, strlngth, j;
	char tempBuffer[200];
	strlngth = strlen(pVar->readBuffer[0]);
	if (strlngth > 200) strlngth = 200;
	if (pVar->verbose) printf("strlength= %d\n", strlngth); 
	j=0;
	for (i=0;i<strlngth;i++) {
		tempBuffer[i] = pVar->readBuffer[0][i];
		if (pVar->verbose) printf("readBuffer[0][ %d]=%d, %c\n", i, pVar->readBuffer[0][i], pVar->readBuffer[0][i]); 
		if (pVar->readBuffer[0][i] == 13) {
			tempBuffer[i] = '\0';
			i++;
			if (pVar->verbose) printf("readBuffer[0][ %d]=%d, %c\n", i, pVar->readBuffer[0][i], pVar->readBuffer[0][i]); 
			tempBuffer[i] = '\0';
			strcpy(pVar->logBuffer[j], tempBuffer);
			j++;
		}
	}
	return j;
}

static int stripReturnBuffer(SS_ID ssId, struct UserVar *pVar, int isock)
{
	int i, strlngth, j;
	char tempBuffer[200];
	strlngth = strlen(pVar->readBuffer[1]);
	if (strlngth > 200) strlngth = 200;
	if (pVar->verbose) printf("strlength= %d\n", strlngth); 
	j=0;
	for (i=0;i<strlngth;i++) {
		tempBuffer[i] = pVar->readBuffer[1][i];
		if (pVar->verbose) printf("readBuffer[1][ %d]=%d, %c\n", i, pVar->readBuffer[1][i], pVar->readBuffer[1][i]); 
		if (pVar->readBuffer[1][i] == 13) {
			tempBuffer[i] = '\0';
			i++;
			if (pVar->verbose) printf("readBuffer[1][ %d]=%d, %c\n", i, pVar->readBuffer[1][i], pVar->readBuffer[1][i]); 
			tempBuffer[i] = '\0';
			strcpy(pVar->returnBuffer[j], tempBuffer);
			j++;
		}
	}
	return j;
}

}%
