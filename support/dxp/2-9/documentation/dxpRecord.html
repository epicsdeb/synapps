<html>
<head>
  <title>DXP - DXP Record</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>

<body>
<h1>DXP Record</h1>
<address>
  Mark Rivers
</address>
<hr>

<h2 align="center">Contents</h2>
<ul>
  <li><a href="#Overview">
                Overview</a></li>
  <li><a href="#Device Address Fields">
                Device Address Fields</a></li>
  <li><a href="#Array Fields">
                Array Fields</a></li>
  <li><a href="#Fields to Start and Stop Data Acquisition">
                Fields to Start and Stop Data Acquisition</a></li>
  <li><a href="#Task Control Fields">
                Task Control Fields</a></li>
  <li><a href="#High-level Control and Readback Fields">
                High-level Control and Readback Fields</a></li>
  <li><a href="#High-Level Run Statistics Fields">
                High-Level Run Statistics Fields</a></li>
  <li><a href="#Single Channel Analyzer (SCA) Fields">
                Single Channel Analyzer (SCA) Fields</a></li>
  <li><a href="#Low-level Fields">
                Low-level Fields</a></li>
  <li><a href="#Record Processing">
                Record Processing</a></li>
  <li><a href="#Debugging">
                Debugging</a></li>
  <li><a href="#Implementation Details">
                Implementation Details</a></li>
  <li><a href="#Future Plans">
                Future Plans</a></li>
  <li><a href="#Graphical Displays">
                Graphical Displays</a></li>
</ul>

<h2 align="center"><a name="Overview">
                            Overview</a></h2>

<p>The DXP record provides EPICS control of all of the
parameters for detector electronics from 
<a href="http://www.xia.com"target="_blank">XIA</a>.
These include both high-level parameters like peaking time, 
and all of the low-level device parameters. The DXP record
is not intended for collecting spectra.  That is done using the
<a href="http://cars.uchicago.edu/software/epics/mcaRecord.html"target="_blank">EPICS MCA record</a>.
<p>
The DXP Record communicates with the hardware using the 
<a href="http://www.xia.com/DXP_Software.html#Drivers" target="_blank">XIA Handel library</a>,
which in turn communicates with the
<a href="http://www.xia.com/Manuals/XIA_Host_Software_Manual.pdf" target="_blank">XIA Xerxes library</a>.

It currently supports the following hardware and operating systems:</p>
<ul>
  <li>The DXP Saturn running the EPICS IOC on Windows, using the
      parallel port.</li>
  <li>The DXP Saturn running the EPICS IOC on Linux, using the
      parallel port.</li>
  <li>The DXP2X running the EPICS IOC on vxWorks, using the 
      Kinetic Systems VME to CAMAC interface.
  <li>The xMAP running the EPICS IOC on Windows, using the National Instruments
      PCI to PXI adapter.</li>
</ul>

The DXP Record can perform the following tasks:
<ul>
  <li>Set high-level parameters like peaking time, fast filter threshold,
      etc. that result in a number of low-level parameters being changed.</li>
  <li>Start and stop data acquisition.</li>
  <li>Directly modify the low-level device parameters.  This is not recommended
      except for expert users!</li>
  <li>Read back the actual values of all high-level and low-level parameters.</li>
  <li>Read the baseline histogram array.</li>
  <li>Read the baseline history array.</li>
  <li>Read the ADC trace array, which provides the functionality of a 
      digital oscilloscope on the detector pre-amp input.</li>
  <li>Open and close the input relay, isolating or connecting the
      module from the detector pre-amp.</li>
  <li>Set the SCA regions, and read the SCA counts when acquisition
      completes</li>
</ul>


<p>This document does not attempt to explain the meaning or use of all of the DXP parameters.
The best documentation of the operation of the DXP modules is provided by XIA in the 
<a href="http://www.xia.com/Manuals/Kepler_Saturn_Manual_4.0.1.pdf" target="_blank">
Saturn User's Manual</a>.  That manual also describes the Kepler software, which does
not apply to EPICS users, but it provides an excellent description of the theory of
digital pulse processing as implemented in the DXP models from XIA.</p>


<p> In the "Access" columns in the field description tables below: </p>

<table>
  <tbody>
    <tr valign="top">
      <td>R</td>
      <td>Read only</td>
      <td></td>
    </tr>
    <tr valign="top">
      <td>R/W</td>
      <td>Read and write are allowed</td>
      <td></td>
    </tr>
    <tr valign="top">
      <td>R/W*</td>
      <td>Read and write are allowed; write triggers record processing if the
        record's SCAN field is set to "Passive".</td>
      <td></td>
    </tr>
    <tr valign="top">
      <td>N</td>
      <td>No access allowed</td>
      <td></td>
    </tr>
  </tbody>
</table>

<p>  </p>
<hr>

<h2 align="center"><a name="Device Address Fields">
                            Device Address Fields</a></h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>INP</td>
      <td>R</td>
      <td>"Input specification"</td>
      <td>DBF_STRING</td>
      <td>The name of the asyn "port" that has been created with dxpConfig() 
          for this hardware. This must be specified when loading the record
          at iocInit().</td>
    </tr>
    <tr valign="top">
      <td>MTYP</td>
      <td>R</td>
      <td>"Module type"</td>
      <td>DBF_LONG</td>
      <td>The module type (defined in epicsHandelUtils.h) for the hardware model.</td>
    </tr>
  </tbody>
</table>

<p></p>
<hr>

<h2 align="center"><a name="Array Fields">
                            Array Fields</a></h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>BASE</td>
      <td>R</td>
      <td>"Baseline Histogram"</td>
      <td>DBF_LONG</td>
      <td>The baseline histogram array.  This array is read from the hardware
          by writing 1 to the .READ_HISTOGRAM field.  The baseline histogram 
          provides a valuable diagnostic of the electronic noise in the system.
          It should ideally be a perfect Gaussian, with a FWHM equal to the 
          electronic noise in the baseline.</td>
    </tr>
    <tr valign="top">
      <td>BASE­_CUT</td>
      <td>R</td>
      <td>"Baseline Cut"</td>
      <td>DBF_LONG</td>
      <td>The baseline histogram cut array.  This array is used to display visually where
          the baseline cut is set on the baseline histogram plot.  It is updated
          when the baseline cut is enabled/disabled, or when the BLMIN or BLMAX low-level
          parameters are changed by the XIA firmware.</td>
    </tr>
    <tr valign="top">
      <td>BASE­_X</td>
      <td>R</td>
      <td>"Baseline Histogram X"</td>
      <td>DBF_FLOAT</td>
      <td>The baseline histogram X axis array.  This array is used to display the baseline
          histogram with an X-axis calibrated in keV.</td>
    </tr>
    <tr valign="top">
      <td>BHIST</td>
      <td>R</td>
      <td>"Baseline History"</td>
      <td>DBF_LONG</td>
      <td>The baseline history array.  This array is read from the hardware
          by writing 1 to the .READ_HISTORY field.  The baseline history 
          provides a valuable diagnostic of the electronic noise in the system.
          It provides a plot of the most recent baseline values versus time.</td>
    </tr>
    <tr valign="top">
      <td>BHIST­_X</td>
      <td>R</td>
      <td>"Baseline History X"</td>
      <td>DBF_FLOAT</td>
      <td>The baseline history X axis array.  This array is used to display the baseline
          histogram with an X-axis calibrated in microseconds.  
          NOTE: This field currently only contains calibrated values for the xMAP hardware.  
          It is not possible to obtain calibrated time values for the Saturn or DXP-2X.</td>
    </tr>
    <tr valign="top">
      <td>TRACE</td>
      <td>R</td>
      <td>"ADC trace"</td>
      <td>DBF_LONG</td>
      <td>The ADC trace array. This array is read from the hardware by writing 1
          to the .READ_TRACE field.  The ADC trace provides the equivalent of a digital
          scope trace of the pre-amp input to the module.  The time per point can be
          controlled with the .TRACE_WAIT field.</td>
    </tr>
    <tr valign="top">
      <td>TRACE­_X</td>
      <td>R</td>
      <td>"ADC Trace X"</td>
      <td>DBF_FLOAT</td>
      <td>The ADC trace X axis array.  This array is used to display the ADC trace
          with an X-axis calibrated in microseconds.  It is updated when .TRACE_WAIT
          is changed.</td>
    </tr>
  </tbody>
</table>

<p> </p>
<hr>

<h2 align="center"><a name="Fields to Start and Stop Data Acquisition"> </a>
                            Fields to Start and Stop Data Acquisition</h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>STRT</td>
      <td>R/W*</td>
      <td>"Start acquiring"</td>
      <td>DBF_LONG</td>
      <td>Writing 1 to this field will start data acquisition.</td>
    <tr valign="top">
      <td>STOP</td>
      <td>R/W*</td>
      <td>"Start acquiring"</td>
      <td>DBF_LONG</td>
      <td>Writing 1 to this field will stop data acquisition.</td>
    </tr>
    <tr valign="top">
      <td>ERAS</td>
      <td>R/W*</td>
      <td>"Erase data"</td>
      <td>DBF_LONG</td>
      <td>Writing 1 to this field will cause the module to erase existing data.</td>
    </tr>
    <tr valign="top">
      <td>ACQG</td>
      <td>R</td>
      <td>"Acquiring"</td>
      <td>DBF_LONG</td>
      <td>This field is 1 if the module is currently acquiring data, 0 if it is not acquiring.</td>
    </tr>
  </tbody>
</table>

<p>Note that if the MCA record is being used, then it is normally used to control
acquisition, rather than tha fields above.</p>

<p> </p>
<hr>

<h2 align="center"><a name="Task Control Fields">
                            Task Control Fields</a></h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>READ_PARAMS</td>
      <td>R/W*</td>
      <td>"Read parameters"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to read all of the high-level and
          low-level parameters from Handel and the hardware.  These parameters are also read
          automatically whenever one of the high-level or low-level parameters is modified.</td>
    </tr>
    <tr valign="top">
      <td>READ_HISTOGRAM</td>
      <td>R/W*</td>
      <td>"Read baseline histogram"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to read the baseline histogram
          and update the .BASE array field.</td>
    </tr>
    <tr valign="top">
      <td>READ_HISTORY</td>
      <td>R/W*</td>
      <td>"Read baseline history"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to read the baseline history
          and update the .BHIST array field.</td>
    </tr>
    <tr valign="top">
      <td>READ_TRACE</td>
      <td>R/W*</td>
      <td>"Read ADC trace"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to read the ADC trace
          and update the .TRACE array field.</td>
    </tr>
    <tr valign="top">
      <td>OPEN_RELAY</td>
      <td>R/W*</td>
      <td>"Open input relay"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to open the input relay,
          disconnecting the DXP module from the detector pre-amplifier.</td>
    </tr>
    <tr valign="top">
      <td>CLOSE_RELAY</td>
      <td>R/W*</td>
      <td>"Close input relay"</td>
      <td>DBF_LONG</td>
      <td>Writing a 1 to this field will cause the DXP record to close the input relay,
          connecting the DXP module to the detector pre-amplifier.  This is the normal
          state.</td>
    </tr>
  </tbody>
</table>

<p> </p>
<hr>

<h2 align="center"><a name="High-level Control and Readback Fields">
                            High-level Control and Readback Fields</a></h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>TRIG_PKTIM</td>
      <td>R/W*</td>
      <td>"Fast filter peaking time"</td>
      <td>DBF_DOUBLE</td>
      <td>The peaking time in microseconds for the fast filter.  The fast filter is used to
          detect input pulses, and determines the Input Count Rate (ICR).</td>
    </tr>
    <tr valign="top">
      <td>TRIG_PKTIM_RBV</td>
      <td>R</td>
      <td>"Fast filter peaking time readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual peaking time in microseconds for the fast filter, which may differ
          from the requested time because of the finite clock speed of the DXP.</td>
    </tr>
    <tr valign="top">
      <td>TRIG_GAPTIM</td>
      <td>R/W*</td>
      <td>"Fast filter gap time"</td>
      <td>DBF_DOUBLE</td>
      <td>The gap time in microseconds for the fast filter.</td>
    </tr>
    <tr valign="top">
      <td>TRIG_GAPTIM_RBV</td>
      <td>R</td>
      <td>"Fast filter gap time readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual gap time in microseconds for the fast filter, which may differ
          from the requested time because of the finite clock speed of the DXP.</td>
    </tr>
    <tr valign="top">
      <td>FAST_TRIG</td>
      <td>R/W*</td>
      <td>"Fast filter threshold"</td>
      <td>DBF_DOUBLE</td>
      <td>The threshold in keV for the fast filter.</td>
    </tr>
    <tr valign="top">
      <td>FAST_TRIG_RBV</td>
      <td>R</td>
      <td>"Fast filter threshold readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual threshold in keV for the fast filter, which may differ
          from the requested threshold.</td>
    </tr>
    <tr valign="top">
      <td>PKTIM</td>
      <td>R/W*</td>
      <td>"Slow filter peaking time"</td>
      <td>DBF_DOUBLE</td>
      <td>The peaking time in microseconds for the slow filter.  The slow filter is used to
          measure the energy of the input pulses. Increasing this time will generally
          improve the energy resolution at the expense of decreased output count rate (OCR).</td>
    </tr>
    <tr valign="top">
      <td>PKTIM_RBV</td>
      <td>R</td>
      <td>"Slow filter peaking time readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual peaking time in microseconds for the slow filter, which may differ
          from the requested time because of the finite clock speed of the DXP.</td>
    </tr>
    <tr valign="top">
      <td>GAPTIM</td>
      <td>R/W*</td>
      <td>"Slow filter gap time"</td>
      <td>DBF_DOUBLE</td>
      <td>The gap time in microseconds for the slow filter. This should be set to the maximum
          rise time of the input pulses.</td>
    </tr>
    <tr valign="top">
      <td>GAPTIM_RBV</td>
      <td>R</td>
      <td>"Slow filter gap time readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual gap time in microseconds for the slow filter, which may differ
          from the requested time because of the finite clock speed of the DXP.</td>
    </tr>
    <tr valign="top">
      <td>SLOW_TRIG</td>
      <td>R/W*</td>
      <td>"Slow filter threshold"</td>
      <td>DBF_DOUBLE</td>
      <td>The threshold in keV for the slow filter.  This should generally be set to 0. 
          except for soft x-ray spectroscopy.</td>
    </tr>
    <tr valign="top">
      <td>SLOW_TRIG_RBV</td>
      <td>R</td>
      <td>"Slow filter threshold readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual threshold in keV for the slow filter, which may differ
          from the requested threshold.</td>
    </tr>
    <tr valign="top">
      <td>MAXWIDTH</td>
      <td>R/W*</td>
      <td>"Maximum width"</td>
      <td>DBF_DOUBLE</td>
      <td>Maximim peak width for pileup inspection.  NOTE: On the xMAP the units are microseconds 
          but on the Saturn and DXP2X the units are currently integer device units.</td>
    </tr>
    <tr valign="top">
      <td>MAXWIDTH_RBV</td>
      <td>R</td>
      <td>"Maximum width readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual maximum width for pileup, which may differ
          from the requested value.</td>
    <tr valign="top">
      <td>PGAIN</td>
      <td>R/W*</td>
      <td>"Pre-amp gain"</td>
      <td>DBF_DOUBLE</td>
      <td>The gain of the detector pre-amp in mV/keV. </td>
    </tr>
    <tr valign="top">
      <td>PGAIN_RBV</td>
      <td>R</td>
      <td>"Pre-amp gain readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The readback value of the pre-amp gain in mV/keV.</td>
    </tr>
    <tr valign="top">
      <td>EMAX</td>
      <td>R/W*</td>
      <td>"Maximum energy (keV)"</td>
      <td>DBF_DOUBLE</td>
      <td>The energy of the last channel in the spectrum in keV.  Modifying this value causes Handel to
          change a number of low-level parameters, including BINFACT and the analog input gain.  If the
          actual energy of the last channel is not equal to this value, then one should
          edit the .ini file to modify the value of the pre-amp gain.</td>
    </tr>
    <tr valign="top">
      <td>EMAX_RBV</td>
      <td>R</td>
      <td>"Maximum energy readback (keV)"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual energy of the last channel in the spectrum in keV, as determined by Handel.  This will
          not be correct if the pre-amp gain in the .ini file is wrong.</td>
    </tr>
    <tr valign="top">
      <td>ECAL</td>
      <td>R/W*</td>
      <td>"Calibration energy (keV)"</td>
      <td>DBF_DOUBLE</td>
      <td>The "calibration energy".  This is the energy at which the ADC_RULE applies.  The default is 10 keV,
          and there is rarely any need to change this.</td>
    </tr>
    <tr valign="top">
      <td>ECAL_RBV</td>
      <td>R</td>
      <td>"Calibration energy readback (keV)"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual calibration energy .</td>
    </tr>
    <tr valign="top">
      <td>ADC_RULE</td>
      <td>R/W*</td>
      <td>"ADC rule at ECAL"</td>
      <td>DBF_DOUBLE</td>
      <td>The percent of the range of the input ADC that should be used for pulses whose energy
          is at the energy of the ECAL field, normally 10 keV.  The normal range is 5-10% for
          reset pre-amplifiers and 30-50% for RC pre-amplifiers.  The goal is to digitize the baseline
          noise into a few ADC bits (look at the ADC trace), but not have the value so large
          that the input signal drifts out of the ADC range (look at the number of drift ups and
          drift downs, NUMDRUPS0 and NUMDRDOS0).</td>
    </tr>
    <tr valign="top">
      <td>ADC_RULE_RBV</td>
      <td>R</td>
      <td>"ADC rule readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual ADC rule value.</td>
    </tr>
    <tr valign="top">
      <td>BASE_CUT_PCT</td>
      <td>R/W*</td>
      <td>"Baseline cut %"</td>
      <td>DBF_DOUBLE</td>
      <td>The baseline cut value, in percent units of the baseline histogram.  Baseline values 
          outside the cut range will not be used in computing the baseline average, but they will
          still be included in the baseline histogram.  The .T11V field can be used to enable or
          disable the baseline cut.</td>
    </tr>
    <tr valign="top">
      <td>BASE_CUT_PCT_RBV</td>
      <td>R</td>
      <td>"Baseline cut % readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual baseline cut value.</td>
    </tr>
    <tr valign="top">
      <td>BASE_CUT_ENBL</td>
      <td>R/W*</td>
      <td>"Enable baseline cut %"</td>
      <td>DBF_MENU</td>
      <td>A flag to enable or disable the baseline cut.</td>
    </tr>
    <tr valign="top">
      <td>BASE_CUT_ENBLE_RBV</td>
      <td>R</td>
      <td>"Baseline cut enable readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The actual baseline cut enable value.</td>
    </tr>
    <tr valign="top">
      <td>BASE_LEN</td>
      <td>R/W*</td>
      <td>"Baseline filter length"</td>
      <td>DBF_MENU</td>
      <td>The length of the baseline filter in samples.  Menu values are powers of 2 from
          2 to 65536.</td>
    </tr>
    <tr valign="top">
      <td>BASE_LEN_RBV</td>
      <td>R</td>
      <td>"Baseline filter length readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The baseline filter length readback.</td>
    </tr>
    <tr valign="top">
      <td>BASE_THRESH</td>
      <td>R/W*</td>
      <td>"Baseline filter threshold"</td>
      <td>DBF_DOUBLE</td>
      <td>The baseline filter threshold.  In this release the units of this parameter are keV on the xMAP
          and integer device units on the Saturn and DXP-2X.
          This is a new DXP parameter, and is not yet documented by XIA.  
          However, it has a major effect on spectra, and it is often
          necessary to increase this value from the initial value.  
          On the Saturn and DXP-2X the .T14V field can be used to
          enable or disable automatic modification of this parameter by the DXP firmware.</td>
    </tr>
    <tr valign="top">
      <td>BASE_THRESH_RBV</td>
      <td>R</td>
      <td>"Baseline threshold readback"</td>
      <td>DBF_DOUBLE</td>
      <td>The baseline threshold readback.</td>
    </tr>
    <tr valign="top">
      <td>TRACE_WAIT</td>
      <td>R/W*</td>
      <td>"Trace wait (usec)"</td>
      <td>DBF_DOUBLE</td>
      <td>The time per point to collect the ADC trace data.  Units are microseconds.</td>
    </tr>
    <tr valign="top">
      <td>BHIST_TIME</td>
      <td>R/W*</td>
      <td>"Baseline history time (usec)"</td>
      <td>DBF_DOUBLE</td>
      <td>The time per point to collect the baseline history data.  Units are microseconds.
          This parameter is only applicable to the xMAP hardware in the current release.  
          It is not possible to control the time per baseline history point on the Saturn and DXP-2X.</td>
    </tr>
  </tbody>
</table>

<p> </p>
<hr>

<h2 align="center"><a name="High-Level Run Statistics Fields">
                            High-Level Run Statistics Fields</a></h2>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>FAST_PEAKS</td>
      <td>R</td>
      <td>"Fast peaks (triggers)"</td>
      <td>DBF_LONG</td>
      <td>The number of fast peaks, i.e. peaks detected by the fast trigger filter.</td>
    </tr>
    <tr valign="top">
      <td>SLOW_PEAKS</td>
      <td>R</td>
      <td>"Slow peaks (counts)"</td>
      <td>DBF_LONG</td>
      <td>The number of slow peaks, i.e. peaks detected by the slow energy filter.</td>
    </tr>
    <tr valign="top">
      <td>ICR</td>
      <td>R</td>
      <td>"Input count rate"</td>
      <td>DBF_DOUBLE</td>
      <td>The input count rate, i.e. the number of fast peaks per second.</td>
    </tr>
    <tr valign="top">
      <td>OCR</td>
      <td>R</td>
      <td>"Output count rate"</td>
      <td>DBF_DOUBLE</td>
      <td>The output count rate, i.e. the number of slow peaks per second.</td>
    </tr>
  </tbody>
</table>

<p> </p>
<hr>

<h2 align="center"><a name="Single Channel Analyzer (SCA) Fields">
                            Single Channel Analyzer (SCA) Fields</a></h2>

<p> The DXP modules provide emulation of 16 single-channel analyzers.  These compute the total
counts in each of 16 SCAs.  The SCAs are defined by a low channel and a high channel.</p>

<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th width=15%>Name</th>
      <th>Access</th>
      <th>Prompt</th>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <td>NUM_SCAS</td>
      <td>R/W*</td>
      <td>"Number of SCAs"</td>
      <td>DBF_LONG</td>
      <td>The number of SCAs. NOTE: Due to limitations in Handel this currently has no effect,
          the number of SCAs defined is always 16.</td>
    </tr>
    <tr valign="top">
      <td>SCA(N)_LO</td>
      <td>R/W*</td>
      <td>"SCA N low channel"</td>
      <td>DBF_LONG</td>
      <td>The low channel for SCA N (N=1-16).  Actual field names are SCA0_LO, SCA1_LO, etc.
          Range is 0 to SCA(N)_HI.</td>
    </tr>
    <tr valign="top">
      <td>SCA(N)_LO_RBV</td>
      <td>R</td>
      <td>"SCA N low channel readback"</td>
      <td>DBF_LONG</td>
      <td>The actual low channel for SCA N (N=1-16).  Actual field names are SCA0_LO_RBV, 
          SCA1_LO_RBV, etc.</td>
    </tr>
    <tr valign="top">
      <td>SCA(N)_HI</td>
      <td>R/W*</td>
      <td>"SCA N high channel"</td>
      <td>DBF_LONG</td>
      <td>The high channel for SCA N (N=1-16).  Actual field names are SCA0_HI, SCA1_HI, etc.
          Range is SCA(N)_LO to maximum channels-1. 
          The record will set _HI to the value of _LO if _HI would otherwise be less
          than _LO.</td>
    </tr>
    <tr valign="top">
      <td>SCA(N)_HI_RBV</td>
      <td>R</td>
      <td>"SCA N high channel readback"</td>
      <td>DBF_LONG</td>
      <td>The actual high channel for SCA N (N=1-16).  Actual field names are SCA0_HI_RBV, 
          SCA1_HI_RBV, etc.</td>
    </tr>
    <tr valign="top">
      <td>SCA(N)_CTS</td>
      <td>R</td>
      <td>"SCA N counts"</td>
      <td>DBF_LONG</td>
      <td>The total counts in SCA N (N=1-16).  Actual field names are SCA0_CTS, 
          SCA1_CTS, etc. These counts are only computed by the DXP
          firmware when acquisition stops.</td>
    </tr>
  </tbody>
</table>


<p>
<hr>
<h2 align="center"><a name="Low-level Fields">
                            Low-level Fields</a></h2>

<p>The DXP record provides control and/or display of all low level parameters in the DXP, 
of which there are more than 80. Note that only expert users should modify these parameters directly.
Most users will only control the high-level parameters described above, and let Handel control the 
low-level parameters.  Note that on the xMAP many of these parameters do not exist, and their use
should be avoided.  It is expected that newer Handel releases for the Saturn and DXP2X will make
the use of low-level parameters unnecessary on those models as well.

<p>The low-level parameter control is provided in a flexible and extensible way, 
because the parameters are specific to
each firmware type and release.  For example, the parameters are different for different types 
of pre-amplifiers (RC versus reset).</p>

<p>The flexibility is provided in the following manner.  Each low level parameter is associated with 3 
fields in the DXP record:
<ul>
<li> A label field, for example A01L.  This is an EPICS DBF_STRING field.  It contains the firmware name
of the low-level parameter, for example, GAINDAC.  The contents of the label field are not hardcoded
into the record, but are rather loaded from the EPICS database when the IOC initializes.  This means
that a new firmware release from XIA does not require any changes to the code in the DXP record,
it just requires modification of the ASCII database file.</li>
<li> A value field, for example A01V.  For low-level parameters that can
be modified, this field is R/W*.  For low-level parameters that are read-only this field is R.</li>
<li> An offset field, for example A01O.  This field is for internal use by the record, and cannot be modified.
For the statistics fields, which are 32-bit integers, there are two offset fields, 
OL for the least significant 16 bits, and OH for the most significant 16 bits.
</ul>
<p> The naming convention for the low-level parameters is PrefixNumberSuffix, e.g. A01L.  As explained above
the suffix has the value L, V or O. 
The following table summarizes the low-level fields:
<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Prefix</th>
      <th>Description</th>
      <th>Number</th>
      <th>Access</th>
      <th>Data type</th>
    </tr>
    <tr valign="top">
      <td>A</td>
      <td>Analog signal conditioner (ASC) parameters</td>
      <td>01 to 09</td>
      <td>R/W*</td>
      <td>DBF_SHORT</td>
    </tr>
    <tr valign="top">
      <td>F</td>
      <td>FIPPI parameters</td>
      <td>01 to 10</td>
      <td>R/W*</td>
      <td>DBF_SHORT</td>
    </tr>
    <tr valign="top">
      <td>B</td>
      <td>Baseline parameters</td>
      <td>01 to 08</td>
      <td>R/W*</td>
      <td>DBF_SHORT</td>
    </tr>
    <tr valign="top">
      <td>D</td>
      <td>DSP parameters</td>
      <td>01 to 10</td>
      <td>R/W*</td>
      <td>DBF_SHORT</td>
    </tr>
    <tr valign="top">
      <td>T</td>
      <td>Run tasks parameters</td>
      <td>01 to 16</td>
      <td>R/W*</td>
      <td>DBF_ENUM.  These fields have the values 0 (No) or 1 (Yes).</td>
    </tr>
    <tr valign="top">
      <td>R</td>
      <td>Readout parameters</td>
      <td>01 to 16</td>
      <td>R</td>
      <td>DBF_SHORT</td>
    </tr>
    <tr valign="top">
      <td>S</td>
      <td>Statistics parameters</td>
      <td>01 to 14</td>
      <td>R</td>
      <td>DBF_LONG</td>
    </tr>
  </tbody>
</table>

<p>The following table lists the current low-level parameters associated with each
low-level DXP record field.  Differences between the RC and reset firmware are noted.  Every effort 
will be made to keep the same DXP record field name associated with the same firmware parameter name
in subsequent software and firmware releases.  This may not always be possible, particularly if existing 
firmware parameters are deleted or renamed.</p>
<table cellpadding="5" border="1">
  <tbody>
    <tr>
      <th>Field</th>
      <th>Firmware parameter</th>
      <th>Description</th>
    </tr>
    <tr valign="top">
      <th colspan=3> Analog Signal Conditioner (ASC) Fields</th>
    </tr>
    <tr valign="top">
      <td>A01</td>
      <td>GAINDAC</td>
      <td>Gain DAC for setting analog input gain.</td>
    </tr>
    <tr valign="top">
      <td>A02</td>
      <td>HIGHGAIN</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A03</td>
      <td>POLARITY</td>
      <td>Pre-amp polarity (not high-voltage polarity). Positive polarity means an x-ray pulse
          causes an increase in the pre-amp voltage output. 0=negative, 1=positive.</td>
    </tr>
    <tr valign="top">
      <td>A04</td>
      <td>INPUTENABLE</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A05</td>
      <td>RESETWAIT</td>
      <td>Time to wait after a reset before collecting data.</td>
    </tr>
    <tr valign="top">
      <td>A06</td>
      <td>RESETINT</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A07&nbsp;(reset)</td>
      <td>SGRANULAR</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A07 (RC)</td>
      <td>RCTAU</td>
      <td>Pre-amp time constant.</td>
    </tr>
    <tr valign="top">
      <td>A08 (reset)</td>
      <td>TRKDACVAL</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A08 (RC)</td>
      <td>RCTAUFRAC</td>
      <td>Fractional adjustment in RC when auto-tuning?</td>
    </tr>
    <tr valign="top">
      <td>A09 (reset)</td>
      <td>TDACWIDTH</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>A09 (RC)</td>
      <td>Unused</td>
      <td>Unused.</td>
    </tr>

    <tr valign="top">
      <th colspan=3> FIPPI Fields</th>
    </tr>
    <tr valign="top">
      <td>F01</td>
      <td>FASTLEN</td>
      <td>Length of the fast filter.</td>
    </tr>
    <tr valign="top">
      <td>F02</td>
      <td>FASTGAP</td>
      <td>Length of the fast filter gap.</td>
    </tr>
    <tr valign="top">
      <td>F03</td>
      <td>SLOWLEN</td>
      <td>Length of the slow filter.</td>
    </tr>
    <tr valign="top">
      <td>F04</td>
      <td>SLOWGAP</td>
      <td>Length of the slow filter gap.</td>
    </tr>
    <tr valign="top">
      <td>F05</td>
      <td>MAXWIDTH</td>
      <td>Maximum width of a valid pulse.</td>
    </tr>
    <tr valign="top">
      <td>F06</td>
      <td>MINWIDTH</td>
      <td>Minimum width of a valid pulse.</td>
    </tr>
    <tr valign="top">
      <td>F07</td>
      <td>PEAKINT</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>F08</td>
      <td>PEAKSAM</td>
      <td>Time to sample the peak height.</td>
    </tr>
    <tr valign="top">
      <td>F09</td>
      <td>THRESHOLD</td>
      <td>Fast filter threshold.</td>
    </tr>
    <tr valign="top">
      <td>F10</td>
      <td>SLOWTHRESH</td>
      <td>Slow filter threshold.</td>
    </tr>

    <tr valign="top">
      <th colspan=3> Baseline Fields</th>
    </tr>
    <tr valign="top">
      <td>B01</td>
      <td>BLFILTER</td>
      <td>Length of the baseline filter.</td>
    </tr>
    <tr valign="top">
      <td>B02</td>
      <td>BLFILTERF</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>B03</td>
      <td>BASEBINNING</td>
      <td>Binning factor when constructing baseline histogram.</td>
    </tr>
    <tr valign="top">
      <td>B04</td>
      <td>BLCUT</td>
      <td>Baseline cut for excluding outlier values from baseline average</td>
    </tr>
    <tr valign="top">
      <td>B05</td>
      <td>BLMIN</td>
      <td>Low channel computed by firmware from BLCUT.</td>
    </tr>
    <tr valign="top">
      <td>B06</td>
      <td>BLMAX</td>
      <td>High channel computed by firmware from BLCUT.</td>
    </tr>
    <tr valign="top">
      <td>B07</td>
      <td>BASETHRESH</td>
      <td>Baseline threshold value.  Not documented by XIA yet.</td>
    </tr>
    <tr valign="top">
      <td>B08</td>
      <td>BASTHRADJ</td>
      <td>Baseline threshold adjust value.  Not documented by XIA yet.</td>
    </tr>

    <tr valign="top">
      <th colspan=3> DSP Fields</th>
    </tr>
    <tr valign="top">
      <td>D01</td>
      <td>BINFACT1</td>
      <td>Binning factor when converting ADC units to MCA channel.</td>
    </tr>
    <tr valign="top">
      <td>D02</td>
      <td>MCALIML0</td>
      <td>First MCA channel to use.</td>
    </tr>
    <tr valign="top">
      <td>D03</td>
      <td>MCALIMHI</td>
      <td>Last MCA channel to use.</td>
    </tr>
    <tr valign="top">
      <td>D04</td>
      <td>TRACEWAIT</td>
      <td>Time per point for ADC trace.</td>
    </tr>
    <tr valign="top">
      <td>D05 (reset)</td>
      <td>Unused</td>
      <td>Unused.</td>
    </tr>
    <tr valign="top">
      <td>D05 (RC)</td>
      <td>ASCTIMEOUT</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>D06</td>
      <td>YELLOWTHR</td>
      <td>Count rate threshold for yellow light.</td>
    </tr>
    <tr valign="top">
      <td>D07</td>
      <td>REDTHR</td>
      <td>Count rate threshold for red light.</td>
    </tr>
    <tr valign="top">
      <td>D08</td>
      <td>PRESET</td>
      <td>Flag for what type of preset to use (none, live time, real time, or counts).</td>
    </tr>
    <tr valign="top">
      <td>D09</td>
      <td>WHICHTEST</td>
      <td>Special task number to be run by firmware.</td>
    </tr>
    <tr valign="top">
      <td>D10</td>
      <td>RUNTASKS</td>
      <td>Bit pattern of flags to tell firmware what options to use.  The T01-T16 fields
          provide access to the individual bits of this word.</td>
    </tr>

    <tr valign="top">
      <th colspan=3> Runtasks Fields</th>
    </tr>
    <tr valign="top">
      <td>T01</td>
      <td>RUNTASKS (bit 0)</td>
      <td>Unused.</td>
    </tr>
    <tr valign="top">
      <td>T02</td>
      <td>RUNTASKS (bit 1)</td>
      <td>Update slope.</td>
    </tr>
    <tr valign="top">
      <td>T03</td>
      <td>RUNTASKS (bit 2)</td>
      <td>Use finite impulse response (FIR) filter.  
          Default is infinite impulse response (IIR) filter.</td>
    </tr>
    <tr valign="top">
      <td>T04</td>
      <td>RUNTASKS (bit 3)</td>
      <td>Update baseline.  
    </tr>
    <tr valign="top">
      <td>T05</td>
      <td>RUNTASKS (bit 4)</td>
      <td>Automatically adjust fast threshold.  
    </tr>
    <tr valign="top">
      <td>T06</td>
      <td>RUNTASKS (bit 5)</td>
      <td>Correct for baseline.  
    </tr>
    <tr valign="top">
      <td>T07</td>
      <td>RUNTASKS (bit 6)</td>
      <td>Subtract slope from baseline.  
    </tr>
    <tr valign="top">
      <td>T08</td>
      <td>RUNTASKS (bit 7)</td>
      <td>Collect baseline history.  
    </tr>
    <tr valign="top">
      <td>T09</td>
      <td>RUNTASKS (bit 8)</td>
      <td>Special task or calibration task.  
    </tr>
    <tr valign="top">
      <td>T10</td>
      <td>RUNTASKS (bit 9)</td>
      <td>Histogram delta baseline.  
    </tr>
    <tr valign="top">
      <td>T11</td>
      <td>RUNTASKS&nbsp;(bit&nbsp;10)</td>
      <td>Enable baseline cut.  
    </tr>
    <tr valign="top">
      <td>T12</td>
      <td>RUNTASKS (bit 11)</td>
      <td>Special timing mode.  
    </tr>
    <tr valign="top">
      <td>T13</td>
      <td>RUNTASKS (bit 12)</td>
      <td>Skip filling.  
    </tr>
    <tr valign="top">
      <td>T14</td>
      <td>RUNTASKS (bit 13)</td>
      <td>Disable automatic baseline threshold adjust.  
    </tr>
    <tr valign="top">
      <td>T15</td>
      <td>RUNTASKS (bit 14)</td>
      <td>Unused.  
    </tr>
    <tr valign="top">
      <td>T16</td>
      <td>RUNTASKS (bit 15)</td>
      <td>Unused.  
    </tr>

    <tr valign="top">
      <th colspan=3> Readout Fields</th>
    </tr>
    <tr valign="top">
      <td>R01</td>
      <td>CODEREV</td>
      <td>Firmware revision.</td>
    </tr>
    <tr valign="top">
      <td>R02</td>
      <td>CODEVAR</td>
      <td>Firmware variant.</td>
    </tr>
    <tr valign="top">
      <td>R03</td>
      <td>RUNIDENT</td>
      <td>Run identification. This starts at zero when the IOC initializes, 
          and increments by 1 each time acquisition is started.</td>
    </tr>
    <tr valign="top">
      <td>R04</td>
      <td>RUNERROR</td>
      <td>Error number.</td>
    </tr>
    <tr valign="top">
      <td>R05</td>
      <td>ERRINFO</td>
      <td>Error information.</td>
    </tr>
    <tr valign="top">
      <td>R06</td>
      <td>HDWRVAR</td>
      <td>Hardware model.</td>
    </tr>
    <tr valign="top">
      <td>R07</td>
      <td>FIPPIREV</td>
      <td>FIPPI revision.</td>
    </tr>
    <tr valign="top">
      <td>R08</td>
      <td>FIPPIVAR</td>
      <td>FIPPI variant.</td>
    </tr>
    <tr valign="top">
      <td>R09</td>
      <td>DECIMATION</td>
      <td>Decimation value, i.e. subsampling factor for the input at longer peaking times.</td>
    </tr>
    <tr valign="top">
      <td>R10</td>
      <td>BUSY</td>
      <td>Busy flag, indicating if module is busy.</td>
    </tr>
    <tr valign="top">
      <td>R11 (reset)</td>
      <td>SLOPEDAC</td>
      <td>The ramp slope D/A converter value.</td>
    </tr>
    <tr valign="top">
      <td>R11 (RC)</td>
      <td>OFFSETDAC</td>
      <td>The offset D/A converter value.</td>
    </tr>
    <tr valign="top">
      <td>R12 (reset)</td>
      <td>SLOPEZERO</td>
      <td>The ramp slope D/A converter zero.</td>
    </tr>
    <tr valign="top">
      <td>R12 (RC)</td>
      <td>OFFDACZERO</td>
      <td>The offset D/A converter zero.</td>
    </tr>
    <tr valign="top">
      <td>R13 (reset)</td>
      <td>SLOPEVAL</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>R13 (RC)</td>
      <td>OFFSETVAL</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>R14 (reset)</td>
      <td>TDQPERADC</td>
      <td>The tracking DAC units per ADC unit.</td>
    </tr>
    <tr valign="top">
      <td>R14 (RC)</td>
      <td>Unused</td>
      <td>Unused.</td>
    </tr>
    <tr valign="top">
      <td>R15 (reset)</td>
      <td>TDQPERADCE</td>
      <td>See manual.</td>
    </tr>
    <tr valign="top">
      <td>R15 (RC)</td>
      <td>Unused</td>
      <td>Unused.</td>
    </tr>
    <tr valign="top">
      <td>R16</td>
      <td>SPECTLEN</td>
      <td>The total length of the MCA memory.</td>
    </tr>

    <tr valign="top">
      <th colspan=3> Statistics Fields</th>
    </tr>
    <tr valign="top">
      <td>S01</td>
      <td>EVTSINRUN0</td>
      <td>Number of events in run.  
          These are pulses that were accumulated in the MCA spectrum.</td>
    </tr>
    <tr valign="top">
      <td>S02</td>
      <td>UNDRFLOWS0</td>
      <td>Number of underflows.  
          These are pulses that would have been in an MCA channel less than MCALIMLO.</td>
    </tr>
    <tr valign="top">
      <td>S03</td>
      <td>OVERFLOWS0</td>
      <td>Number of overflows.  
          These are pulses that would have been in an MCA channel greater than MCALIMHI.</td>
    </tr>
    <tr valign="top">
      <td>S04</td>
      <td>FASTPEAKS0</td>
      <td>Number of fast peaks.  
          These are pulses counted by the fast (trigger) filter.</td>
    </tr>
    <tr valign="top">
      <td>S05</td>
      <td>BASEEVTS0</td>
      <td>Number of baseline events.</td>
    </tr>
    <tr valign="top">
      <td>S06</td>
      <td>BASEMEAN0</td>
      <td>Mean value of the baseline.</td>
    </tr>
    <tr valign="top">
      <td>S07</td>
      <td>LIVETIME0</td>
      <td>Number of livetime clock ticks.</td>
    </tr>
    <tr valign="top">
      <td>S08</td>
      <td>REALTIME0</td>
      <td>Number of realtime clock ticks.</td>
    </tr>
    <tr valign="top">
      <td>S09</td>
      <td>NUMASCINT0</td>
      <td>Number of ASC interrupts.  This is the number of times that the ASC had to interrupt
          the DSP, typically because the input signal is out of the range of the ADC.</td>
    </tr>
    <tr valign="top">
      <td>S10</td>
      <td>NUMRESETS0</td>
      <td>Number of pre-amp resets.</td>
    </tr>
    <tr valign="top">
      <td>S11</td>
      <td>NUMDRDOS0</td>
      <td>Number of drift downs.  This is the number of times that the input signal 
          drifted below the range of the ADC.</td>
    </tr>
    <tr valign="top">
      <td>S12</td>
      <td>NUMDRUPS0</td>
      <td>Number of drift ups.  This is the number of times that the input signal 
          drifted above the range of the ADC.</td>
    </tr>
    <tr valign="top">
      <td>S13</td>
      <td>NUMUPSETS0</td>
      <td>Number of upsets.</td>
    </tr>
    <tr valign="top">
      <td>S14</td>
      <td>NUMZIGZAG0</td>
      <td>Number of zig-zags.  This is the number of times that the input signal drifted above
          and below the range of the ADC.</td>
    </tr>

  </tbody>
</table>

<p> </p>
<hr>
<h2 align="center"><a name="Record Processing">
                            Record Processing</a></h2>

<p>Because the DXP record can perform so many different tasks, and because
it is designed for high performance, it behaves differently from typical
simple EPICS records like ai and ao.  Processing the record does not actually
do anything unless one has written to one of the fields in the record that has 
the Process Passive attribute.  For example, writing a 1 to the .READ_HISTOGRAM
field will cause the record to process, and to read the baseline histogram
array from the hardware.  Similarly, to read the DXP parameters write a 1 to the
.READ_PARAMS field, and to read the ADC trace, write a 1 to the .READ_TRACE field.
Writing to any high-level parameter such as the peaking time (.PKTIM), or to any
low-level parameter (e.g. .A01V) will cause the record to read back all of the 
parameters, as if the .READ_PARAMS field had been set to 1.  The .VAL field
of the DXP record exists, but it is not used.</p>

<p> </p>
<hr>
<h2 align="center"><a name="Debugging">
                            Debugging</a></h2>

<p>There are 3 types of debugging messages that can be enabled for the DXP software:
<ol>

<li>Record level debugging.  To print out debugging messages from the dxpRecord code
type the following at the IOC prompt.  On Windows or Linux:
<pre>
var dxpRecordDebug 10
</pre>
On vxWorks
<pre>
dxpRecordDebug=10
</pre>
</li>

<li>EPICS device support and driver level debugging.  To turn on these messages
type the following at the IOC prompt (assuming your DXP asyn server is called DXP1):
<pre>
asynSetTraceMask("DXP1",0,255)
asynSetTraceIOMask("DXP1",0,2)
</pre>
The second parameter in these commands is the asyn "address" which is the channel number
in the system.  For a system with 16 dxp records on port DXP1 the parameter must be in
the range 0-15.
</li>

<li>Handel debugging.  To turn on informational messages from the XIA Handel and 
Xerxes software type the following command at the IOC prompt:
<pre>
xiaSetLogLevel(3)
</pre>
The logging level can be set to 1=error, 2=warning, 3=information, 4=debug.
</li>
</ol>


<p> </p>
<hr>
<h2 align="center"><a name="Implementation Details">
                            Implementation Details</a></h2>

<p>The DXP record has associated device support.  This device support is closely coupled
to the record and is intended to support all DXP models. It is not expected that there
will be a need for additional device support.</p>

<p>The EPICS software communicates with the XIA Handel software through an
<a href="http://www.aps.anl.gov/epics/modules/soft/asyn/"target="_blank">asyn server</a>.
This server provides
a single thread that is used for all calls to the Handel library.  For the MCA record the
server implements standard asyn interfaces like asynInt32,
asynInt32Array, and asynFloat64.  The server makes calls to Handel in these interface 
methods.</p>

<p>The DXP device support uses the asyn server by connecting to it, and queuing asyn 
requests via that server.  However, the DXP device support callback does not use the
asyn interfaces provided by the asyn server.  Rather, the callback routine directly calls
the Handel functions.  This is perfectly OK to do, and is much simpler than trying to provide
interfaces in the asyn server for all of the functions that the device support needs.  By 
using a single asyn server (single thread) for both the MCA and DXP records it is 
guaranteed that they will not conflict.  There is also an EPICS mutex that is used to
protect all calls to the Handel library.  This is necessary even with the single
asyn server thread because the init_record routine makes some Handel calls directly, and
this can conflict with the asyn server thread that is already running when init_record is still
being called.</p>

<p>The DXP and MCA records communicate only through the Handel API, they do not call any
Xerxes functions directly.  Handel calls Xerxes, which in turn calls the machine-dependent
functions, which are specific to a particular operating system and hardware model.  For the 
Saturn on Windows the DXP software uses the standard XIA machine dependent support.  For 
Linux and vxWorks there is a new md_epics.c file that implements the low-level drivers for
the parallel port (Linux) and CAMAC (vxWorks).<p>

<p>Information on how to install, configure and run the EPICS DXP software is given in the 
general
<a href="dxpDoc.html"target="_blank">EPICS DXP documentation</a>.


<p> </p>
<hr>
<h2 align="center"><a name="Future Plans">
                            Future Plans</a></h2>

<p>The following are some future plans for the DXP record:
<ul>
<li>Implement multi-threading for multi-element detectors.  Although Handel is not thread-safe,
the EPICS mutex described above allows multiple threads (e.g. one thread per detector element) to call 
Handel. 
When one thread is done reading a spectrum, for
example, it can be computing ROIs while the next thread is doing a DMA read 
of its hardware via Handel.  It is not clear if this would result in a significant performance
improvement.</li>

<li>Implement the on-the-fly MCA scanning mode with the mapping version of the xMAP firmware.</li>

<li>Implement the on-the-fly SCA scanning mode with the timing versions of the xMAP, Saturn and
DXP2X firmware.</li>

<li>Implement the list mode readout of the new DXP-XMAP PXI hardware when it is released.</li>
</ul>

<p> </p>
<hr>
<h2 align="center"><a name="Graphical Displays">
                            Graphical Displays</a></h2>

<p>The following are screen shots of the medm screens provided for the DXP application
on a single-element detector, such as the Saturn.  These screens display and control 
EPICS process variables that are provided in the files dxp.db and mca.db.  
These include records other than just the DXP record itself.</p>

<p> </p>
<hr>
<h3 align="center">single_dxp_top.adl</h3>
<p>Main control screen for single-element detector.</p>
<p align="center"><img border="0" src="single_dxp_top.png"</p>

<p> </p>
<hr>
<h3 align="center">dxp.adl</h3>
<p>Complete screen for low-level DXP parameters and control.</p>
<p align="center"><img border="0" src="dxp.png"</p>

<p> </p>
<hr>
<h3 align="center">dxp_sca.adl</h3>
<p>Screen for SCA display and control.</p>
<p align="center"><img border="0" src="dxp_sca.png"</p>

<p> </p>
<hr>
<h3 align="center">mca.adl</h3>
<p>Screen to display the spectral data and control acquisition.  
Note that this screen is provided in the EPICS MCA application, 
not in the DXP application.</p>
<p align="center"><img border="0" src="mca.png"</p>

<p> </p>
<hr>
<h3 align="center">dxp_baseline.adl</h3>
<p>Screen to display the baseline histogram and control its update rate.</p>
<p align="center"><img border="0" src="dxp_baseline.png"</p>

<p> </p>
<hr>
<h3 align="center">dxp_baseline_history.adl</h3>
<p>Screen to display the baseline history and control its update rate.</p>
<p align="center"><img border="0" src="dxp_baseline_history.png"</p>

<p> </p>
<hr>
<h3 align="center">dxp_trace.adl</h3>
<p>Screen to display the ADC trace, and control the time per point and update rate.</p>
<p align="center"><img border="0" src="dxp_trace.png"</p>


<hr>

<address>
  Suggestions and comments to: <a href="mailto:rivers@cars.uchicago.edu">Mark
  Rivers </a>: (rivers@cars.uchicago.edu) <br>
  Last modified: September 19, 2006
</address>
</body>
</html>
