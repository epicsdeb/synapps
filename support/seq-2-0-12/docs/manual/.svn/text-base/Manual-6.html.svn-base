<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="Manual.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 Chapter 5:  State Notation Language Syntax
</TITLE>

</HEAD>
<BODY BGCOLOR="#ffffff">
<H1 CLASS="LOCALTITLE">
<A NAME="pgfId-691616"></A>State Notation Language Syntax</H1>
<P CLASS="BODY">
<A NAME="pgfId-700301"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700317"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700318"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700319"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700417"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-692225"></A>This chapter formalizes the state notation language syntax using a variant of BNF (Backus-Naur Form).</P>
<P CLASS="BODY">
<A NAME="pgfId-700363"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700381"></A>&nbsp;</P>
<P CLASS="BODY">
<A NAME="pgfId-700382"></A>&nbsp;</P>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-700400"></A><A NAME="85605"></A>Typographical conventions<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<P CLASS="BODY">
<A NAME="pgfId-700453"></A>The idea is that the meaning will be clear without explanation. However, here are some explanatory notes.</P>
<UL>
<LI CLASS="LISTBULLET1">
<A NAME="pgfId-692226"></A>words and symbols in <EM CLASS="Code">
teletype</EM>
 font are to be taken literally (&quot;terminals&quot;)</LI>
<LI CLASS="LISTBULLET1">
<A NAME="pgfId-692227"></A>words in <EM CLASS="Identfier">
bold italics</EM>
 are syntactic terms which will be defined below (&quot;nonterminals&quot;), except in a few cases where the meaning is obvious</LI>
<LI CLASS="LISTBULLET1">
<A NAME="pgfId-692228"></A>where the name of a nonterminal is enclosed in square brackets, that term is optional</LI>
<LI CLASS="LISTBULLET1">
<A NAME="pgfId-692229"></A>where a term is followed by an ellipsis (<EM CLASS="Identfier">
...</EM>
), it may optionally be repeated (so if the term was not optional this means that there can be one or more instances of it; if the term was optional this means that there can be zero or more instances of it)</LI>
<LI CLASS="LISTBULLET1">
<A NAME="pgfId-692230"></A>where a term is followed by a separator (<EM CLASS="Emphasis">
e.g. </EM>
a comma) and an ellipsis, it is to be understood that the separator will separate each repeated instance of the term</LI>
</UL>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-692231"></A><A NAME="58601"></A>State Program<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704644"></A><EM CLASS="Identfier">
program</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692232"></A>program <EM CLASS="Identfier">
program_name </EM>
<EM CLASS="Key-word">
[</EM>
(&quot;<EM CLASS="Identfier">
parameter_list</EM>
&quot;)<EM CLASS="Key-word">
]</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-702856"></A><EM CLASS="Identfier">
[entry_handler]</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692234"></A><EM CLASS="Identfier">
definition...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692235"></A><EM CLASS="Identfier">
state_set...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-702889"></A><EM CLASS="Identfier">
[exit_handler]</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703223"></A><EM CLASS="Identfier">
program_name</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-703391"></A>The name of the program. This is used as the name of the global variable which contains or points to all the state program data structures (the address of this global variable is passed to the <EM CLASS="Key-word">
seq</EM>
<A NAME="marker-703527"></A> function when creating the run-time sequencer). It is also used as the base for the state set thread names unless overridden via the <EM CLASS="Key-word">
name</EM>
<A NAME="marker-703554"></A> parameter (<A HREF="Manual-5.html#92625" CLASS="XRef">See Specifying Run-Time Parameters</A>).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703361"></A><EM CLASS="Identfier">
parameter_list</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-703642"></A>A list of comma-separated parameters in the same form as they are specified on the command line (<A HREF="Manual-5.html#92625" CLASS="XRef">See Specifying Run-Time Parameters</A>). Command-line parameters override those specified here.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703875"></A><EM CLASS="Identfier">
definition</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-703880"></A>See <A HREF="Manual-6.html#48649" CLASS="XRef">See Definitions</A>.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703646"></A><EM CLASS="Identfier">
entry_handler</EM>
<A NAME="marker-703737"></A><A NAME="55038"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-703659"></A>A state program may specify entry code to run prior to state set thread creation. This is run in the context of the first state set thread, before the other threads are created and is specified as follows:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703818"></A>entry {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703819"></A>	<EM CLASS="Identfier">
[statement]...</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703820"></A>}</P>
<P CLASS="BODY">
<A NAME="pgfId-703831"></A>The entry code consists of zero or more statements as described in <A HREF="Manual-6.html#87145" CLASS="XRef">See Statements and Expressions</A>. However, no control system variable access functions may be called within the entry code.</P>
<P CLASS="BODY">
<A NAME="pgfId-703832"></A>This handler should not be confused with the entry block of a state, which has the same syntax, but is executed at each transition to a new state.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703887"></A><EM CLASS="Identfier">
state_set</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-703899"></A>See <A HREF="Manual-6.html#62956" CLASS="XRef">See State Sets</A>.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703669"></A><EM CLASS="Identfier">
exit_handler</EM>
<A NAME="marker-703736"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-703712"></A>When a state program is stopped via <EM CLASS="Key-word">
seqStop</EM>
<A NAME="marker-703740"></A>, all state set threads within the state program are deleted. The state program may specify exit code to run prior to thread deletion. This is run in the context of the first state set thread and is specified as follows:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703713"></A>exit {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703758"></A>	<EM CLASS="Identfier">
[statement]...</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-703776"></A>}</P>
<P CLASS="BODY">
<A NAME="pgfId-703714"></A>The exit code consists of zero or more statements as described in <A HREF="Manual-6.html#87145" CLASS="XRef">See Statements and Expressions</A>. However, no control system variable access functions may be called within the exit code.</P>
<P CLASS="BODY">
<A NAME="pgfId-703715"></A>This handler should not be confused with the exit block of a state, which has the same syntax, but is executed at each transition from a state to the next state.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-703647"></A><A NAME="48649"></A>Definitions<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704670"></A><EM CLASS="Identfier">
definition</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692239"></A><EM CLASS="Identfier">
definition</EM>
 =			<EM CLASS="Identfier">
decl_stmt | assign_stmt | monitor_stmt | sync_stmt | syncq_stmt |</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704491"></A><EM CLASS="Identfier">
			compiler_option_stmt</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-703957"></A><EM CLASS="Identfier">
decl_stmt</EM>
<A NAME="marker-703998"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-703934"></A>Variable declarations are similar to C except that the types are limited to the following, only scalar initialization is permitted, and only one variable may be declared per declaration statement.</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692240"></A>char		<EM CLASS="Identfier">
	variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692241"></A>short	<EM CLASS="Identfier">
		variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692242"></A>int	<EM CLASS="Identfier">
		variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692243"></A>long	<EM CLASS="Identfier">
		variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692244"></A>float	<EM CLASS="Identfier">
		variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692245"></A>double			<EM CLASS="Identfier">
variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692246"></A>string			<EM CLASS="Identfier">
variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704254"></A>evflag			<EM CLASS="Identfier">
event_flag_name</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-692247"></A>Type <EM CLASS="Key-word">
string</EM>
 produces an array of char with length equal to the constant <EM CLASS="Key-word">
MAX_STRING_SIZE</EM>
, which is defined (as 40) in one of the included header files. Unsigned types and pointer types may also be specified. For example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692248"></A>unsigned short					*<EM CLASS="Identfier">
variable_name</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-692249"></A>Variables may also be declared as arrays.</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692250"></A>char			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692251"></A>short	<EM CLASS="Identfier">
		variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692252"></A>int			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692253"></A>long			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692254"></A>float			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692255"></A>double			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692256"></A>char			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692257"></A>short			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692258"></A>int	<EM CLASS="Identfier">
		variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692259"></A>long			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692260"></A>float			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692261"></A>double			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
array_length</EM>
][<EM CLASS="Identfier">
array_length</EM>
];</P>
<P CLASS="BODY">
<A NAME="pgfId-692263"></A>Note that arrays of strings and event flags are not implemented.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692265"></A><EM CLASS="Identfier">
assign_stmt</EM>
<A NAME="marker-704226"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-704118"></A>Once a variable is declared, it may be assigned to a control system variable. Thereafter, that variable is used to interact with the underlying control system. The following are all variations on assignment (note that the &quot;<EM CLASS="Key-word">
to</EM>
&quot; is optional):</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692266"></A>assign			<EM CLASS="Identfier">
variable_name</EM>
 <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 &quot;<EM CLASS="Identfier">
variable_name</EM>
<EM CLASS="Emphasis">
&quot;</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692267"></A>assign			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
index</EM>
] <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 &quot;<EM CLASS="Identfier">
variable_name</EM>
<EM CLASS="Emphasis">
&quot;</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692268"></A>assign			<EM CLASS="Identfier">
variable_name</EM>
 <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 { &quot;<EM CLASS="Identfier">
variable_name</EM>
<EM CLASS="Emphasis">
&quot;, </EM>
<EM CLASS="Identfier">
...</EM>
<EM CLASS="Emphasis">
 }</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-692269"></A>A control system variable name may contain one or more macro names enclosed in braces, as in &quot;<EM CLASS="Key-word">
{sys}{sub}voltage</EM>
&quot;. Macros are named following the same rules as C language variables.</P>
<P CLASS="BODY">
<A NAME="pgfId-692270"></A>For control system variables declared as arrays, the requested count is the length of the array or the native count for the underlying variable, whichever is smaller. The native count is determined when the initial connection is established. Pointer types may not be assigned to control system variables.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692271"></A><EM CLASS="Identfier">
monitor_stmt</EM>
<A NAME="marker-704403"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-692272"></A>To make the state program event-driven, input variables can be monitored. Monitored variables are automatically updated with the current value of the underlying control system variable (the variable must first be assigned to a control system variable).</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692273"></A>monitor				<EM CLASS="Identfier">
variable_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692274"></A>monitor				<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
index</EM>
];</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692278"></A><EM CLASS="Identfier">
sync_stmt</EM>
<A NAME="marker-704404"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-692279"></A><A NAME="marker-707734"></A>An event flag can be associated with an SNL variable (which may be an array, and thus associated with several control system variables). When a monitor is posted on any of the associated control system variables, the corresponding event flag is set (even if it was already set). Note that the &quot;<EM CLASS="Key-word">
to</EM>
&quot; is optional.</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704534"></A>sync			<EM CLASS="Identfier">
variable_name</EM>
 <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 <EM CLASS="Identfier">
event_flag_name</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704543"></A>sync			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
index</EM>
] <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 <EM CLASS="Identfier">
event_flag_name</EM>
;</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692281"></A><EM CLASS="Identfier">
syncq_stmt</EM>
<A NAME="marker-704405"></A><A NAME="92761"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-692282"></A><A NAME="marker-707735"></A>An event flag can be associated with a monitor queue which, in turn, is associated with an SNL variable (which may be an array, and thus associated with several control system variables). The queue size defaults to 100 but can be overridden on a per-queue basis. When a monitor is posted on any of the associated control system variables, the variable's value is written to the end of the queue and the corresponding event flag is set. If the queue is already full, the last entry is overwritten. Only scalar items can be accommodated in the queue (if the variable is array-valued, only the first item will be saved). The <EM CLASS="Key-word">
pvGetQ</EM>
<A NAME="marker-704402"></A> function reads items from the queue.</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704558"></A>syncQ			<EM CLASS="Identfier">
variable_name</EM>
 <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 <EM CLASS="Identfier">
event_flag_name</EM>
 <EM CLASS="Identfier">
[queue_size]</EM>
;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704560"></A>syncQ			<EM CLASS="Identfier">
variable_name</EM>
[<EM CLASS="Identfier">
index</EM>
] <EM CLASS="Key-word">
[</EM>
to<EM CLASS="Key-word">
]</EM>
 <EM CLASS="Identfier">
event_flag_name</EM>
 <EM CLASS="Identfier">
[queue_size]</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-704578"></A>Note that the square brackets around &quot;<EM CLASS="Key-word">
to</EM>
&quot; and <EM CLASS="Identfier">
queue_size</EM>
 indicate optional items rather than literal square brackets.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692284"></A><EM CLASS="Identfier">
compiler_option_stmt</EM>
<A NAME="marker-704454"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-692285"></A>A compiler option is specified as follows:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692286"></A>option			<EM CLASS="Identfier">
compiler_option_name</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-692289"></A>Possible compiler options are given in <A HREF="Manual-4.html#19975" CLASS="XRef">See Compiler Options</A>, and must include the &quot;<EM CLASS="Key-word">
+</EM>
&quot; or &quot;<EM CLASS="Key-word">
-</EM>
&quot; sign. Example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692291"></A>option			+<A NAME="marker-704726"></A>r;		/* make code reentrant */</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-704508"></A><A NAME="62956"></A>State Sets<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704685"></A><EM CLASS="Identfier">
state_set</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-704509"></A>ss <EM CLASS="Identfier">
state_set_name</EM>
 {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704593"></A><EM CLASS="Identfier">
	state_def...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704603"></A>}</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704743"></A><EM CLASS="Identfier">
state_set_name</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-704766"></A>The name of the state set. The normal C variable naming rules apply.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704701"></A><EM CLASS="Identfier">
state_def</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-704510"></A>state <EM CLASS="Identfier">
state_name</EM>
 {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704621"></A>	<EM CLASS="Identfier">
[state_option_stmt]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705085"></A><EM CLASS="Identfier">
	[entry_action]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705090"></A><EM CLASS="Identfier">
	event_action...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705092"></A><EM CLASS="Identfier">
	[exit_action]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-704632"></A>}</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704718"></A><EM CLASS="Identfier">
state_name</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-704774"></A>The name of the state. The normal C variable naming rules apply. State names need only be unique within the state set (<EM CLASS="Emphasis">
e.g. </EM>
each state set within a state program could have a <EM CLASS="Key-word">
start</EM>
 state).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-704769"></A><EM CLASS="Identfier">
state_option_stmt</EM>
<A NAME="29671"></A></H4>
<P CLASS="BODY">
<A NAME="pgfId-704734"></A>A state option is specified as follows:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692297"></A>option <EM CLASS="Identfier">
state_option_name</EM>
;</P>
<P CLASS="BODY">
<A NAME="pgfId-705040"></A>Currently there are three allowable options, <EM CLASS="Key-word">
t</EM>
<A NAME="marker-705081"></A>, <EM CLASS="Key-word">
e</EM>
<A NAME="marker-705082"></A> and <EM CLASS="Key-word">
x</EM>
<A NAME="marker-705083"></A>. The option string must be preceded by a &quot;<EM CLASS="Key-word">
+</EM>
&quot; or &quot;<EM CLASS="Key-word">
-</EM>
&quot;, for instance <EM CLASS="Key-word">
option -te</EM>
.</P>
<P CLASS="BODY">
<A NAME="pgfId-705041"></A>The options are:</P>
<P CLASS="OPTION">
<A NAME="pgfId-705042"></A><EM CLASS="Key-word">
-t</EM>
	Don't reset the time specifying when the state was entered if coming from the same state. When this option is used the <EM CLASS="Key-word">
delay</EM>
<A NAME="marker-706587"></A> function will return whether the given time delay has elapsed from the moment the current state was entered from a different state, rather than from when it was entered for the current iteration.</P>
<P CLASS="OPTION">
<A NAME="pgfId-705043"></A><EM CLASS="Key-word">
-e</EM>
	Execute <EM CLASS="Key-word">
entry</EM>
<A NAME="marker-706588"></A> blocks even if the previous state was the same as the current state.</P>
<P CLASS="OPTION">
<A NAME="pgfId-705044"></A><EM CLASS="Key-word">
-x</EM>
 	Execute <EM CLASS="Key-word">
exit</EM>
<A NAME="marker-706589"></A> blocks even if the next state is the same as the current state.</P>
<P CLASS="BODY">
<A NAME="pgfId-705045"></A><EM CLASS="Key-word">
+t</EM>
, <EM CLASS="Key-word">
+e</EM>
 and <EM CLASS="Key-word">
+x</EM>
 are also permitted, though &quot;<EM CLASS="Key-word">
+</EM>
&quot; is interpreted as &quot;perform the default action for this option&quot;. For instance <EM CLASS="Key-word">
option +tx</EM>
 would have the same effect as if no option specification were given for <EM CLASS="Key-word">
t</EM>
 and <EM CLASS="Key-word">
x</EM>
, so its use is only documentary. Note that more than one option line is allowed, and that syntax must be used to specify both &quot;<EM CLASS="Key-word">
+</EM>
&quot; and &quot;<EM CLASS="Key-word">
-</EM>
&quot; options, for example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705046"></A>state low {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705048"></A>	option -e;  /* Do entry{} every time ... */</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705049"></A>	option +x;  /* but only do exit{} when really leaving */</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705050"></A>	entry { <EM CLASS="Identfier">
...</EM>
 }</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705051"></A><EM CLASS="Identfier">
	...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705052"></A>	exit { <EM CLASS="Identfier">
...</EM>
 }</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705053"></A>}</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692303"></A><EM CLASS="Identfier">
entry_action</EM>
<A NAME="60053"></A></H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692304"></A>entry {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705229"></A><EM CLASS="Identfier">
	[statement]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705234"></A>}</P>
<P CLASS="BODY">
<A NAME="pgfId-705273"></A><EM CLASS="Key-word">
entry</EM>
<A NAME="marker-706602"></A> blocks are executed when the state is entered. There can be more than one of them.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692305"></A><EM CLASS="Identfier">
event_action</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692306"></A>when ( <EM CLASS="Identfier">
expression</EM>
 ) {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705348"></A><EM CLASS="Identfier">
	[statement]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705349"></A>} state <EM CLASS="Identfier">
new_state</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-705355"></A><EM CLASS="Identfier">
new_state</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-705390"></A>The name of the new state to enter. This can be the current state.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692307"></A><EM CLASS="Identfier">
exit_action</EM>
<A NAME="56851"></A></H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692308"></A>exit {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705353"></A><EM CLASS="Identfier">
	[statement]...</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705354"></A>}</P>
<P CLASS="BODY">
<A NAME="pgfId-692309"></A><EM CLASS="Key-word">
exit</EM>
<A NAME="marker-706603"></A> blocks are executed when the state is left. See the options <EM CLASS="Key-word">
-e</EM>
<A NAME="marker-705403"></A> and <EM CLASS="Key-word">
-x</EM>
<A NAME="marker-705404"></A> above for more details about controlling this behavior. Note that the statements in all entry blocks of a state are executed before any of the expressions in <EM CLASS="Key-word">
when</EM>
<A NAME="marker-705405"></A> conditions are evaluated.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-692325"></A><A NAME="87145"></A>Statements and Expressions<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-705406"></A><EM CLASS="Identfier">
statement</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692326"></A>{ <EM CLASS="Identfier">
[statement]...</EM>
 }<EM CLASS="Identfier">
														|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705606"></A><EM CLASS="Identfier">
expression</EM>
;			<EM CLASS="Identfier">
										|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705641"></A>if ( <EM CLASS="Identfier">
expression</EM>
 ) <EM CLASS="Identfier">
statement</EM>
											<EM CLASS="Identfier">
	|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705552"></A>else <EM CLASS="Identfier">
statement</EM>
											<EM CLASS="Identfier">
	|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705561"></A>while ( <EM CLASS="Identfier">
expression</EM>
 ) <EM CLASS="Identfier">
statement</EM>
											<EM CLASS="Identfier">
	|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705570"></A>for ( <EM CLASS="Identfier">
expression</EM>
; <EM CLASS="Identfier">
expression</EM>
; <EM CLASS="Identfier">
expression</EM>
 ) <EM CLASS="Identfier">
statement</EM>
 <EM CLASS="Identfier">
|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705579"></A>break;</P>
<P CLASS="BODY">
<A NAME="pgfId-705428"></A>As can be seen, most C statements are supported. Strangely, some are missing (but are not hard to add should the need arise).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-705719"></A><EM CLASS="Identfier">
expression</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-705844"></A><EM CLASS="Identfier">
expression </EM>
, <EM CLASS="Identfier">
expression...												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705861"></A><EM CLASS="Identfier">
expression binop expression												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705882"></A><EM CLASS="Identfier">
expression asgnop expression												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705903"></A><EM CLASS="Identfier">
unop expression												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706041"></A>++ <EM CLASS="Identfier">
expression												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706042"></A>-- <EM CLASS="Identfier">
expression												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706043"></A><EM CLASS="Identfier">
expression</EM>
 ++											<EM CLASS="Identfier">
	|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705934"></A><EM CLASS="Identfier">
expression</EM>
 --										<EM CLASS="Identfier">
		|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705947"></A><EM CLASS="Identfier">
number												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705960"></A><EM CLASS="Identfier">
char_const												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705970"></A><EM CLASS="Identfier">
string												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705971"></A><EM CLASS="Identfier">
name												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705972"></A><EM CLASS="Identfier">
name</EM>
 ( <EM CLASS="Identfier">
expression</EM>
 )<EM CLASS="Identfier">
												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705983"></A><EM CLASS="Identfier">
expression</EM>
 [ <EM CLASS="Identfier">
expression</EM>
 ]<EM CLASS="Identfier">
												|</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-705978"></A>( <EM CLASS="Identfier">
expression</EM>
 )</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-705988"></A><EM CLASS="Identfier">
binop</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-706004"></A>-<EM CLASS="Identfier">
 | </EM>
+<EM CLASS="Identfier">
 | </EM>
*<EM CLASS="Identfier">
 | </EM>
/<EM CLASS="Identfier">
 | </EM>
&gt;<EM CLASS="Identfier">
 | </EM>
&gt;=<EM CLASS="Identfier">
 | </EM>
==<EM CLASS="Identfier">
 | </EM>
!=<EM CLASS="Identfier">
 | </EM>
&lt;=<EM CLASS="Identfier">
 | </EM>
&lt;<EM CLASS="Identfier">
 | </EM>
||<EM CLASS="Identfier">
 | </EM>
&amp;&amp;<EM CLASS="Identfier">
 | </EM>
&lt;&lt;<EM CLASS="Identfier">
 | </EM>
&gt;&gt;<EM CLASS="Identfier">
 | </EM>
|<EM CLASS="Identfier">
 | </EM>
^<EM CLASS="Identfier">
 | </EM>
&amp;<EM CLASS="Identfier">
 | </EM>
%<EM CLASS="Identfier">
 | </EM>
?<EM CLASS="Identfier">
 | </EM>
:<EM CLASS="Identfier">
 | </EM>
.<EM CLASS="Identfier">
 | </EM>
-&gt;</P>
<P CLASS="BODY">
<A NAME="pgfId-706061"></A>These are the usual C binary operators (with the C precendences) with the addition of the &quot;<EM CLASS="Key-word">
?</EM>
&quot;, &quot;<EM CLASS="Key-word">
:</EM>
&quot;, &quot;<EM CLASS="Key-word">
.</EM>
&quot; and &quot;<EM CLASS="Key-word">
-&gt;</EM>
&quot; operators. These can be treated as binary operators because SNL makes no use of the semantics of ternary expressions and structure member access (a side-effect that you may notice is that the state notation compiler will warn that structure tags are unused variables).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-706062"></A><EM CLASS="Identfier">
asgnop</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-706066"></A>=<EM CLASS="Identfier">
 | </EM>
+=<EM CLASS="Identfier">
 | </EM>
-=<EM CLASS="Identfier">
 | </EM>
&amp;=<EM CLASS="Identfier">
 | </EM>
|=<EM CLASS="Identfier">
 | </EM>
/=<EM CLASS="Identfier">
 | </EM>
*=<EM CLASS="Identfier">
 | </EM>
%=<EM CLASS="Identfier">
 | </EM>
&lt;&lt;=<EM CLASS="Identfier">
 | </EM>
&gt;&gt;=<EM CLASS="Identfier">
 | </EM>
^=</P>
<P CLASS="BODY">
<A NAME="pgfId-706067"></A>These are the usual C assignment operators.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-706068"></A><EM CLASS="Identfier">
unop</EM>
</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-706071"></A>+<EM CLASS="Identfier">
 | </EM>
-<EM CLASS="Identfier">
 | </EM>
*<EM CLASS="Identfier">
 | </EM>
&amp;<EM CLASS="Identfier">
 | </EM>
!<EM CLASS="Identfier">
 | </EM>
&#126;</P>
<P CLASS="BODY">
<A NAME="pgfId-706126"></A>These are the usual C unary operators.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-706139"></A><EM CLASS="Identfier">
number<BR>
char_const<BR>
string<BR>
name</EM>
</H4>
<P CLASS="BODY">
<A NAME="pgfId-706151"></A>The usual C syntax is supported for numbers, character constants, strings and names. Note that, taken together,</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706159"></A><EM CLASS="Identfier">
expression </EM>
, <EM CLASS="Identfier">
expression...						</EM>
</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706206"></A><EM CLASS="Identfier">
name</EM>
 ( <EM CLASS="Identfier">
expression</EM>
 )</P>
<P CLASS="BODY">
<A NAME="pgfId-706248"></A>imply that function calls are permitted (syntactically, the argument list is a comma-separated expression).</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-692363"></A><A NAME="54856"></A>Built-in Functions<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<P CLASS="BODY">
<A NAME="pgfId-692364"></A>The following special functions are built into the SNL. In most cases the state notation compiler performs some special interpretation of the parameters to these functions. Therefore, some are either not available through escaped C code or their use in escaped C code is subject to special rules.</P>
<P CLASS="BODY">
<A NAME="pgfId-707172"></A>The term <EM CLASS="Identfier">
variable_name</EM>
 refers to any SNL variable that is assigned to a control system variable (or, if it's an array, variables). When using such a variable as a function argument, the function is automatically given access to the details of the underlying control system variable.</P>
<P CLASS="BODY">
<A NAME="pgfId-707177"></A>Several of these functions are primarily intended to be called only from <EM CLASS="Key-word">
when</EM>
<A NAME="marker-707191"></A> clauses or only from action code. However, unlike in previous versions, it is safe to call any function both in <EM CLASS="Key-word">
when</EM>
 clauses and in action code.</P>
<P CLASS="BODY">
<A NAME="pgfId-708936"></A><EM CLASS="Key-word">
int</EM>
 function returns should be assumed to be a <EM CLASS="Key-word">
pvStat</EM>
 error code unless otherwise spacified.</P>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692365"></A><A NAME="marker-706557"></A>delay</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692366"></A>int		delay(double <EM CLASS="Identfier">
delay_in_seconds</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692367"></A>The delay function returns <EM CLASS="Key-word">
TRUE</EM>
 if the specified time has elapsed since entering the state. It should be used only within a <EM CLASS="Key-word">
when</EM>
<A NAME="marker-706558"></A> expression.</P>
<P CLASS="BODY">
<A NAME="pgfId-706561"></A>The <A NAME="marker-706644"></A><EM CLASS="Key-word">
-t</EM>
 state option (<A HREF="Manual-6.html#29671" CLASS="XRef">See state_option_stmt</A>) controls whether the delay is measured from when the current state was entered from a different state (<EM CLASS="Key-word">
-t</EM>
) or from any state, including itself (<EM CLASS="Key-word">
+t</EM>
, the default)</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692368"></A><A NAME="marker-706905"></A><A NAME="33895"></A>pvPut</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-706816"></A>int		pvPut(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706961"></A>int		pvPut(<EM CLASS="Identfier">
variable_name</EM>
, <EM CLASS="Identfier">
SYNC</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-706864"></A>int		pvPut(<EM CLASS="Identfier">
variable_name</EM>
, <EM CLASS="Identfier">
ASYNC</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692370"></A>This function puts (or writes) the value of an SNL variable to the underlying control system variable. The function returns the status from the <A NAME="marker-706814"></A>PV layer (<EM CLASS="Emphasis">
e.g. </EM>
<EM CLASS="Key-word">
pvStatOK</EM>
 for success).</P>
<P CLASS="BODY">
<A NAME="pgfId-706904"></A>By default, <EM CLASS="Key-word">
pvPut</EM>
 does not wait for the put to be complete; completion must be inferred by other means. The optional <EM CLASS="Key-word">
SYNC</EM>
<A NAME="marker-707010"></A> argument causes it to block on completion with a hard-coded timeout of 10s. The optional <EM CLASS="Key-word">
ASYNC</EM>
<A NAME="marker-707009"></A> argument allows completion to be checked via a subsequent call to <EM CLASS="Key-word">
pvPutComplete</EM>
<A NAME="marker-707008"></A> (typically in a <EM CLASS="Key-word">
when</EM>
<A NAME="marker-707022"></A> clause).</P>
<P CLASS="BODY">
<A NAME="pgfId-707011"></A>Note that, when using <A NAME="marker-707021"></A>channel access, the <EM CLASS="Key-word">
SYNC</EM>
 and <EM CLASS="Key-word">
ASYNC</EM>
 arguments result in use of <EM CLASS="Key-word">
ca_put_callback</EM>
<A NAME="marker-707040"></A>; if neither optional argument is specified, <EM CLASS="Key-word">
ca_put</EM>
<A NAME="marker-707041"></A> is called as with previous versions.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-707324"></A><A NAME="marker-707159"></A><A NAME="marker-707323"></A><A NAME="20724"></A>pvPutComplete</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-707433"></A>int		pvPutComplete(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707437"></A>int		pvPutComplete(<EM CLASS="Identfier">
array_name</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707366"></A>int		pvPutComplete(<EM CLASS="Identfier">
array_name</EM>
, long <EM CLASS="Identfier">
any</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707370"></A>int		pvPutComplete(<EM CLASS="Identfier">
array_name</EM>
, long <EM CLASS="Identfier">
any</EM>
, long *<EM CLASS="Identfier">
pComplete</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-707326"></A>This function returns <EM CLASS="Key-word">
TRUE</EM>
 if the last put of this control system variable has completed. This call is appropriate only if <EM CLASS="Key-word">
pvPut</EM>
<A NAME="marker-707328"></A>'s optional <EM CLASS="Key-word">
ASYNC</EM>
 argument was used.</P>
<P CLASS="BODY">
<A NAME="pgfId-707388"></A>The first form is appropriate when the SNL variable is a scalar. However, it can also be an array (each of whose elements may be assigned to a different control system variable). In this case, the single argument form returns <EM CLASS="Key-word">
TRUE</EM>
 if the last puts of all the elements of the array have completed (the missing arguments are implicitly <EM CLASS="Key-word">
0</EM>
 and <EM CLASS="Key-word">
NULL</EM>
 respectively). If <EM CLASS="Key-word">
any</EM>
 is <EM CLASS="Key-word">
TRUE</EM>
, then the function returns <EM CLASS="Key-word">
TRUE</EM>
 if any put has completed since the last call. If <EM CLASS="Key-word">
pComplete</EM>
 is non-NULL, it should be a <EM CLASS="Key-word">
long</EM>
 array of the same length as the SNL variable and its elements will be set to <EM CLASS="Key-word">
TRUE</EM>
 if and only if the corresponding put has completed.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692371"></A><A NAME="marker-707347"></A><A NAME="42652"></A>pvGet</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-707043"></A>int		pvGet(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707051"></A>int		pvGet(<EM CLASS="Identfier">
variable_name</EM>
, <EM CLASS="Identfier">
SYNC</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707059"></A>int		pvGet(<EM CLASS="Identfier">
variable_name</EM>
, <EM CLASS="Identfier">
ASYNC</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692373"></A>This function gets (or reads) the value of an SNL variable from the underlying control system variable. The function returns the status from the <A NAME="marker-707078"></A>PV layer (<EM CLASS="Emphasis">
e.g.</EM>
 <EM CLASS="Key-word">
pvStatOK</EM>
 for success). By default, the state set will block until the read operation is complete with a hard-coded timeout of 10s. The asynchronous (<EM CLASS="Key-word">
+a</EM>
<A NAME="marker-707156"></A>) compile option can be used to prevent this, in which case completion can be checked via a subsequent call to <EM CLASS="Key-word">
pvGetComplete</EM>
<A NAME="marker-707157"></A> (typically in a <EM CLASS="Key-word">
when</EM>
<A NAME="marker-707158"></A> clause).</P>
<P CLASS="BODY">
<A NAME="pgfId-707284"></A>The optional <EM CLASS="Key-word">
SYNC</EM>
<A NAME="marker-707282"></A> and <EM CLASS="Key-word">
ASYNC</EM>
<A NAME="marker-707283"></A> arguments override the compile option. <EM CLASS="Key-word">
SYNC</EM>
 blocks and so gives default behavior if <EM CLASS="Key-word">
+a</EM>
 was not specified; <EM CLASS="Key-word">
ASYNC</EM>
 doesn't block and so gives default behavior if <EM CLASS="Key-word">
+a</EM>
 was specified.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-707286"></A><A NAME="marker-707285"></A>pvGetComplete</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-707287"></A>int		pvGetComplete(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-707238"></A>This function returns <EM CLASS="Key-word">
TRUE</EM>
 if the last get of this control system variable has completed, <EM CLASS="Emphasis">
i.e.</EM>
 the value in the variable is current. This call is appropriate only if the asynchronous (<EM CLASS="Key-word">
+a</EM>
<A NAME="marker-707262"></A>) compile option is specified or <EM CLASS="Key-word">
pvGet</EM>
<A NAME="marker-707261"></A>'s optional <EM CLASS="Key-word">
ASYNC</EM>
 argument was used.</P>
<P CLASS="BODY">
<A NAME="pgfId-708960"></A>Unlike <EM CLASS="Key-word">
pvPutComplete</EM>
, <EM CLASS="Key-word">
pvGetComplete</EM>
 doesn't support arrays.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692374"></A><A NAME="marker-707162"></A>pvGetQ</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-707502"></A>int		pvGetQ(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-707506"></A>int		pvGetQ(<EM CLASS="Identfier">
array_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692376"></A><A NAME="marker-707736"></A>This function removes the oldest value from a SNL variable's monitor queue (the variable should have been associated with a queue and an event flag via the <EM CLASS="Key-word">
syncQ</EM>
<A NAME="marker-707167"></A> statement) and updates the corresponding SNL variable. Despite its name, this function is really closer to <EM CLASS="Key-word">
efTestAndClear</EM>
 than it is to <EM CLASS="Key-word">
pvGet</EM>
. It returns <EM CLASS="Key-word">
TRUE</EM>
 if the queue was not empty.</P>
<P CLASS="BODY">
<A NAME="pgfId-707740"></A>If the SNL variable is an array then the behavior is the same regardless of whether the array name or an array element name is specified. This is because a single queue is associated with the entire array.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692378"></A><A NAME="marker-707737"></A>pvFreeQ</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692379"></A>void		pvFreeQ(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692380"></A><A NAME="marker-707756"></A>This function deletes all entries from an SNL variable's queue and clears the associated event flag (the variable should have been associated with a queue and an event flag via the <EM CLASS="Key-word">
syncQ</EM>
<A NAME="marker-707759"></A> statement).</P>
<P CLASS="BODY">
<A NAME="pgfId-707806"></A>As with <EM CLASS="Key-word">
pvGetQ</EM>
, if the SNL variable is an array then the behavior is the same regardless of whether the array name or an array element name is specified.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692384"></A><A NAME="57861"></A>pvMonitor</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-708969"></A><A NAME="marker-708968"></A>int		pvMonitor(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-708970"></A>This function initiates a monitor on the underlying control system variable.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-708972"></A><A NAME="marker-708971"></A>pvStopMonitor</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692388"></A>int		pvStopMonitor(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-707773"></A>This function terminates a monitor on the underlying control system variable.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692390"></A><A NAME="marker-707798"></A>pvFlush</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692391"></A>void		pvFlush()</P>
<P CLASS="BODY">
<A NAME="pgfId-692392"></A>This function causes the <A NAME="marker-707801"></A>PV layer to flush its input-output buffer. It just might be needed if performing asynchronous operations <EM CLASS="Emphasis">
within</EM>
 an action block (note that the buffer is always flushed on exit from an action block).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692393"></A><A NAME="marker-707963"></A>pvCount</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692394"></A>int		pvCount(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692395"></A>This function returns the element count associated with the control system variable.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692396"></A><A NAME="marker-708183"></A>pvStatus</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692397"></A>pvStat		pvStatus(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692398"></A>This function returns the current alarm status for the control system variable (<EM CLASS="Emphasis">
e.g.</EM>
 <EM CLASS="Key-word">
pvStatHIHI</EM>
; defined in <EM CLASS="Key-word">
pvAlarm.h</EM>
<A NAME="marker-708051"></A>). The status and severity are only valid after either a <EM CLASS="Key-word">
pvGet</EM>
 call has completed or a monitor has been delivered.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692400"></A><A NAME="marker-708184"></A>pvSeverity</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692401"></A>pvSevr		pvSeverity(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692402"></A>This function returns the current alarm severity (<EM CLASS="Emphasis">
e.g.</EM>
 <EM CLASS="Key-word">
pvSevrMAJOR</EM>
). The notes above apply</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692404"></A><A NAME="marker-708185"></A>pvTimeStamp</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692405"></A>TS_STAMP			pvTimeStamp(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692406"></A>This function returns the time stamp for the last pvGet or monitor of this variable. The compiler does recognize type TS_STAMP. Therefore, variable declarations for this type should be in escaped C code. This will generate a compiler warning, which can be ignored.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692408"></A><A NAME="marker-708186"></A>pvAssign</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692409"></A>int		pvAssign(<EM CLASS="Identfier">
variable_name</EM>
, <EM CLASS="Identfier">
control_system_variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692410"></A>This function assigns or re-assigned the SNL variable <EM CLASS="Identfier">
variable_name</EM>
 to <EM CLASS="Identfier">
control_system_variable_name</EM>
. If <EM CLASS="Identfier">
control_system_variable_name</EM>
 is an empty string then <EM CLASS="Identfier">
variable_name</EM>
 is de-assigned (not associated with any control system variable).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692411"></A><A NAME="marker-708187"></A>pvAssigned</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692412"></A>int		pvAssigned(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692413"></A>This function returns <EM CLASS="Key-word">
TRUE</EM>
 if the SNL variable is currently assigned to a control system variable.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692414"></A><A NAME="marker-708208"></A>pvConnected</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692415"></A>int		pvConnected(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692416"></A>This function returns <EM CLASS="Key-word">
TRUE</EM>
 if the underlying control system variable is currently connected.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692417"></A><A NAME="marker-708260"></A>pvIndex</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692418"></A>int		pvIndex(<EM CLASS="Identfier">
variable_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692421"></A>This function returns the index associated with a control system variable. See <A HREF="Manual-6.html#51917" CLASS="XRef">See User Functions within the State Program</A>.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692423"></A><A NAME="marker-708261"></A>pvChannelCount</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692424"></A>int		pvChannelCount()</P>
<P CLASS="BODY">
<A NAME="pgfId-692425"></A>This function returns the total number of control system variables associated with the state program (the term &quot;channel&quot; is a carry-over from the days when the only support message system was <A NAME="marker-708281"></A>channel access).</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692426"></A><A NAME="marker-708282"></A>pvAssignCount</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692427"></A>int		pvAssignCount()</P>
<P CLASS="BODY">
<A NAME="pgfId-692428"></A>This function returns the total number of SNL variables in this program that are assigned to underlying control system variables. Note: if all SNL variables are assigned then the following expression is <EM CLASS="Key-word">
TRUE</EM>
:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692429"></A>pvAssignCount() == pvChannelCount()</P>
<P CLASS="BODY">
<A NAME="pgfId-708321"></A>Each element of an SNL array counts as variable for the purposes of <EM CLASS="Key-word">
pvAssignCount</EM>
.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692430"></A><A NAME="marker-708338"></A>pvConnectCount</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692431"></A>int		pvConnectCount()</P>
<P CLASS="BODY">
<A NAME="pgfId-692432"></A>This function returns the total number of underlying control system variables that are connected. Note: if all variables are connected then the following expression is <EM CLASS="Key-word">
TRUE</EM>
:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692433"></A>pvConnectCount() == pvChannelCount()</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692434"></A><A NAME="marker-708392"></A>efSet</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692435"></A>void		efSet(<EM CLASS="Identfier">
event_flag_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692436"></A>This function sets the event flag and causes the execution of the <EM CLASS="Key-word">
when</EM>
<A NAME="marker-708371"></A> statements for all state sets that are pending on this event flag.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692437"></A><A NAME="marker-708393"></A>efTest</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692438"></A>int		efTest(<EM CLASS="Identfier">
event_flag_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692439"></A>This function returns <EM CLASS="Key-word">
TRUE</EM>
 if the event flag was set.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692440"></A><A NAME="marker-708394"></A>efClear</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692441"></A>int		efClear(<EM CLASS="Identfier">
event_flag_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692442"></A>This function clears the event flag and causes the execution of the <EM CLASS="Key-word">
when</EM>
<A NAME="marker-708372"></A> statements for all state sets that are pending on this event flag.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692443"></A><A NAME="marker-708395"></A>efTestAndClear</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692444"></A>int		efTestAndClear(<EM CLASS="Identfier">
event_flag_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692445"></A>This function clears the event flag and returns <EM CLASS="Key-word">
TRUE</EM>
 if the event flag was set. It is intended for use within a <EM CLASS="Key-word">
when</EM>
<A NAME="marker-708381"></A> clause.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692447"></A><A NAME="27179"></A>macValueGet</H4>
<P CLASS="PROGRAM">
<A NAME="pgfId-692448"></A><A NAME="marker-708396"></A>char*		macValueGet(char *<EM CLASS="Identfier">
macro_name</EM>
)</P>
<P CLASS="BODY">
<A NAME="pgfId-692449"></A>This function returns a pointer to a string that is the value for the specified macro name. If the macro does not exist, it returns <EM CLASS="Key-word">
NULL</EM>
.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="HEADING1">
<A NAME="pgfId-692450"></A>C Compatibility Features<DIV>
<IMG SRC="Manual-8.gif">
</DIV>
</H2>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-708398"></A><A NAME="marker-708498"></A>Comments</H4>
<P CLASS="BODY">
<A NAME="pgfId-692451"></A>C-style comments may be placed anywhere in the state program.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692452"></A><A NAME="marker-708499"></A>Escape to C Code</H4>
<P CLASS="BODY">
<A NAME="pgfId-692453"></A><A NAME="marker-708500"></A>Because the SNL does not support the full C language, C code may be escaped in the program. The escaped code is not compiled by SNC, but is passed the C compiler. There are two escape methods allowed:</P>
<P CLASS="BODY">
<A NAME="pgfId-692454"></A>1. <A NAME="marker-708501"></A>Any code between <EM CLASS="Key-word">
%%</EM>
 and the next newline character is escaped. Example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692455"></A>%% for (i=0; i &lt; NVAL; i++) {</P>
<P CLASS="BODY">
<A NAME="pgfId-692456"></A>2. <A NAME="marker-708502"></A>Any code between <EM CLASS="Key-word">
%{</EM>
 and <EM CLASS="Key-word">
}%</EM>
 is escaped. Example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692457"></A>%{</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692458"></A>extern 	float					smooth();</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692459"></A>extern 	LOGICAL					accelerator_mode;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692460"></A>}%</P>
<P CLASS="BODY">
<A NAME="pgfId-692461"></A>If you are using the C pre-processor prior to compiling with <EM CLASS="Key-word">
snc</EM>
, and you wish to defer interpretation of a preprocessor directive (&quot;<EM CLASS="Key-word">
#</EM>
&quot; statement), then you should use the form: </P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692462"></A>%%#include				&lt;ioLib.h&gt;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692463"></A>%%#include				&lt;abcLib.h&gt;</P>
<P CLASS="BODY">
<A NAME="pgfId-692464"></A>Any variable declared in escaped C code and used in SNL code will be flagged with a <A NAME="marker-708503"></A>warning message by the SNC. However, it will be passed on to the C compiler correctly.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692471"></A><A NAME="51917"></A>User Functions within the State Program</H4>
<P CLASS="BODY">
<A NAME="pgfId-692472"></A>The last state set may be followed by C code, usually containing one or more user-supplied functions. For example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692473"></A>program example { <EM CLASS="Bold">
...</EM>
 }</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692474"></A>/* last SNL statement */</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692475"></A>%{</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692476"></A>LOCAL float smooth (pArray, numElem)</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692477"></A>  { ... }</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692478"></A>}%</P>
<P CLASS="BODY">
<A NAME="pgfId-692479"></A>There is little reason to do this, since a state program can of course be linked against C libraries.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-708505"></A><A NAME="marker-708508"></A>Calling pvGet etc. from C</H4>
<P CLASS="BODY">
<A NAME="pgfId-708504"></A>The built-in SNL functions such as <EM CLASS="Key-word">
pvGet</EM>
 cannot be directly used in user-supplied functions. However, most of the built-in functions have a C language equivalent, which begin with the prefix seq_ (<EM CLASS="Emphasis">
e.g. </EM>
pvGet becomes seq_pvGet). These C functions must pass a parameter identifying the calling state program, and if a control system variable name is required, the index of that variable must be supplied. This index is obtained via the pvIndex function. Furthermore, if the code is complied with the <EM CLASS="Key-word">
+r</EM>
<A NAME="marker-708512"></A> option, the database variables must be referenced as a structure element as described in <A HREF="Manual-6.html#69816" CLASS="XRef">See Variable Modification for Reentrant Option</A> (this isn't a problem if individual SNL variables are passed as parameters to C code, because the compiler will do the work). Examination of the intermediate C code that the compiler produces will indicate how to use the built-in functions and database variables.</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692483"></A><A NAME="marker-708511"></A><A NAME="64912"></A>Variable Extent</H4>
<P CLASS="BODY">
<A NAME="pgfId-692484"></A>All variables declared in a state program are made static (non-global) in the C file, and thus are not accessible outside the state program module.</P>
<P CLASS="BODY">
<A NAME="pgfId-708514"></A><A NAME="marker-708515"></A>Local variables can be escaped and declared within <EM CLASS="Key-word">
when</EM>
<A NAME="marker-708529"></A> clauses (this will result in a &quot;variable used but not declared&quot; warning from the compiler; ignore it). However, when using the <EM CLASS="Key-word">
+r</EM>
 option, the same name cannot be used for SNL and local variables (because the compiler is not clever enough to realize that use of the local variable is intended; see <A HREF="Manual-6.html#69816" CLASS="XRef">See Variable Modification for Reentrant Option</A>). For example:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708545"></A>		when ( pvPutComplete( init, TRUE, done ) ) {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708550"></A>%%			long i;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708551"></A>			printf( &quot;init commands not all done:&quot; );</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708597"></A>			for ( i = 0; i &lt; N; i++ )</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708553"></A>				printf( &quot; %ld&quot;, done[i] );</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708554"></A>			printf( &quot;&#92;n&quot; );</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-708555"></A>		} state active</P>
</DIV>
<DIV>
<H4 CLASS="UHEADING3">
<A NAME="pgfId-692486"></A><A NAME="69816"></A>Variable Modification for Reentrant Option</H4>
<P CLASS="BODY">
<A NAME="pgfId-692487"></A>If the reentrant option (<EM CLASS="Key-word">
+r</EM>
<A NAME="marker-708513"></A>) is specified to SNC then all variables are made part of a structure. Suppose we have the following declarations in the SNL:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692488"></A>int			sw1;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692489"></A>float			v5;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692490"></A>short			wf2[1024];</P>
<P CLASS="BODY">
<A NAME="pgfId-692491"></A>The C file will contain the following declaration:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692492"></A>struct UserVar {</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692493"></A> 	int			sw1;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692494"></A> 	float			v5;</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692495"></A> 	short			wf2[1025];</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692496"></A>};</P>
<P CLASS="BODY">
<A NAME="pgfId-692497"></A>The sequencer allocates the structure area at run time and passes a pointer to this structure into the state program. This structure has the following type: </P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692498"></A>struct UserVar						*pVar;</P>
<P CLASS="BODY">
<A NAME="pgfId-692499"></A>Reference to variable <EM CLASS="Key-word">
sw1</EM>
 is made as:</P>
<P CLASS="PROGRAM">
<A NAME="pgfId-692500"></A>pVar-&gt;sw1</P>
<P CLASS="BODY">
<A NAME="pgfId-692501"></A>This conversion is automatically performed by the SNC for all SNL statements, but you will have to handle escaped C code yourself.</P>
</DIV>
</DIV>
</BODY>
</HTML>
