<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>areaDetector Prosilica driver</title>
</head>
<body>
  <div style="text-align: center">
    <h1>
      areaDetector Prosilica driver</h1>
    <h2>
      January 30, 2009</h2>
    <h2>
      Mark Rivers</h2>
    <h2>
      University of Chicago</h2>
  </div>
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Performance measurements">Performance measurements</a></li>
    <li><a href="#Hardware notes">Hardware notes</a></li>
    <li><a href="#Restrictions">Restrictions</a></li>
    <li><a href="#Future">Future enhancements</a></li>
  </ul>
  <h2 id="Prosilica Driver">
    Prosilica Driver</h2>
  <p>
    This is a driver for Gigabit Ethernet and Firewire cameras from <a href="http://www.prosilica.com">
      Prosilica</a>. It inherits from ADDriver and implements nearly all of the parameters
    in ADStdDriverParams.h. It also implements a number of parameters that are specific
    to the Prosilica cameras. The driver is only supported under Windows (EPICS win32-x86
    architecture) and Linux because the vendor library is only provided as a pre-built
    binary for those operating systems. The vendor library provided by Prosilica does
    callbacks to a user-supplied function each time there is a new frame. Thus, the
    driver does not need to create a thread itself for callbacks.
  </p>
  <p>
    The vendor library supports saving individual frames as TIFF files, and this is
    implemented in the driver. The NDPluginFile plugin can be used to capture or stream
    images much more rapidly in the netCDF file format.
  </p>
  <p>
    The driver redefines the choices for 2 of the parameters defined in ADStdDriverParams.h.
    The ADTriggerMode choices for the Prosilica are:
  </p>
  <ul>
    <li>Free Run (collects images as fast as allowed by the camera readout and the exposure
      time)</li>
    <li>Sync In 1 (external trigger on line 1)</li>
    <li>Sync In 2 (external trigger on line 2)</li>
    <li>Sync In 3 (external trigger on line 3)</li>
    <li>Sync In 4 (external trigger on line 4)</li>
    <li>Fixed Rate (collects images at a fixed rate)</li>
    <li>Software (single software trigger)</li>
  </ul>
  <p>
    The Prosilica supports hardware timing input and output signals that are supported
    in the driver.
  </p>
  <p>
    The ADFileFormat choices for the Prosilica are:
  </p>
  <ul>
    <li>TIFF (this is the only format supported)</li>
    <li>Invalid (this menu item is defined only because MEDM will not display a menu widget
      with only 1 choice)</li>
  </ul>
  <p>
    The ADDataType choices for the Prosilica are:
  </p>
  <ul>
    <li>NDUInt8 (8-bit data)</li>
    <li>NDUInt16 (12 or 16 bit data)</li>
  </ul>
  <p>
    The ADColorMode choices for the Prosilica are:
  </p>
  <ul>
    <li>NDColorModeMono (monochromatic data)</li>
    <li>NDColorModeBayer (raw Bayer data)</li>
    <li>NDColorModeRGB1 (RGB1 data)</li>
  </ul>
  <p>
    The color Prosilica cameras are also capable of various YUV color formats but these
    are not supported in the driver. They may be added in a future release.
  </p>
  <p>
    The Prosilica driver implements the following parameters in addition to those in
    ADStdDriverParams.h:
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="CENTER" colspan="7,">
          <b>Parameter Definitions in prosilica.cpp and EPICS Record Definitions in prosilica.template</b></td>
      </tr>
      <tr>
        <th>
          Enum name</th>
        <th>
          asyn interface</th>
        <th>
          Access</th>
        <th>
          Description</th>
        <th>
          drvUser string</th>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
      </tr>
      <tr>
        <td align="CENTER" colspan="7,">
          <b>Trigger and I/O Control</b></td>
      </tr>
      <tr>
        <td>
          PSSyncIn1Level</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          The level of the Sync In 1 signal</td>
        <td>
          PS_SYNC_IN_1_LEVEL</td>
        <td>
          $(P)$(R)SyncIn1Level_RBV</td>
        <td>
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncIn2Level</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          The level of the Sync In 2 signal</td>
        <td>
          PS_SYNC_IN_2_LEVEL</td>
        <td>
          $(P)$(R)SyncIn2Level_RBV</td>
        <td>
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut1Mode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The mode of the Sync Out 1 signal. Allowed values are:
          <br />
          GPO (general purpose output)
          <br />
          AcqTrigReady
          <br />
          FrameTrigReady
          <br />
          FrameTrigger
          <br />
          Exposing
          <br />
          FrameReadout
          <br />
          Imaging
          <br />
          Acquiring
          <br />
          SyncIn1
          <br />
          SyncIn2
          <br />
          SyncIn3
          <br />
          SyncIn4
          <br />
          Strobe1
          <br />
          Strobe2
          <br />
          Strobe3
          <br />
          Strobe4
          <br />
        </td>
        <td>
          PS_SYNC_OUT_1_MODE</td>
        <td>
          $(P)$(R)SyncOut1Mode
          <br />
          $(P)$(R)SyncOut1Mode_RBV
        </td>
        <td>
          mbbo
          <br />
          mbbi
        </td>
      </tr>
      <tr>
        <td>
          PSSyncOut1Level</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The level of the Sync Out 1 signal. This is only programmable when SyncOut1Mode=GPO.</td>
        <td>
          PS_SYNC_OUT_1_LEVEL</td>
        <td>
          $(P)$(R)SyncOut1Level<br />
          $(P)$(R)SyncOut1Level_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut1Invert</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Flag to invert the Sync Out 1 signal.</td>
        <td>
          PS_SYNC_OUT_1_INVERT</td>
        <td>
          $(P)$(R)SyncOut1Invert<br />
          $(P)$(R)SyncOut1Invert_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut2Mode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The mode of the Sync Out 2 signal. Allowed values are the same as for PSSyncOut1Mode.
        </td>
        <td>
          PS_SYNC_OUT_2_MODE</td>
        <td>
          $(P)$(R)SyncOut2Mode
          <br />
          $(P)$(R)SyncOut2Mode_RBV
        </td>
        <td>
          mbbo
          <br />
          mbbi
        </td>
      </tr>
      <tr>
        <td>
          PSSyncOut2Level</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The level of the Sync Out 2 signal. This is only programmable when SyncOut2Mode=GPO.</td>
        <td>
          PS_SYNC_OUT_2_LEVEL</td>
        <td>
          $(P)$(R)SyncOut2Level<br />
          $(P)$(R)SyncOut1Level_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut2Invert</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Flag to invert the Sync Out 2 signal.</td>
        <td>
          PS_SYNC_OUT_2_INVERT</td>
        <td>
          $(P)$(R)SyncOut2Invert<br />
          $(P)$(R)SyncOut2Invert_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut3Mode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The mode of the Sync Out 3 signal. Allowed values are the same as for PSSyncOut1Mode.
        </td>
        <td>
          PS_SYNC_OUT_3_MODE</td>
        <td>
          $(P)$(R)SyncOut3Mode
          <br />
          $(P)$(R)SyncOut3Mode_RBV
        </td>
        <td>
          mbbo
          <br />
          mbbi
        </td>
      </tr>
      <tr>
        <td>
          PSSyncOut3Level</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The level of the Sync Out 3 signal. This is only programmable when SyncOut3Mode=GPO.</td>
        <td>
          PS_SYNC_OUT_3_LEVEL</td>
        <td>
          $(P)$(R)SyncOut3Level<br />
          $(P)$(R)SyncOut3Level_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSSyncOut3Invert</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Flag to invert the Sync Out 3 signal.</td>
        <td>
          PS_SYNC_OUT_3_INVERT</td>
        <td>
          $(P)$(R)SyncOut3Invert<br />
          $(P)$(R)SyncOut3Invert_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSStrobe1Mode</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          The mode of the Strobe 1 signal. The Strobe signals are based on the following values,
          but allow for changing the delay and width relative to the underlying value. Any
          of the outputs can be set to the Stobe1 value, rather than the raw values of these
          signals. Allowed values are:
          <br />
          AcqTrigReady
          <br />
          FrameTrigReady
          <br />
          FrameTrigger
          <br />
          Exposing
          <br />
          FrameReadout
          <br />
          Acquiring
          <br />
          SyncIn1
          <br />
          SyncIn2
          <br />
          SyncIn3
          <br />
          SyncIn4
          <br />
        </td>
        <td>
          PS_STROBE_1_MODE</td>
        <td>
          $(P)$(R)Strobe1Mode
          <br />
          $(P)$(R)Strobe1Mode_RBV
        </td>
        <td>
          mbbo
          <br />
          mbbi
        </td>
      </tr>
      <tr>
        <td>
          PSStrobe1CtlDuration</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Flag to allow controlling the strobe duration.</td>
        <td>
          PS_STROBE_1_CTL_DURATION</td>
        <td>
          $(P)$(R)Strobe1CtlDuration<br />
          $(P)$(R)Strobe1CtlDuration_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          PSStrobe1Duration</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          The strobe duration if PSStrobe1CtlDuration is On.</td>
        <td>
          PS_STROBE_1_DURATION</td>
        <td>
          $(P)$(R)Strobe1Duration<br />
          $(P)$(R)Strobe1Duration_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          PSStrobe1Delay</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          The strobe delay relative to the underlying signal that the strobe is based on.</td>
        <td>
          PS_STROBE_1_DELAY</td>
        <td>
          $(P)$(R)Strobe1Delay<br />
          $(P)$(R)Strobe1Delay_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td align="CENTER" colspan="7,">
          <b>Statistics Information</b></td>
      </tr>
      <tr>
        <td>
          PSReadStatistics</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          Read the Gigabit Ethernet statistics when 1</td>
        <td>
          PS_READ_STATISTICS</td>
        <td>
          $(P)$(R)PSReadStatistics</td>
        <td>
          longout</td>
      </tr>
      <tr>
        <td>
          PSStatDriverType</td>
        <td>
          asynOctet</td>
        <td>
          r/o</td>
        <td>
          Driver type</td>
        <td>
          PS_DRIVER_TYPE</td>
        <td>
          $(P)$(R)PSDriverType_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          PSStatFilterVersion</td>
        <td>
          asynOctet</td>
        <td>
          r/o</td>
        <td>
          Packet filter version</td>
        <td>
          PS_FILTER_VERSION</td>
        <td>
          $(P)$(R)PSFilterVersion_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          PSStatFrameRate</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          Frame rate (Hz)</td>
        <td>
          PS_FRAME_RATE</td>
        <td>
          $(P)$(R)PSFrameRate_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          PSStatFramesCompleted</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of frames completed</td>
        <td>
          PS_FRAMES_COMPLETED</td>
        <td>
          $(P)$(R)PSFramesCompleted_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatFramesDropped</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of frames dropped</td>
        <td>
          PS_FRAMES_DROPPED</td>
        <td>
          $(P)$(R)PSFramesDropped_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatPacketsErroneous</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of erroneous packets</td>
        <td>
          PS_PACKETS_ERRONEOUS</td>
        <td>
          $(P)$(R)PSPacketsErroneous_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatPacketsMissed</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of missed packets</td>
        <td>
          PS_PACKETS_MISSED</td>
        <td>
          $(P)$(R)PSPacketsMissed_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatPacketsReceived</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of received packets</td>
        <td>
          PS_PACKETS_RECEIVED</td>
        <td>
          $(P)$(R)PSPacketsReceived_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatPacketsRequested</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of packets requested</td>
        <td>
          PS_PACKETS_REQUESTED</td>
        <td>
          $(P)$(R)PSPacketsRequested_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSStatPacketsResent</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of packets resent</td>
        <td>
          PS_PACKETS_RESENT</td>
        <td>
          $(P)$(R)PSPacketsResent_RBV</td>
        <td>
          longin</td>
      </tr>
      <tr>
        <td>
          PSBadFrameCounter</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          Number of bad frames</td>
        <td>
          PS_BAD_FRAME_COUNTER</td>
        <td>
          $(P)$(R)PSBadFrameCounter_RBV</td>
        <td>
          longin</td>
      </tr>
    </tbody>
  </table>
  <p>
    The following is the MEDM screen ADBase.adl connected to a Prosilica camera.
  </p>
  <div style="text-align: center">
    <h3>
      ADBase.adl</h3>
    <img alt="ADBase_prosilica.png" src="ADBase_prosilica.png" /></div>
  <p>
    The following is the MEDM screen that provides access to the specific parameters
    for the Prosilica detector.
  </p>
  <div style="text-align: center">
    <h3>
      prosilica.adl</h3>
    <img alt="prosilica.png" src="prosilica.png" /></div>
  <p>
    The following is an IDL <a href="http://cars.uchicago.edu/software/idl/imaging_routines.html#epics_ad_display">
      epics_ad_display</a> screen displaying the Prosilica detector images.
  </p>
  <div style="text-align: center">
    <h3>
      epics_ad_display.pro</h3>
    <img alt="prosilica_tvscl.jpg" src="prosilica_tvscl.jpg" /></div>
  <h2 id="Future">
    Future enhancements</h2>
  <p>
    Work is needed on connection management. If the camera is unplugged or powered off
    when the areaDetector driver is running it does not gracefully recover.
  </p>
  <p>
    The Linux driver currently requires some modifications to EPICS base. This should
    be resolved either by modifying base or with changes from Prosilica for their driver.
  </p>
</body>
</html>
