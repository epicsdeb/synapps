<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>autosave</title>
</head>

<body bgcolor="#FFFFFF">

<h1 align="center">autosave v4.5</h1>

Autosave automatically saves the values of EPICS process variables (PVs) to
files on a server, and restores those values when the IOC is rebooted.  The
original author is Bob Dalesio; I made some improvements; Frank Lenkszus made
some more improvements, which I folded into the version I've been maintaining. 
A bunch of people contributed to getting the software running on PPC hardware,
including Ron Sluiter, Andrew Johnson, and Pete Jemian (APS), Markus Janousch
and David Maden (SLS), and I'm not sure who else.

<P>Autosave is a two-part operation: run-time save, and boot-time restore.  The
run-time part (save_restore.c) is started by commands in the IOC startup file,
and persists while the IOC is running.  Its primary job is to save PV values to
files on a server, but it also supports manual restore and other management
operations.  The boot-time part (dbrestore.c) is invoked during iocInit, via an
EPICS initHook.  It restores PV values from files written by the run-time part,
and does not persist after iocInit() returns.

<P>In addition to the autosave software, the autosave module contains a client
program, asVerify, to compare written autosave files with current PV values.
This program can also write an autosave file from which PV values can be
restored.

<h2> Important nuances </h2>
<ul>

<P><li>Autosave uses dbStaticLib to write parameters at boot time, just like
dbLoadRecords().  Thus, boot-time restore does not cause record processing to
occur, and it does not make a record's value defined (doesn't set UDF to 0).
<em>Exception: arrays cannot be written by dbStaticLib, so autosave writes arrays
using database access.  This still doesn't cause processing to occur, though it
should cause the record's UDF field to be set to 0.</em>

<P><li>At run time (after boot-time restore), autosave reads and writes using
channel-access.  Thus, restoring at run time will in general produce a
different result than restoring at boot time. <em>Exception: arrays are read and
written using database access.</em>

<P><li>Boot-time restore can occur at either or both of two times: before record
initialization ("pass 0"); and after record initialization ("pass 1").  (Record
initialization includes device initialization.) For most PV's, you don't need to
think about this; just tell autosave to restore at both times, and autosave will
do whatever is required to get the value written.  You cannot make this
restore-time choice on a PV-by-PV basis; you can only specify when an entire
file of parameters should be restored.

<P>If you want the restored value available for use by device support during its
initialization, you must cause the value to be restored during pass 0.  (Note
that arrays cannot be restored at this time.) If you want the restored value to
overwrite the value written by record/device initialization, you must cause the
value to be restored dusing pass 1.

<P>Motor-record positions (VAL or DVAL) should be restored only before record
initialization, because this is the assumption under which motor-record device
support was written. 

<P>In the lore that has built up around autosave, PV's that should be restored
only before record initialization have been termed "positions".  All other PV's
have been termed "settings".  Thus, you might run across a file called
'auto_positions.req', and now you'll know that the parameters in this file are
intended to be restored only during autosave's pass-0.

<P><li>You can save parameters without also restoring them, and restore
parameters without also saving them, but you can't make these choices for
individual parameters, only for entire files of parameters. 

</ul>

<h2> Module contents</h2>

<h3>asApp/src</h3>
<dl>
<dt>save_restore.c
<dd>saves PV values in files on a file server according to preset rules.

<dt>dbrestore.c
<dd>restore PV values at boot time, using dbStaticLib

<dt>initHooks.c
<dd>call restore routines at the correct time during boot.

<dt>fGetDateStr.c
<dd>Frank Lenkszus' date-string routines

<dt>save_restore.h, fGetDateStr.h
<dd>headers

<dt>asVerify.c
<dd>Client-side tool to compare autosaved file with current PV values.
Can also write an autosave file.
</dl>

<p><h3>asApp/Db</h3>
<dl>
<dt>auto_settings.req, auto_positions.req 
<dd>Sample request files

<dt>save_restoreStatus.db
<dd>database containing records save_restore uses to report status.

<dt>infoExample.db
<dd>database containing a record with info nodes specifying fields to be
autosaved.

<dt>SR_test.db
<dd>Test database for autosave and asVerify.
</dl>

<p><h3>asApp/op/adl</h3>
<dl>
<dt>save_restoreStatus*.adl, save_restoreStatusLegend.adl,
save_restoreStatus_more.adl, save_restoreStatus_tiny.adl,
SR_X_Status.adl
<dd>MEDM displays of save_restore status.
</dl>


<hr>
<h2>How to use autosave</h2>

This software can be used in many different ways.  I'll describe what you have
to do to use it as it's commonly used at APS beamlines to save PV values
periodically, and restore them on reboot.  A complete example of how
autosave is used at APS can be found in the synApps xxx module.  The relevant
files in that module are the following:

<ul>
<dl>
<dt>xxx/configure/RELEASE
<dd>look for "AUTOSAVE"
<dt>xxx/xxxApp/src/Makefile
<dd>look for "autosave"
<dt>xxx/xxxApp/src/xxxCommonInclude.dbd
<dd>look for "asSupport.dbd"
<dt>xxx/iocBoot/iocvxWorks/save_restore.cmd
<dd>the whole file
<dt>xxx/iocBoot/iocvxWorks/auto_positions.req
<dd>the whole file
<dt>xxx/iocBoot/iocvxWorks/auto_settings.req
<dd>the whole file
<dt>xxx/iocBoot/iocvxWorks/st.cmd
<dd>look for "save_restore.cmd" before the call to iocInit, and
"create_monitor_set" after the call to iocInit.
<dt>xxx/iocBoot/iocvxWorks/autosave
<dd>a directory to hold autosave .sav files
</dl>
</ul>

Here's a step-by-step program for deploying autosave.  Some of the steps
are optional:

<h4>1. Build (required)</h4>
Build the module and include the resulting library,
libautosave.a, and database-definition file, asSupport.dbd, in an IOC's
build.  For example, add
<pre>	AUTOSAVE=&lt;path to the autosave module&gt;</pre>
to xxx/configure/RELEASE, add
<pre>	xxx_LIBS += autosave</pre>
to xxxApp/src/Makefile, and add
<pre>	include "asSupport.dbd"</pre>
to iocxxxInclude.dbd.

<h4>2. Write request files (optional, though this is the most common use)</h4>
Create "request" files (e.g., auto_settings.req,
auto_positions.req) specifying the PVs whose values you want to save and
restore.  The save files corresponding to these request files will have the
".req" suffix replaced by ".sav".

Request files can include other request files (nested includes are allowed) and
macro substitution can be performed on the included files (using William
Lupton's macro library), with the following syntax:
<pre>
	file &lt;request_file&gt; &lt;macro-substitution_string&gt;
</pre>
e.g.,
<pre>
	file motor_settings.req P=xxx:,M=m1
</pre>

<P>I've tried to defend against forseeable variations in syntax, so that include
lines with embedded whitespace and/or quotes, macro strings without commas,
empty macro strings, and lines with trailing comments will be parsed as one
would want.  Generally, quotes are ignored, whitespace implies a comma but
otherwise is ignored, and everything after the second sequence of
non-whitespace characters (i.e., after the file name) and before the (optional)
comment character '#' is taken as the macro-substitution string.  Macro
substitution is performed on the entire line, so it's possible to parameterize
names of included files, as well as PV names.  It is also possible to define a
macro that replaces its target with nothing.

<p>Most synApps modules contain autosave-request files that are
intended to be included in an ioc's autosave-request file(s).  For example,
calc/calcApp/Db/scalcout_settings.req contains a list of the fields one
might want to autosave for a single scalcout record.  This file is
<i>include</i>d in calc/calcApp/Db/userStringCalcs10_settings.req, which,
in turn, is included in xxx/iocBoot/iocvxWorks/auto_settings.req.

<p>Beginning with version 4.3, autosave can generate request files from
<i>info</i> nodes contained in an EPICS database.  See the function
<code>makeAutosaveFiles()</code>, below, for more information on this topic.

<P> <i>Note: Beginning with synApps version 5.2.1, synApps contains software to
generate autosave-request files from information contained in command and
database files. See synApps/support/utils/makeAutosaveFiles.py.</i>

<h4>3. Set request-file path (optional, recommended)</h4>
Specify one or more directories to be searched for
request files, using one or more invocations of the function
<pre>
	set_requestfile_path()
</pre>

<h4>4. Set NFS host (optional, only available on vxWorks)</h4>
Specify the NFS host from which save files will be read at restore time,
and to which they will be written at save time, by calling the function
<pre>
	save_restoreSet_NFSHost()
</pre>

<P>When autosave manages its own NFS mount, as this command directs it to do, it
can fix a stale file handle by dismounting and remounting the file system.   

<h4>5. Use NFS (required on vxWorks) </h4>

Use NFS, preferably as described above, or by including an
<code>nfsMount()</code> command in your startup script.  Save_restore is only
tested with NFS, and probably will not work with vxWorks' netDrv .

<P>When autosave runs under operating systems other than vxWorks, it simply uses
whatever mount the operating system, or a system administrator, has provided.

<h4>6. Set save-file path (optional, recommended)</h4>
Specify the directory in which you want save
files to be written, by calling the function
<pre>
	set_savefile_path()
</pre>

in your startup script, before the <code>create_xxx_set()</code> commands, to
specify the path to the directory.  If you are using NFS (strongly recommended),
ensure that the path does not contain symbolic links.  In my experience, VxWorks
cannot write through a symbolic link.  (I don't understand all the ins and outs
of this limitation.  It may be that symbolic links are OK if they contain
absolute path names.)

<P>Beginning with autosave v4.3, you can also specify the path and/or
filename, to which an autosave <tt>.sav</tt> file is to be written, with
an EPICS PV. See the documentation of <tt>create_xxx_set()</tt> for details. 


<h4>7. Give the ioc write permission to the autosave directory (required)</h4>
Give the IOC write permission to the directory in which the save
files are to be written.  If you forget this step, save_restore may be able to
write save files, but the files will be corrupted because save_restore will not
be permitted to change their lengths.  Save_restore attempts to detect this
condition, but cannot work around it if the file length must increase.

<h4>8. Specify restore files (optional, recommended)</h4>

Specify which save files are to be restored before record initialization (pass 0)
and which are to be restored after record initialization (pass 1), using the
commands

<pre>
	set_pass0_restoreFile()
	set_pass1_restoreFile()
</pre>

Place these commands in the startup file before iocInit.  In versions earlier
than 4.4, autosave would attempt to restore  "auto_positions.sav" and
"auto_settings.sav", if no restore files had been specified.  Beginning with
version 4.5, only files specified in calls to set_pass<i>n</i>_restoreFile() are
restored.

<P>To disable boot-time restore completely, delete or comment out all
<code>set_pass<i>n</i>_restoreFile()</code> calls.

<p>Notes on restore passes:
<ol>
<li><P>Link fields cannot be restored (by dbStatic calls) after record
initialization.  If you want save/restore to work for link fields you must
specify them in a pass-0 file.  
<li><P> Device support code for the motor record uses the value of the field
DVAL, restored during pass 0, only if the value read from the hardware is
zero.  If the value from hardware is nonzero, it is used instead of the
restored value.
<li><P>Arrays cannot be restored during pass 0. 

<li><P>Scalar PV's which have type DBF_NOACCESS in the .dbd file, and are set
to some other DBF type during record initialization, cannot be restored during
pass 0. 

<li>It is not an error to attempt to restore PV's during the wrong pass. The
default strategy, implemented with auto_settings.req and auto_positions.req, is
to use both passes for everything except PV's that shouldn't be restored in
pass 1.  (Motor positions aren't restored in pass 1 because doing so would
overwrite any values read from the hardware.)

</ol>

<h4>9. Load initHook routine (required)</h4>
Load a copy of initHooks that calls reboot_restore() to restore
saved parameter values.  The copy of initHooks included in this distribution is
recommended.  This will happen automatically if the ioc's executable is built
as described above.

<P>You can disable boot-time restore by refraining from loading the initHook
routine, but this is not always practical.  Another way to disable boot-time
restore is described in step <i>8. Specify restore files</i>, above.

<h4>10. Select save-file options (optional, recommended)</h4>
<ul>
<li>Tell save_restore to writed dated backup files.
At boot time, the restore software writes a backup copy of the ".sav" file from
which it restored PV's.  This file can either be named xxx.sav.bu, and be
rewritten every reboot, or named xxx.sav_YYMMDD-HHMMSS, where "YY..." is a
date.  Dated backups are not overwritten.  If you want dated backup files, put
the following line in your st.cmd file before the call toiocInit():
<pre>
	save_restoreSet_DatedBackupFiles(1)
</pre>

<P>Note:
  If a save file is restored in both pass 0 and pass 1, the boot-backup file
  will be written only during pass 0.

<P><li>Tell save_restore to save sequence files.  The
commands:
<pre>
	save_restoreSet_NumSeqFiles(3)
	save_restoreSet_SeqPeriodInSeconds(600)
</pre>
will cause save_restore to maintain three copies of each .sav file, at
ten-minute intervals.  Note: if autosave fails to write the .sav file, it will
stop making sequence copies until it again succeeds.

<P><li>Specify the time delay between a failed .sav-file write and the retry of
that write.  The default delay is 60 seconds.  If list-PV's change during the
delay, the new values will be written.
<pre>
	save_restoreSet_RetrySeconds(60)
</pre>
</ul>

<h4>11. Start the save task (required)</h4>
Invoke the "save" part of this software as part of the EPICS
startup sequence, by calling create_XXX_set() -- e.g., adding lines of the form
<pre>
	create_monitor_set("auto_positions.req", 5, "P=xxx:")
	create_monitor_set("auto_settings.req", 30, "P=xxx:")
</pre>

to your EPICS startup file after iocInit.  You can call the files anything you
want, but note that the file names "auto_positions" and "auto_settings" receive
special treatment: they are default restore-file names specified by
<code>asInitHooks()</code> if <code>set_passN_restoreFile()</code> were never
called.  The third argument to <code>create_monitor_set()</code>  is a
macro-substitution string, as described above in the discussion of request files
(step 2).  If supplied, this macro-substitution string supplements any macro
strings supplied in include-file directives of request files read for this save
set.

<P> If you want to start the save task without also creating a save set, you
can make the call <code>create_monitor_set("", 0, "")</code>.

<P>The macro string can also be used to override the default path and name to
which the <tt>.sav</tt> file will be written.  If the macro
<tt>SAVEPATHPV=&lt;pv-name&gt;</tt> is included, autosave will write the
<tt>.sav</tt> file to the path read from the EPICS PV &lt;pv-name&gt;, instead
of writing to the path specified in <tt>set_savefile_path()</tt>. If the macro
<tt>SAVENAMEPV=&lt;pv-name&gt;</tt> is included, autosave will write the
<tt>.sav</tt> file to the filename read from the EPICS PV &lt;pv-name&gt;.
(By default, the <tt>.sav</tt> file name is the request-file name, with <tt>.req</tt>
replaced by <tt>.sav</tt>.)

<P><b>NOTE:</b>  If either <tt>SAVEPATHPV</tt> or <tt>SAVENAMEPV</tt> occurs in
the macro string, autosave will not attempt to save backup or sequence files for
the save set.


<P>For each <code>create_monitor_set(&lt;name&gt;.req, &lt;time&gt;, &lt;macro&gt;)</code> command, the
save_restore process will write the files &lt;name&gt;.sav and &lt;name&gt;.savB every
&lt;time&gt; seconds, if any of the PVs named in the file &lt;name&gt;.req have changed
value since the last write.  Other <code>create_xxx_set()</code> commands do the same thing,
but with different conditions triggering the save operation.

<P>Note that in versions prior to 2.7, <code>create_monitor_set()</code> used an
argument of type double to specify the period (in seconds).  This doesn't work on
PowerPC processors, under vWorks, so the arguments for this and similar functions
were changed to int.

<P>If your IOC takes a really long time to boot, it's possible the PVs you want to
save will not have the correct values when the save_restore task first looks at
them.  (If you are restoring lots of long arrays, this is even more likely.)
Under vxWorks, you can avoid this by putting a
<pre>
	taskDelay(&lt;number_of_60_Hz_clock_ticks&gt;)
</pre>
before <code>create_monitor_set()</code>.


<h4>12. Maintain save files</h4>

Autosave is not completely bulletproof.  Most APS beamlines have at least one
autosave related problem every year.  If autosave fails, you might be able to
detect it, or work around it, using asVerify.  This client-side program reads an
autosave .sav file and independently verifies that the values it contains agree
with current PV values.  The program can also be used to write a .sav file,
given a list of PVs.  The list of PVs is normally an autosave .sav file, but a
file containing nothing but PV names, one per line, would also work. 

Here's asVerify's command line:
<pre>
usage: asVerify [-vrd] &lt;autosave_file&gt;
         -v (verbose) causes all PV's to be printed out
             Otherwise, only PV's whose values differ are printed.
         -r (restore_file) causes a restore file named
            '&lt;autosave_file&gt;.asVerify' to be written.
         -d (debug) increment debug level by one.
         -rv (or -vr) does both
examples:
    asVerify auto_settings.sav
        (reports only PVs whose values differ from saved values)
    asVerify -v auto_settings.sav
        (reports all PVs, marking differences with '***'.)
    asVerify -vr auto_settings.sav
        (reports all PVs, and writes a restore file.)
    asVerify auto_settings.sav
    caput &lt;myStatusPV&gt; $?
        (writes number of differences found to a PV.)

NOTE: For the purpose of writing a restore file, you can specify a .req
file (or any file that contains PV names, one per line) instead of a
.sav file.  However, this program will misunderstand any 'file' commands
that occur in a .req file.  (It will look for a PV named 'file'.)
</pre>

<P>Note that asVerify cannot read an autosave request file; it will understand
any PV names contained in the file, but it cannot parse the "file" command,
perform macro substitutions, or include other request files.

<hr>
<h2>About save files</h2>
PV values in a save file have been converted to strings, in most cases simply
by having been read as strings -- e.g., <code>ca_get(DBR_STRING,...)</code>.
Most data types are read using channel access and written using dbStaticLib
calls.  Four data types get special attention:
<dl>
<dt>double
<dd>read as double, converted to string with the format "%.14g".  (Otherwise,
the record's .PREC field would limit the precision.)
<dt>float
<dd>Same as double, but the format is "%.7g".
<dt>menu and enum

<dd>Menu and enum are integer data types with values restricted to the set
(0,1,...N), where 'N' depends on the PV, but is usually 15 or smaller.  EPICS
associates a string with each number in the set, and permits clients to use
either the number or the string.  For menu PV's, the strings are specified in a
.dbd file; for enum PV's, the strings can be specified in a database file,
and they can be modified at run time.

<P>Channel access does not distinguish these types, so neither does autosave.
Autosave cannot write enums as strings, because enum strings may not have been
defined at the time they must be restored.

<dt>arrays of any kind
<dd>Arrays are read and written using database access.  Channel access cannot
read only the defined portion of an array, dbStaticLib cannot write an array.
(However, asVerify uses channel access to read arrays.)
</dl>

<P>Here is a sample save file.  Characters in <font color=blue>blue</font> are
documentation comments, and are not part of the file:
<P>
<pre>
# save/restore V4.9	Automatically generated - DO NOT MODIFY - 060720-154526
! 1 channel(s) not connected - or not all gets were successful
xxx:SR_ao.DISP 0 <font color=blue>(uchar)</font>
xxx:SR_ao.PREC 1 <font color=blue>(short)</font>
xxx:SR_bo.IVOV 2 <font color=blue>(ushort)</font>
xxx:SR_ao.SCAN 3 <font color=blue>(enum - saved/restored as a short)</font>
xxx:SR_ao.VAL 4.1234567890123 <font color=blue>(double, printed with format "%.14g")</font>
xxx:SR_scaler.RATE 1.234568 <font color=blue>(float, printed with format "%.7g")</font>
xxx:SR_ao.DESC description <font color=blue>(string)</font>
xxx:SR_ao.OUT xxx:SR_bo.VAL NPP NMS <font color=blue>(link)</font>
xxx:SR_ao.RVAL 4 <font color=blue>(long)</font>
xxx:SR_bi.SVAL 2 <font color=blue>(ulong)</font>
#i_dont_exist.VAL Search Issued <font color=blue>(no such PV)</font>
xxx:SR_char_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_double_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_float_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_long_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_short_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_string_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_uchar_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_ulong_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
xxx:SR_ushort_array @array@ { "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" }
&lt;END&gt;

</pre>

Save files are not intended to be edited manually.  If you, nevertheless, do
edit a save file, you must end it with the text
<pre>
&lt;END&gt;
</pre>
followed by one or two arbitrary characters (normally '\n' or '\r\n').  If the
file does not end with this text, reboot_restore() will assume the crate
crashed while the file was being written, or that some other bad thing
happened, and will not use the file. Once a save file has been created
successfully, save_restore will not overwrite the file unless a good ".savB"
backup file exists. Similarly, it will not overwrite the ".savB" file unless
the save file was successfully written.

<P>You can comment out lines in a .sav file by beginning them with '#'.

<hr>
<h2>User-callable functions</h2>

<dl>
<P><dt><code>int manual_save(char *request_file)</code>
<dd>If a manual save set for the request file <code>request_file</code> was created
with create_manual_set(), this command will cause current PV values to
be saved.

<P><dt><code>int set_savefile_name(char *request_file, char *save_file)</code>
<dd>If a save set has already been created for the request file, this
function will change the save file name.

<P><dt><code>int create_periodic_set(char *request_file, int period, char *macrostring)</code>
<dd>Create a save set for the request file.  The save file will be written
every <code>period</code> seconds.
	<P> See "Start the save task", above for information about the macro string.
	<P>This function can be called at any time after iocInit.

<P><dt><code>int create_triggered_set(char *request_file, char *trigger_channel,
		char *macrostring)</code>
<dd>Create a save set for the request file.  The save file will be written
	whenever the PV specified by <code>trigger_channel</code> is posted.  Normally
	this occurs when the PV's value changes.
	<P> See "Start the save task", above for information about the macro string.
	<P>This function can be called at any time after iocInit.

<P><dt><code>int create_monitor_set(char *request_file, int period, char *macrostring)</code>
<dd>Create a save set for the request file.  The save file will be written
	every <code>period</code> seconds, if any PV in the save set was posted (changed
	value) since the last write.
	<P> See "Start the save task", above for information about the macro string.
	<P>This function can be called at any time after iocInit.

<P><dt><code>int create_manual_set(char *request_file, char *macrostring)</code>
<dd>Create a save set for the request file.  The save file will be written
	when the function <code>manual_save()</code> is called with the same request-file
	name.
	<P> See "Start the save task", above for information about the macro string.
	<P>This function can be called at any time after iocInit.

<P><dt><code>int fdbrestore(char *save_file)</code>
<dd>If <code>save_file</code> refers to a save set that exists in memory, then PV's
	in the save set will be restored from values in memory.  Otherwise, this
	functions restores the PV's in &lt;saveRestorePath&gt;/&lt;save_file&gt; and creates
	a new backup file "&lt;saveRestorePath&gt;/&lt;save_file&gt.bu".  The effect
	probably will not be the same as a boot-time restore, because caput()
	calls are used instead of static database access dbPutX() calls.
	Record processing will result from caput()'s to inherently process-
	passive fields.
	<P>This function can be called at any time after one of the
	<tt>create_*_set()</tt> functions have been called.  If you want to
	call this function before creating any save sets, you can call
	<tt>create_*_set()</tt> with an empty request-file name.  Autosave will
	complain about this, but it won't think you're a bad person.

<P><dt><code>int fdbrestoreX(char *save_file)</code>
<dd>This function restores from the file &lt;saveRestorePath&gt;/&lt;save_file&gt, which
	can look just like a save file, but which needn't end in &lt;END&gt;?.  No backup
	file will be written.  The effect probably will not be the same as a
	boot-time restore, because caput() calls are used instead of static
	database access dbPutX() calls.  Record processing will result from
	caput()'s to inherently process-passive fields.
	<P>This function can be called at any time after one of the
	<tt>create_*_set()</tt> functions have been called.  If you want to
	call this function before creating any save sets, you can call
	<tt>create_*_set()</tt> with an empty request-file name.  Autosave will
	not hate you for doing this, though it will complain.

<P><dt><code>void save_restoreSet_FilePermissions(int permissions)</code>
<dd>Specify the file permissions used to create new .sav files.  This
	integer value will be supplied, exactly as given, to the system call,
	<tt>open()</tt>.  Typically, file permissions are set with an octal
	number, such as 0640, and <tt>save_restoreSet_FilePermissions()</tt>
	will confirm any number given to it by echoing it to the console as
	an octal number.
	<P>This function can be called at any time after iocInit.

<P><dt><code>void save_restoreShow(int verbose)</code>
<dd>List all the save sets currently being managed by the save_restore task.
	If (verbose != 0), lists the PV's as well.
	<P>This function can be called at any time after iocInit.

<P><dt><code>int set_requestfile_path(char *path, char *pathsub)</code>
<dd>Called before create_xxx_set(), this function specifies the path to be
	prepended to request-file names.  <code>pathsub</code>, if present, will be appended
	to <code>path</code>, if present, with a separating '/', whether or not <code>path</code> ends
	or <code>pathsub</code> begins with '/'.  If the result does not end in '/', one will
	be appended to it.
	<P>You can specify several directories to be searched for request files by
	calling this routine several times.  Directories will be searched in the
	order in which the <code>set_requestfile_path()</code> calls were made.  If you never
	call the routine, the crate's current working directory will be searched.
	If you ever call it, the current directory ("./") will be searched only if
	you've asked for it explicitly.

<P><dt><code>int set_savefile_path(char *path, char *pathsub)</code>
<dd>Called before iocInit(), this function specifies the path to be prepended
	to save-file and restore-file names.   <code>pathsub</code>, if present, will be
	appended to <code>path</code>, if present, with a separating '/', whether or not <code>path</code>
	ends or <code>pathsub</code> begins with '/'.  If the result does not end in '/', one
	will be appended to it.
	<P>If save_restore is managing its own NFS mount, this function specifies the
	mount point, and calling it will result in an NFS mount if all other
	requirements have already been met.  If a valid NFS mount already exists,
	the file system will be dismounted and then mounted with the new path name.
	This function can be called at any time.

<P><dt><code>int set_saveTask_priority(int priority)</code>
<dd>Set the priority of the save_restore task.

<P><dt><code>int remove_data_set(char *request_file)</code>
<dd>If a save set has been created for <code>request_file</code>, this function will
	delete it.

<P><dt><code>int reload_periodic_set(char *request_file, int period, char *macrostring)</code>
<dd>This function allows you to change the PV's and the period associated with
	a save set created by <code>create_periodic_set()</code>.

<P><dt><code>int reload_triggered_set(char *request_file, char *trigger_channel,
		char *macrostring)</code>
<dd>This function allows you to change the PV's and the trigger channel
	associated with a save set created by <code>create_triggered_set()</code>.

<P><dt><code>int reload_monitor_set(char * request_file, int period, char *macrostring)</code>
<dd>This function allows you to change the PV's and the period associated with
	a save set created by <code>create_monitor_set()</code>.

<P><dt><code>int reload_manual_set(char * request_file, char *macrostring)</code>
<dd>This function allows you to change the PV's associated with a save set
	created by <code>create_manual_set()</code>.

    <P>Note: Don't get too ambitious with the remove/reload functions.  You
    have to wait for one to finish completely (the save_restore task must
    get through its service loop) before executing another.  If you call
    one before the previous function is completely finished, I don't know
    what will happen.

<P><dt><code>int reboot_restore(char *save_file, initHookState init_state)</code>
<dd>This should only be called from initHooks because it can only function
	correctly if called at particular times during iocInit.

<P><dt><code>int set_pass0_restoreFile(char *save_file)</code>
<dd>This function specifies a save file to be restored during iocInit,
	before record initialization. Up to eight files can be specified using calls to this function.

<P><dt><code>int set_pass1_restoreFile(char *save_file)</code>
<dd>This function specifies a save file to be restored during iocInit,
	after record initialization.
	Up to eight files can be specified using calls to this function.

<P><dt><code>void save_restoreSet_Debug(int debug_level)</code>
<dd>Sets the value <code>(int) save_restoreDebug</code> (initially 0).  Increase to
	get more informational messages printed to the console.
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_IncompleteSetsOk(int ok)</code>
<dd>Sets the value of <code>(int) save_restoreIncompleteSetsOk</code> (initially 1).
	If set to zero, save files will not be restored at boot time unless
	they are perfect, and they will not be overwritten at save time
	unless a valid CA connection and value exists for every PV in the
	list.
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_NumSeqFiles(int numSeqFiles)</code>
<dd>Sets the value of <code>(int) save_restoreNumSeqFiles</code> (initially 3).
	This is the number of sequenced backup files to be maintained.
	<code>numSeqFiles</code> must be between 0 and 10 inclusive.  
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_SeqPeriodInSeconds(int period)</code>
<dd>Sets the value of <code>(int) save_restoreSeqPeriodInSeconds</code> (initially 60).
	Sequenced backup files will be written with this period.
	<code>period</code> must be 10 or greater.
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_RetrySeconds(int seconds)</code>
<dd>Sets the value of <code>(int) save_restoreRetrySeconds</code> (initially 60; minimum 10).
	If the .sav-file write fails, it will be retried after this interval..
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_DatedBackupFiles(int ok)</code>
<dd>Sets the value of <code>(int) save_restoreDatedBackupFiles</code> (initially 1).
	If zero, the backup file written at reboot time (a copy of the file
	from which parameter values are restored) will have the suffix '.bu',
	and will be overwritten every reboot.  If nonzero, each reboot will
	leave behind its own backup file.
	<P>This function can be called at any time.

<P><dt><code>void save_restoreSet_status_prefix(char *prefix)</code>
<dd>Specifies the prefix to be used to construct the names of PV's with
	which save_restore reports its status.  If you want autosave to update
	status PVs as it operates, you must call this function and load the
	database save_restoreStatus.db, specifying the same prefix in both
	commands.
	<P>This function must be called before the first call to <code>create_xxx_set()</code>.

<P><dt><code>void save_restoreSet_UseStatusPVs(int ok)</code>
<dd>Specifies whether save_restore should report its status to a preloaded set
	of EPICS PV's (contained in the database save_restoreStatus.db).  If the
	argument is '0', then status PV's will not be used.
	<P>This function should be called before the first call to <code>create_xxx_set()</code>.

<P><dt><code>void save_restoreSet_NFSHost(char *hostname, char *address)</code>
<dd>Specifies the name and IP address of the NFS host.  If both have been
	specified, and <code>set_savefile_path()</code> has been called to specify the file
	path, save_restore will manage its own NFS mount.  This allows save_restore
	to recover from a reboot of the NFS host (i.e., a stale file handle) and
	from some kinds of tampering with the save_restore directory.

<P><dt><code>void makeAutosaveFileFromDbInfo(char *fileBaseName, char *info_name)
</code>
<dd>Search through the EPICS database (i.e., all EPICS records loaded into an
IOC) for 'info' nodes named <code>info_name</code>; construct a list of PV
names from the associated info_values found, and write the PV names to the
file <code>fileBaseName</code>.  If <code>fileBaseName</code> does not contain the string '.req',
this string will be appended to it.  See <code>makeAutosaveFiles()</code> for more information.

<P>This function can be called at any time after iocInit().

<P><dt><code>void makeAutosaveFiles(void)
</code>
<dd>Search through the EPICS database (i.e., all EPICS records loaded into an
IOC) for <i>info</i> nodes named 'autosaveFields' and 'autosaveFields_pass0';
construct lists of PV names from the associated info values, and write the PV
names to the files 'info_settings.req' and 'info_positions.req', respectively.

<P>An info node, in an EPICS database, is similar to a field specification, but
it has the word <code>info</code> instead of <code>field</code>; and it has an
arbitrary name, instead of the name of a field in the record.  Here's an EPICS
database containing a single record with two info nodes:

<P><PRE>
record(ao, "$(P)test1") {
  field(DTYP, "Soft Channel")
  <font color="blue">info(autosaveFields, "PREC EGU DESC")
  info(autosaveFields_pass0, "VAL")</font>
}
</PRE>

<P>From this information, <code>makeAutosaveFiles()</code> will write the
following two files:

<pre>
<b><font color="blue">info_settings.req</font></b>
$(P)test1.PREC
$(P)test1.EGU
$(P)test1.DESC

<b><font color="blue">info_positions.req</font></b>
$(P)test1.VAL
</pre>

<P>This function can be called at any time after iocInit().

<P>See also:
<ul>
<li>Chapter 14, "Static Database Access", in the <i>EPICS Application Developer's
Guide</i>.
<li><code>makeAutosaveFileFromDbInfo()</code>.
</ul>

</dd>

</dl>

<h2>Example of use</h2>



---------- begin excerpt from st.cmd ----------------------

<pre>
.
.
.
<font color="blue">### autoSaveRestore setup
save_restoreSet_Debug(0)

# status-PV prefix, so save_restore can find its status PV's.
save_restoreSet_status_prefix("xxx:")

# ok to restore a save set that had missing values (no CA connection to PV)?
# ok to save a file if some CA connections are bad?
save_restoreSet_IncompleteSetsOk(1)

# In the restore operation, a copy of the save file will be written.  The
# file name can look like "auto_settings.sav.bu", and be overwritten every
# reboot, or it can look like "auto_settings.sav_020306-083522" (this is what
# is meant by a dated backup file) and every reboot will write a new copy.
save_restoreSet_DatedBackupFiles(1)

# specify where save files should go
set_savefile_path(startup, "autosave");

## specify where request files can be found
# current directory
set_requestfile_path(startup, "")
# We want to include request files that are stored with the databases they
# support -- e.g., in stdApp/Db, mcaApp/Db, etc.  The variables std and mca
# are defined in cdCommands.  The path is searched in the order in which
# directories are specified. 
set_requestfile_path(startup)
set_requestfile_path(std, "stdApp/Db")
set_requestfile_path(motor, "motorApp/Db")
set_requestfile_path(mca, "mcaApp/Db")
set_requestfile_path(ip, "ipApp/Db")
set_requestfile_path(ip330, "ip330App/Db")
# [...]

# Specify what save files should be restored when.
# Up to eight files can be specified for each pass.
set_pass0_restoreFile("auto_positions.sav")
set_pass0_restoreFile("auto_settings.sav")
set_pass1_restoreFile("auto_settings.sav")

set_pass0_restoreFile("info_positions.sav")
set_pass0_restoreFile("info_settings.sav")
set_pass1_restoreFile("info_settings.sav")
# [...]

# Number of sequenced backup files (e.g., 'auto_settings.sav0') to write
save_restoreSet_NumSeqFiles(3)

# Time interval between sequenced backups
save_restoreSet_SeqPeriodInSeconds(600)

# Time between failed .sav-file write and the retry.
save_restoreSet_RetrySeconds(60)

# NFS host name and IP address
save_restoreSet_NFSHost("oxygen", "164.54.52.4")</font>
.
.
.
dbLoadDatabase("../../dbd/xxxApp.dbd")
.
.
.
<font color="blue">dbLoadRecords("$(AUTOSAVE)/asApp/Db/save_restoreStatus.db", "P=xxx:")</font>
.
.
.
iocInit
.
.
.
<font color="blue">### Start up the save_restore task and tell it what to do.
# The task is actually named "save_restore".
#
# save positions every five seconds
create_monitor_set("auto_positions.req", 5, "P=xxx:")
# save other things every thirty seconds
create_monitor_set("auto_settings.req", 30, "P=xxx:")

# Handle autosave 'commands' contained in loaded databases.
makeAutosaveFiles()
create_monitor_set("info_positions.req", 5, "P=xxx:")
create_monitor_set("info_settings.req", 30, "P=xxx:")

</font>
.
.
.
</pre>
---------- end excerpt from st.cmd ----------------------

<address>
    Suggestions and Comments to: <br>
    <a href="mailto:mooney@aps.anl.gov">Tim Mooney </a>:
    (mooney@aps.anl.gov) <br>
    Last modified: Nov. 13, 2008 
</address>
</body>
</html>
