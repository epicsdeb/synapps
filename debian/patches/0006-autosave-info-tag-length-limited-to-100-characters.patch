From: Michael Davidsaver <mdavidsaver@bnl.gov>
Date: Fri, 10 Sep 2010 14:11:06 -0400
Subject: [PATCH] autosave: info tag length limited to 100 characters

Remove artificial limitation of using fixed size temp
buffer for the entire info tag.  Instead use a smaller
buffer for each field name.  Surely no record has field
names longer then 29 characters.
---
 autosave/asApp/src/dbrestore.c |   47 +++++++++++++++++++++++++++++++--------
 1 files changed, 37 insertions(+), 10 deletions(-)

diff --git a/autosave/asApp/src/dbrestore.c b/autosave/asApp/src/dbrestore.c
index 8e03f93..864bf33 100644
--- a/autosave/asApp/src/dbrestore.c
+++ b/autosave/asApp/src/dbrestore.c
@@ -1221,7 +1221,8 @@ long SR_write_array_data(FILE *out_fd, char *name, void *pArray, long num_elemen
 	return(n);
 }
 
-#define BUFFER_SIZE 100
+/* Surely this is enough... */
+#define MAX_FIELD_SIZE 30
 /*
  * Look through the database for info nodes with the specified info_name, and get the
  * associated info_value string.  Interpret this string as a list of field names.  Write
@@ -1232,24 +1233,31 @@ void makeAutosaveFileFromDbInfo(char *fileBaseName, char *info_name)
 {
 	DBENTRY		dbentry;
 	DBENTRY		*pdbentry = &dbentry;
-	const char *info_value, delimiters[] = " \t\n\r.";
-	char		buf[BUFFER_SIZE], *field, *fields=buf;
+	const char *info_value, *pbegin, *pend;
+	char		*fname, *falloc=NULL, field[10];
 	FILE 		*out_fd;
-	int			searchRecord;
+	int			searchRecord ,flen;
 
 	if (!pdbbase) {
 		errlogPrintf("autosave:makeAutosaveFileFromDbInfo: No Database Loaded\n");
 		return;
 	}
 	if (strstr(fileBaseName, ".req")) {
-		strncpy(buf, fileBaseName, BUFFER_SIZE);
+		fname=fileBaseName;
 	} else {
-		sprintf(buf, "%s.req", fileBaseName);
+		fname=falloc=malloc(strlen(fileBaseName)+sizeof(".req"));
+		if (!fname) {
+			errlogPrintf("save_restore:makeAutosaveFileFromDbInfo - allocation failed\n");
+			return;
+		}
+		sprintf(fname, "%s.req", fileBaseName);
 	}
-	if ((out_fd = fopen(buf,"w")) == NULL) {
-		errlogPrintf("save_restore:makeAutosaveFileFromDbInfo - unable to open file '%s'\n", buf);
+	if ((out_fd = fopen(fname,"w")) == NULL) {
+		errlogPrintf("save_restore:makeAutosaveFileFromDbInfo - unable to open file '%s'\n", fname);
+		free(falloc);
 		return;
 	}
+	free(falloc);
 
 	dbInitEntry(pdbbase,pdbentry);
 	/* loop over all record types */
@@ -1267,13 +1275,32 @@ void makeAutosaveFileFromDbInfo(char *fileBaseName, char *info_name)
 			info_value = dbGetInfo(pdbentry, info_name);
 			if (info_value) {
 				/* printf("record %s.autosave = '%s'\n", dbGetRecordName(pdbentry), info_value); */
-				strncpy(fields, info_value, BUFFER_SIZE);
-				for (field = strtok(fields, delimiters); field; field = strtok(NULL, delimiters)) {
+				pbegin = info_value;
+
+				for(;*pbegin && isspace(*pbegin); pbegin++) {} /* skip leading whitespace */
+
+				while (pbegin && *pbegin && !isspace(*pbegin)) {
+					pend = pbegin;
+
+					/* find end of field */
+					for(;*pend && !isspace(*pend); pend++) {}
+					/* pend points to whitespace or \0 */
+
+					flen = pend-pbegin;
+					if (flen >= sizeof(field)-1) flen = sizeof(field)-1;
+					memcpy(field, pbegin, flen);
+					field[flen]='\0';
+
 					if (dbFindField(pdbentry, field) == 0) {
 						fprintf(out_fd, "%s.%s\n", dbGetRecordName(pdbentry), field);
 					} else {
 						printf("makeAutosaveFileFromDbInfo: %s.%s not found\n", dbGetRecordName(pdbentry), field);
 					}
+
+					pbegin = pend;
+
+					for(;*pbegin && isspace(*pbegin); pbegin++) {} /* skip leading whitespace */
+					
 				}
 				}
 			}
-- 
